I"8<h2 id="before-we-start">Before we start</h2>
<p>과제를 하면서 내가 아직 모르는 부분이 많다는 것을 느꼈다. 문제를 풀어보면 각 연산자의 특징으로 사용할 것을 짐작하고, 가능한 각 경우의 수를 테스트한 경우가 많았다. 그런데 각 연산자를 제대로 알지 못하다보니 생각보다 오랜 시간이 걸렸다. 그래서 과제를 설명하기 전에 어떤 성질이 있는지를 알고 있으면 편하게 풀 수 있다. 핵심적인 것은 Tmax, 1, 0, -1, Tmin을 어떻게 바꾸는지, 그리고 각 연산자를 사용하는 몇 가지 팁을 정리하려고 한다.</p>

<h3>&amp;</h3>
<p>&amp;는 두 operhands가 모두 1일 경우만 1이 되고, 그 외에는 0이 된다. 그리고 x와 Tmax, 1, 0, -1, Tmin과의 연산을 살펴보자.</p>

<p>Tmax는 0111…11의 형태이므로 &amp;를 사용하면 부호를 제외한 나머지 비트 벡터를 구할 수 있다.</p>

<p>1은 마지막 비트를 구할 수 있다. 이는 »와 같이 쓰면 부호를 구하는데 굉장히 유용하다. 어떤 수의 부호를 구하고 싶다면 그 비트를 오른쪽으로 밀어주는 것을 생각한다. 그러므로 가장 먼저 떠올리는 것은 <code class="language-plaintext highlighter-rouge">x &gt;&gt; 31</code>이 된다. 하지만 이는 양수에서만 잘 작동하고 음수에서는 잘 작동하지 않는다. 왜냐하면 »는 비트를 오른쪽으로 밀어준 후에 제일 왼쪽 비트를 넣어주는데, 음수는 1이 계속 복사되므로 원하는 대로 부호 비트만 남지 않는다. 그래서 <code class="language-plaintext highlighter-rouge">&amp; 1</code>과 같이 사용해서 <code class="language-plaintext highlighter-rouge">(x &gt;&gt; 31) &amp; 1</code>로 사용하면 부호를 간단히 구할 수 있다.</p>

<p>0과의 연산은 무조건 0이 나오기 때문에 그다지 쓸만하지는 않다.</p>

<p>-1과의 연산은 해당 수를 그대로 내놓는다.</p>

<p>Tmin과의 연산은 부호 비트를 계산하는데 사용할 수 있다. 이 경우 부호 비트가 제일 왼쪽에 남기 때문에 그대로 사용하거나, 앞서 말한 <code class="language-plaintext highlighter-rouge">(x &gt;&gt; 31) &amp; 1</code>과 함께 사용해서 <code class="language-plaintext highlighter-rouge">((x &amp; Tmin) &gt;&gt; 31) &amp; 1</code>로 써도 된다.</p>

<h3 id="-1">|</h3>
<p>|가 유용한 점은 if-else 형태를 사용할 수 있다는 점이다. 예를 들어서 아래와 같은 코드를 작성하고 싶다고 하자.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (condition) {
  code1
} else {
  code2
}
</code></pre></div></div>

<p>하지만 우리 과제에서 if-else를 사용하는 것을 제한했기 때문에 사용할 수 없다. 대신 <code class="language-plaintext highlighter-rouge">(condition) &amp; code1 | !(condition) &amp; code2</code> 형태로 이를 대체할 수 있다. 물론 &amp;를 사용하기 때문에 condition이 어떤 결과값을 내놓는지와 code1, code2를 잘 조율해야 한다. 확실한 것은 조건에 따라 나뉘는 경우에 1순위로 생각할 수 있는 방법이다.</p>

<h3 id="-2">~</h3>
<p>~를 Tmax, 1, 0, -1, Tmin에 사용하면 각각 Tmin, -2, -1, 0, Tmax가 된다. 보통은 <code class="language-plaintext highlighter-rouge">-x = ~x + 1</code>을 이용해서 -x를 구하는데 사용한다. 만약 -를 각각 Tmax, 1, 0, -1, Tmin에 적용하면 각각 Tmin + 1, -1, 0, 1, Tmin이 된다. 여기서 눈여겨 볼 점은 0과 Tmin이 그대로 자기자신이 된다는 점이다.</p>

<h3 id="-3">^</h3>
<p>^는 같은 수끼리 사용했을 경우에만 0이 된다. 그러므로 딱 하나 예외를 둔 경우에 사용되는 경우가 많다. 또한 결과값을 바꿔주는데도 유용하다. 예를 들어 어떤 코드가 0을 넣으면 0이 나오고, 1을 넣으면 1이 나온다고 하자. 그런데 이 결과를 서로 바꾸고 싶을 수도 있다. 이 때 ^를 사용해서 <code class="language-plaintext highlighter-rouge">code ^ 1</code>로 써주면 0은 1이 되고 1은 0이 되는 결과를 간단히 만들 수 있다. 다음으로 Tmax, 1, 0, -1, Tmin과의 연산 결과는 각각 아래 테이블처럼 된다.</p>

<table>
  <thead>
    <tr>
      <th>^</th>
      <th>Tmax</th>
      <th>1</th>
      <th>0</th>
      <th>-1</th>
      <th>Tmin</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Tmax</td>
      <td>0</td>
      <td>0111…10</td>
      <td>Tmax</td>
      <td>Tmin</td>
      <td>-1</td>
    </tr>
    <tr>
      <td>1</td>
      <td>0111…10</td>
      <td>0</td>
      <td>1</td>
      <td>1111…10</td>
      <td>1000…01</td>
    </tr>
    <tr>
      <td>0</td>
      <td>Tmax</td>
      <td>1</td>
      <td>0</td>
      <td>-1</td>
      <td>Tmin</td>
    </tr>
    <tr>
      <td>-1</td>
      <td>Tmin</td>
      <td>111…10</td>
      <td>-1</td>
      <td>0</td>
      <td>Tmax</td>
    </tr>
    <tr>
      <td>Tmin</td>
      <td>-1</td>
      <td>1000…01</td>
      <td>Tmin</td>
      <td>Tmax</td>
      <td>0</td>
    </tr>
  </tbody>
</table>

<h3 id="-4">!</h3>
<p>!으로 0을 1로 그 외의 수를 0으로 만들 수 있다. 이를 이용해서 <code class="language-plaintext highlighter-rouge">!!x</code>를 사용하면 0은 0으로 보내고, 그 외의 수는 1로 보내줄 수 있다.</p>

<h2 id="lab1-datalab">Lab1 datalab</h2>
<p>이 과제에세 제출하면 되는 것은 <strong>bits.c</strong> 파일뿐으로, 13개의 프로그래밍 퍼즐을 포함하고 있다. 각 과제의 뼈대 함수를 정수에 사용하는 기본적인 코드만으로 완성시켜야 하는데, 반복문이나 조건문 같은 것은 사용할 수 없다. 다시 말해 <strong>!, ~, &amp;, ^, |, +, «, » 만으로 코드를 완성 시켜야 한다.</strong> 또한 8bits보다 긴 상수를 사용할 수 없다. 자세한 것은 <strong>bits.c</strong> 파일의 주석을 확인하자.</p>

<h2 id="evaluation">Evaluation</h2>

<h3 id="correctness-points">Correctness points</h3>
<p>각 문제는 난이도별로 1~4점으로 배점되어 있으며 총합 36점이다. 작성한 함수는 <strong>btest</strong>라는 프로그램으로 채점하며 다음 장에 사용법이 있다.</p>

<h3 id="performance-points">Performance points</h3>
<p>이 과제의 목적은 단순히 문제를 푸는 것 만이 아니라, 최대한 짧고 간단하게 코드를 작성하는 법을 배우는 것이다. 그래서 각 함수마다 사용가능한 연산 횟수를 지정해놓았는데, 이 값은 굉장히 커서 심각하게 비효율적인 경우가 아니라면 통과할 수 있다. 각 조건을 만족하면 2점씩 받는다.</p>

<h2 id="autograding-your-work">Autograding your work</h2>
<p>-<strong>btest</strong>: bits.c 안의 함수의 정확도를 확인한다. 사용하려면 <code class="language-plaintext highlighter-rouge">make</code>-&gt;<code class="language-plaintext highlighter-rouge">./btest</code>로 사용할 수 있다. 중요한 것은 bits.c 파일을 수정할 때마다 btest를 다시 작동시켜야 한다. 또한 -f를 사용하면 각 함수별로 체크하는 것도 가능하다. 예를 들어 <code class="language-plaintext highlighter-rouge">./btest -f bitXor</code>라고 쓰면, bitXor만 체크한다.
-<strong>dlc</strong>: 이 프로그램은 사용하면 안 되는 연산자를 사용하거나, 너무 많은 연산자를 사용하는 등의 결함을 검출해주는 프로그램이다. <code class="language-plaintext highlighter-rouge">./dlc bits.c</code>로 작동 가능하다. 추가로 -e를 사용해서 각 함수별로 얼마나 많은 연산자를 사용했는지 검사할 수 있다. <code class="language-plaintext highlighter-rouge">./dlc -e bits.c</code>
-<strong>driver.pl</strong>: btest와 dlc를 사용해서 정확도와 효율성 점수를 채점한다. <code class="language-plaintext highlighter-rouge">./driver.pl</code>로 사용하면 되며 과제의 채점은 driver.pl로 하면 된다.</p>

<h2 id="solve">Solve</h2>

<h3 id="bitxor">bitXor</h3>
<p>^를 &amp;와 ~만으로 구현해야 한다. 간단히 ^, &amp;, ~를 테이블로 한 번 표현해보겠다.</p>

<table>
  <thead>
    <tr>
      <th>^</th>
      <th>1</th>
      <th>0</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <td>0</td>
      <td>1</td>
      <td>0</td>
    </tr>
  </tbody>
</table>

<table>
  <thead>
    <tr>
      <th>&amp;</th>
      <th>1</th>
      <th>0</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
  </tbody>
</table>

<table>
  <thead>
    <tr>
      <th>~</th>
      <th>0</th>
      <th>1</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td> </td>
      <td>1</td>
      <td>0</td>
    </tr>
  </tbody>
</table>

<p>여기서 &amp;를 생각해보자. &amp;는 기본적으로 1이 나오는 경우의 수를 줄이는 연산이다. 그렇기 때문에 우리가 ^를 만들고 싶다면 아래 두 결과를 만들어서 &amp;를 사용해줘야 한다.</p>

<table>
  <thead>
    <tr>
      <th>a</th>
      <th>1</th>
      <th>0</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>1</td>
      <td>1</td>
    </tr>
    <tr>
      <td>0</td>
      <td>1</td>
      <td>0</td>
    </tr>
  </tbody>
</table>

<table>
  <thead>
    <tr>
      <th>b</th>
      <th>1</th>
      <th>0</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <td>0</td>
      <td>1</td>
      <td>1</td>
    </tr>
  </tbody>
</table>

<p>그렇다면 a와 b는 무엇이 될 수 있을까? 이는 ~이 1과 0을 바꾸는 연산임을 기억하면 쉽게 유추할 수 있다. a와 bㅇ에 ~을 붙이면 아래처럼 된다.</p>

<table>
  <thead>
    <tr>
      <th>~a</th>
      <th>1</th>
      <th>0</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <td>0</td>
      <td>0</td>
      <td>1</td>
    </tr>
  </tbody>
</table>

<table>
  <thead>
    <tr>
      <th>~b</th>
      <th>1</th>
      <th>0</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
  </tbody>
</table>

<p>이 둘은 모양만 봐도 &amp;로 쉽게 만들 수 있다. 즉 ~a = (~x &amp; ~y)가 되고, ~b = (x &amp; y)가 된다. 다시 말해서 a = ~(~x &amp; ~y), b = ~ (x &amp; y)고 ^ = a &amp; b = ~(x &amp; y) &amp; ~(~x &amp; ~y)로 계산할 수 있다.</p>

<p>또는 ~x &amp; y와 x &amp; ~y의 결과로도 만들 수 있다. 이 경우도 살펴보자. 우선 두 연산의 결과는 아래와 같다.</p>

<table>
  <thead>
    <tr>
      <th>x &amp; ~y</th>
      <th>1</th>
      <th>0</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
  </tbody>
</table>

<table>
  <thead>
    <tr>
      <th>~x &amp; y</th>
      <th>1</th>
      <th>0</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <td>0</td>
      <td>1</td>
      <td>0</td>
    </tr>
  </tbody>
</table>

<p>그리고 이들에 ~을 붙인 다음 &amp;를 계산하고 다시 ~을 붙이면 된다. 결국 ~(~(x &amp; ~y) &amp; ~(~x &amp; y))도 답이 된다.</p>

<p>결국 내가 찾아낸 답은 2가지로 하나는 ~(x &amp; y) &amp; ~(~x &amp; ~y)이고, 다른 하나는 ~(~(x &amp; ~y) &amp; ~(~x &amp; y))다. 다만 연산자의 수가 전자가 7개 후자가 8개이므로 전자를 사용하는 것이 더 적절하다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int bitXor(int x, int y) {
  return ~(x &amp; y) &amp; ~(~x &amp; ~y);
}
</code></pre></div></div>

<h3 id="tmin">tmin</h3>
<p>2의 보수 중에서 가장 작은 값을 반환하는 함수다. 2의 보수 계산법을 기억해보면 가장 작은 수는 10000…000이다. 그러므로 1000…00을 만들면 된다. 해법은 간단히 1 « 31을 하면 된다. 이는 32bits에만 성립하므로 다른 환경에서도 똑같은 결과가 나오는 것을 고민해봤지만, logical shift 없이는 할 수 있는 방법을 찾지 못했다. 문제의 조건에서 제약이 많아서 아마 이 외의 답은 없을듯 하다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int tmin(void) {
  return 1 &lt;&lt; 31;
}
</code></pre></div></div>

<h3 id="istmax">isTmax</h3>
<p>x가 들어왔을 때, 2의 보수의 최대값이면 1을 아니라면 0을 반환하면 된다. 사용가능한 연산은 !, ~, &amp;, ^, |, +로 shift를 사용할 수 없다.</p>

<p>당연히 문제를 보는 순간 !(x ^ 0x7FFFFFFF)를 떠올릴 것이다. 하지만 우리는 너무 큰 상수를 사용할 수 없게 되어 있다. 그러므로 저 수를 직접 만들어주거나, 다른 방향으로 접근해야 한다.</p>

<p>우리가 사용할 수 있는 수 중에서 의미있는 것은 사실상 x, 1, 0 뿐이다. 왜냐하면 나머지 2, 3, … 등은 1의 합으로 표현될 뿐더러 별다른 특성이 없다. 그러므로 x, 1, 0에 위의 연산을 넣었을 경우를 생각해보자.</p>

<p>!는 0인 경우만 1이 되고 나머지 경우는 0이 된다. 우리 문제의 경우 최대값인 경우에만 1이 나오고 나머지 경우는 0이 나와야 한다. 어떤형식으로 사용될지는 아직 모르지만 확실한 것은 !이 사용되어야 한다는 것이다.</p>

<p>~은 간단한 방법으로 수를 확장해준다. ~x(-x-1), ~1(-2), ~0(-1)이 사용가능한데 ~1은 그다지 의미 없는 수이므로, ~로 수를 확장하면 x, 1, 0, -1, ~x를 사용가능하다고 생각해도 된다.</p>

<p>&amp;은 두 수가 1일 경우에만 1이 나온다. &amp;는 결국 두 수가 얼마나 비슷한지와 관련된 연산이다. 그래서 x와 1, 0, -1, ~x를 계산해봐도 그다지 의미있는 수는 나오지 않으므로 &amp;는 사용되지 않는다.</p>

<p>^는 두 수가 완전히 같을 때만 0이 나온다. 우리가 원하는 경우가 하나 뿐인 경우에 사용할 수 있다.</p>

<table>
  <tbody>
    <tr>
      <td>는 경우의 수를 표현하기 좋아서 예외 사항이 하나 있을 경우 사용가능하다.</td>
    </tr>
  </tbody>
</table>

<p>다시 돌아가서 우리가 1이 나오길 원하는 수는 Tmax(011…11)이다. Tmax로 생각해볼 수 있는 유의미한 계산은 다음과 같다.</p>

<ul>
  <li>Tmax + 1 = Tmin</li>
  <li>2 * Tmax + 2 = 0</li>
</ul>

<p>그 중에서 아래 식을 사용해서 문제를 풀어봤다.</p>

<p>2 * Tmax + 2는 사실 2 * (Tmax + 1)이고 2를 곱하는 것은 수를 왼쪽으로 한 칸씩 미는 것과 동일하다. 결국 저 식을 해석하자면 Tmax에 1을 더하면 100…00이 되고 이를 왼쪽으로 한 칸 밀어주면 0이 된다는 것이다. 만약 Tmax만 이를 만족한다면 !를 사용해서 굉장히 간단하게 해결할 수 있다. 문제는 -1(111…11) 또한 이를 만족한다는 사실이다. 그 외의 수는 별 문제 없이 만족하므로 저 경우만 해결해주면 된다.</p>

<p>지금까지의 분석 결과를 정리하면,</p>

<ul>
  <li>마지막에 !를 써서 Tmax만 1로 만든다.</li>
  <li>2 * (Tmax + 1) = 0을 써야한다. shift가 허용되지 않으므로 x + x + 2를 쓴다.</li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>-1의 경우만 예외 처리해야 하므로</td>
          <td>를 사용한다.</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<table>
  <tbody>
    <tr>
      <td>결국 식은 !((x + x + 2)</td>
      <td>(x+1))의 형태에서 조금 조정을 해줘야 한다. x가 Tmax라면 !(0</td>
      <td>1) 이라서 0이 되고, x가 -1이면 !(0</td>
      <td>0)이라서 0이 된다. 그 외의 숫자는 !(1</td>
      <td>1)로 0이 된다. 이는 우리가 원하던 결과가 아니니 조금 수정이 필요하다. 그런데 우리가 원하는 결과는 각각 !(0</td>
      <td>0), !(0</td>
      <td>1), !(1</td>
      <td>0)이 되는 경우로 마지막 수가 반대로 되면 된다. 그러므로 !를 사용하면 간단히 해결할 수 있다. 결국 식은 **!((x + x + 2)</td>
      <td>!(x + 1))**이 되어야 한다.</td>
    </tr>
  </tbody>
</table>

<h3 id="alloddbits">allOddBits</h3>
<p>홀수번째에 모두 1이 있는지 확인하는 문제다. 단, least significant digit이 0번째이고, most significant digit이 31번째로 생각해야 한다. 이는 만약 0xAAAAAAAA를 사용할 수 있다면 굉장히 간단하다. 왜냐하면 x &amp; 0xAAAAAAAA으로 짝수번째 자리는 수에 상관 없이 0으로 만들고, 홀수번째가 1인 경우에만 1로 만든다. 그 다음 이를 Xor로 0xAAAAAAAA와 비교해서 수가 같은 경우만 남기면 된다. 왜냐하면 Xor로 수가 같지 않다는 뜻은 홀수 번째에 1이 없다는 의미기 때문이다. 마지막으로 Xor을 사용하면 둘이 같을 경우 0이 나오므로 !를 사용해서 값을 바꿔줘야 한다. 결국 답은 !((x &amp; 0xAAAAAAAA) ^ 0xAAAAAAAA)가 된다.</p>

<p>문제는 상수로 사용할 수 있는 수가 0x00~0xFF가 끝이라는 것이다. 이 보다 큰 수는 상수로 사용할 수 없도록 해놓았으므로 직접 만들어줘야 한다. 이는 «로 굉장히 간단히 해결할 수 있다. 8칸 밀어주고 원래 수를 더하고, 다시 16칸 밀어주고 원래 수를 더해주면 된다. 결국 정답은 다음처럼 된다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int allOddBits(int x) {
  int AAAAAAAA = 0xAA;
  AAAAAAAA += AAAAAAAA &lt;&lt; 8;
  AAAAAAAA += AAAAAAAA &lt;&lt; 16;
  return !((x &amp; AAAAAAAA) ^ AAAAAAAA);
}
</code></pre></div></div>

<h3 id="negate">negate</h3>
<p>-x를 구하면 되는 굉장히 간단한 문제다. ~x = -x -1이므로, -x = ~x + 1이 된다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int negate(int x) {
  return ~x + 1;
}
</code></pre></div></div>

<h3 id="isasciidigit">isAsciiDigit</h3>
<p>부등호를 표현하는 식을 구현할 수 있는지 묻는 문제다. $a \leq b$ 식을 다르게 표현하면 $0 \leq b - a$가 된다. 여기서 $-a$는 $~a + 1$로 구할 수 있으므로 식은 $0 \leq b + ~a + 1$이 된다. 결국 우리는 $b + ~a +1$이 0이상인지 여부를 확인할 수 있으면 된다. 수가 만약 음수라면 제일 앞의 비트가 1일 것이므로, 제일 앞 자리 비트를 확인해주면 된다. 지금까지의 아이디어를 코드로 바꾸면 <code class="language-plaintext highlighter-rouge">(b + ~a + 1) &gt;&gt; 31</code>인데, 수가 양수일 경우엔 0이 되고, 음수일 경우엔 1이 된다. 우리는 결과값이 반대로 되길 원하므로 !를 사용해서 반대로 적용해준다. <code class="language-plaintext highlighter-rouge">!(b + ~a + 1) &gt;&gt; 31</code></p>

<p>우리가 적용해야 하는 범위는 0x30에서 0x39까지 이므로 식이 두 개가 나오고 둘 다 만족해야 한다. 그러므로 식은 <code class="language-plaintext highlighter-rouge">!(0x39 + ~x + 1) &gt;&gt; 31 &amp; !(x + ~0x30 + 1) &gt;&gt; 31</code>이다.</p>

<h3 id="conditional">conditional</h3>
<p>x ? y : z를 구현하는 문제다. 우선 x가 참이면 1이 나오고 거짓이면 0이 나와야 한다. 이는 !!(x)로 간단히 할 수 있다. 그리고 if/else와 같은 효과를 위해 |를 사용한다. 형태는 (condition1) &amp; y | (condition2) &amp; z 형태가 되어야 한다. 그리고 condition1, 2는 x가 참, 거짓일 경우 번갈아가며 111…111이 되고 거짓일 경우 000…000이 되도록 하면 된다.</p>

<p>우선 왼쪽 조건을 구하면 !를 사용해서 오른쪽도 적절히 수정가능할 것이다. 그러므로 왼쪽 조건부터 구해보겠다. x를 !!x로 참인 경우는 1로 거짓인 경우는 0으로 일괄적으로 바꿀 수 있다. 그러므로 우리가 해야할 것은 1일 경우 111…111이 되고, 0일 경우 000…000이 되도록 하면 된다. 수를 잘 살펴보면 111…111은 -1이고 000…000은 -0이다. 다시 말해서 a에 -를 붙여주는 연산인 ~a+1을 해줘야 한다. 그러므로 왼쪽 조건은 ~!!x+1이 된다.</p>

<p>왼쪽 조건을 찾았으므로 오른쪽도 찾아보자. 우선 ~a+1이 a가 1일 경우엔 111…111이 되고, 0일 때는 0이 된다. 왼쪽에는 x가 참일 때 a에 1을 넣고, 거짓일 때 0이 들어가야 했다. 반대로 오른쪽에는 x가 참일 때 0을 넣고, 거짓일 경우 1이 들어가야 한다. 이는 간단히 !를 사용하면 해결된다. 그러므로 오른쪽의 a에 들어갈 것은 !!!x가 된다. !!는 의미가 없으므로 간단히 !x로 정리해준다. 결과적으로 식은 아래처럼 된다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int conditional(int x, int y, int z) {
  return ((~!!x+1) &amp; y) | ((~!x+1) &amp; z);
}
</code></pre></div></div>

<h3 id="islessorequal">isLessOrEqual</h3>
<p>y-x &gt;= 0을 그대로 이용하면 비트의 범위를 벗어나 오류가 발생한다. 그러므로 수의 부호를 바탕으로 계산해야 한다. 우선 둘의 부호가 같은 경우, y - x를 해도 표현 가능한 범위를 벗어나지 않는다. 서로 부호가 다르다면 수의 크기를 비교할 필요 없이 부호만으로 계산이 가능하다.</p>

<p>우선 어떤 수가 주어졌을 때, 부호를 알아낼 수 있어야 한다. 단순히 shift만으로 해결되지 않는 것이, arithmetic shift이기 때문에 오른쪽으로 밀어줘도 왼쪽에 sign digit이 하나씩 추가 되기 때문이다. 그래서 shift 이후에 &amp; 1을 사용해서 첫 번째 자리만 남기고 나머지는 없애 줘야 한다.</p>

<p>두 수의 부호가 같은지를 확인할 때는 앞에서 구한 x_sign과 y_sign을 이용하면 바로 구할 수 있다. 이 때는 &amp;1을 해줄 필요가 없는 것이 어차피 000…001, 000…000으로만 ^ 연산을해서 마지막 자리 빼고는 모두 확실히 0이 된다.</p>

<p>if문 또는 conditional을 구현하는 것을 기억하면 조건문은 <code class="language-plaintext highlighter-rouge">(condition) &amp; ... | (!condition) &amp; ...</code>으로 나타난다. 여기서 우리는 두 부호가 동일한지 아닌지에 따라 갈리므로 condition은 <code class="language-plaintext highlighter-rouge">x_sign ^ y_sign</code> 이 된다. 만약 두 부호가 동일하다면 앞서 말했듯이 y-x로도 범위를 벗어나지 않으므로 계산 결과의 부호를 사용해주면 된다. 부호가 다르다면 x의 부호가 -라면 자동적으로 y가 더 크게 된다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int isLessOrEqual(int x, int y) {
  int calc = y + ~x + 1;
  int calc_sign = (calc &gt;&gt; 31) &amp; 1;
  int x_sign = (x &gt;&gt; 31) &amp; 1;
  int y_sign = (y &gt;&gt; 31) &amp; 1;
  int xor_sign = x_sign ^ y_sign;
  return (xor_sign &amp; x_sign) | ((!xor_sign) &amp; (!calc_sign));
}
</code></pre></div></div>

<h3 id="logicalneg">logicalNeg</h3>
<p>!를 사용하지 않고 !를 만드는 문제다. !는 0일 경우만 1이 되고 그 외에는 모두 0이 된다. 즉, 어느 한 경우만 특징적인 것이 있는 연산을 사용해야 한다. binary operator들의 연산결과를 생각해보자. x &amp; y, x | y, x ^ y를 가지고 0인 경우와 0이 아닌 경우를 찾아내야 한다.</p>

<p>연산자에 따라 각 수의 계산 값으로 그룹을 나뉘어서 0과 그 외의 수를 나누어야 한다. 그런데 x가 주어졌을 때, 그와 다른 수를 만들어내는 것은 사실상 ~x 뿐이다. 그러므로 x와 비교할 수 있는 수는 ~x와 -x밖에 없다. 그러므로 위의 연산으로 x와 ~x, -x를 비교했을 때, 0인 경우와 아닌 경우로 나뉜다면 이를 가지고 logicalNeg를 만들 수 있다.</p>

<p>&amp;의 경우 x &amp; ~x는 무조건 0이 되므로 아무런 의미가 없다. x &amp; -x는 그룹이 나뉘기는 하는데, 값이 나오는 비트의 위치가 랜덤하기 때문에 해결법이 없어 보인다.</p>

<p>다음으로 ^를 살펴보자. x ^ ~x는 무조건 111…111이 나와서 아무런 쓸모가 없다. 대신 x ^ -x는 x가 0, Tmin인 경우만 0이 되고, 나머지 경우는 첫 번째 비트가 1이 된다. 이를 이용해서 풀 수도 있다.</p>

<table>
  <tbody>
    <tr>
      <td>마지막으로</td>
      <td>를 알아보자. x</td>
      <td>~x 역시 111…11만 결과값으로 나와서 의미없다. x</td>
      <td>-x는 x가 0인 경우만 0이 되고, 그 외의 경우는 첫 번째 비트가 1이 된다.</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>결과적으로 ^와</td>
      <td>이 적절해 보인다. 그런데 ^는 Tmin을 걸러주는 과정이 한 번 더 필요하므로 좀 더 복잡하다. 그러므로</td>
      <td>를 이용해서 풀어보도록 하자. 0인 경우와 그 외의 경우는 첫 번째 비트가 0 또는 1로 나오는 차이를 보인다. 그러므로 첫 번째 비트가 1인지 아닌지로 분류할 수 있다. <code class="language-plaintext highlighter-rouge">((x | (~x + 1)) &gt;&gt; 31)</code>를 보면 x가 0인 경우는 0이 되고, 그 외에는 111…11이 된다. 여기서 마지막 비트만 남도록 &amp; 1을 해주면 0과 0…01인 경우로 나뉜다. <code class="language-plaintext highlighter-rouge">((x | (~x + 1)) &gt;&gt; 31) &amp; 1</code></td>
    </tr>
  </tbody>
</table>

<p>그런데 여기서 0인 경우는 0이 나오고 1인 경우는 1이 나온다. 하지만 우리는 0을 1로 보내고, 1을 0으로 보내고 싶다. 이는 ^ 연산 테이블을 기억하면 간단히 해결할 수 있다. 왜냐하면 0 ^ 1 = 1, 1 ^ 1 = 0 이기 때문이다. 그러므로 최종적으로 식은 <code class="language-plaintext highlighter-rouge">(((x | (~x + 1)) &gt;&gt; 31) &amp; 1) ^ 1;</code>이 된다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int logicalNeg(int x) {
  return (((x | (~x + 1)) &gt;&gt; 31) &amp; 1) ^ 1;
}
</code></pre></div></div>

<p>그런데 곰곰히 생각해보니 <code class="language-plaintext highlighter-rouge">((x|(~x+1))&gt;&gt;31)+1;</code>을 쓰면 더 간단히 해결된다. 왜냐하면 <code class="language-plaintext highlighter-rouge">((x | (~x + 1)) &gt;&gt; 31)</code>에서 0은 0이 되고, 그 외의 수는 -1이 되기 때문이다.</p>

<h3 id="howmanybits">howManyBits</h3>
<p>이 문제는 내가 풀면서 제일 오래 걸린 문제다. 우선 예시를 보면서부터 문제가 생겼다. -1을 표현하는데 1bit 만으로 충분하다는 예를 봤기 때문이다. 아무런 생각없이 비트가 1개 뿐이라면 0과 1을 표현할 것이라 생각했는데, 2의 보수 표기법으로 나타내면 0과 -1이 된다는 것을 떠올렸다. 그리고 -1을 표현하는 방법이 다양함을 기억해냈다. 111…111, …, 11, 1 모두 -1을 표현한다. 다른 음수도 마찬가지인데 예를 들어서 -5는 1011, 11011, 111011 등으로 표현할 수 있다. 규칙을 찾아보면 왼쪽에 1이 2번 나올 경우 제일 왼쪽 비트를 지울 수 있다는 점을 알 수 있다. 그러므로 음수에서는 제일 왼쪽의 0을 찾아주면 그보다 왼쪽은 하나의 1로 줄일 수 있다. 그러므로 제일 왼쪽의 0이 나오는 비트 n에 1을 더한 것이 답이 된다.</p>

<p>양수의 경우는 좀 더 간단하다 그저 제일 왼쪽의 1을 찾아주면 충분하기 때문이다. 다만 이 비트들 왼쪽에 0이 있어야 한다. 그렇지 않으면 음수를 표현하기 때문이다. 그래서 양수의 경우 제일 왼쪽의 1이 나오는 비트 n에 1을 더해줘야 한다.</p>

<p>결국 우리는 음수의 경우 제일 왼쪽의 0을 찾고, 양수는 1을 찾아야 한다. 문제는 이를 어떻게 수행할 것인가 하는 점이다. 지금 우리는 2가지 문제가 있다. 첫 번째, if를 사용할 수 없는데 찾아야 하는 수가 0과 1로 다르다는 문제가 있다. 두 번째, 어떻게 제일 왼쪽의 1이나 0을 알아낼 수 있을지다.</p>

<p>첫 번째 질문에 대한 대답으로, 수가 음수일 경우 ~x를 사용할 수 있다. 이렇게 하면 결국 제일 왼쪽의 1을 찾는 문제로 바뀌기 때문이다. 두 번째 문제의 대답은, 이진 탐색을 사용하는 것이다. 아마 조건에 맞는 수를 찾아야 한다는 점에서 이진 탐색을 떠올린 사람이 많을 것이다. 문제는 이를 기본적인 코드만으로 어떻게 구현해야 할지다.</p>

<p>해답은 »와 !를 사용하는 것이다. 예를 들어서 왼쪽 16비트에 1이 있는지를 확인하고 싶다면 !!(x » 16)을 한다. 만약 왼쪽에 0뿐이었다면 x » 16은 0이 되고, !!(x » 16)도 0이 된다. 만약 1이 하나라도 있었다면 x » 16은 0이 아니므로 !!(x » 16)은 1이 나온다. 그리고 결과값이 0이면 왼쪽에 1이 없다는 의미이므로 오른쪽 16비트에서 검색해줘야 하고, 결과값이 1이라면 다시 왼쪽 16비트에서 검색해줘야 한다.</p>

<p>왼쪽 16비트에 1이 없었을 경우, x » 8로 다시 위와 같은 과정을 거쳐야 한다. 왼쪽에 1이 있었을 경우에는 (x » 16) » 8로 다시 검색을 해줘야 한다. 이와 같은 과정을 4, 2, 1의 경우에 모두 해주면 이진 탐색을 구현할 수 있다.</p>

<p>본격적으로 코드로 구현해보겠다. 우선 x를 부호에 따라서 그대로 두거나, 0과 1을 바꿔줘야 한다. sign이 어떻게 정의될지는 모르지만 형태는 개략 <code class="language-plaintext highlighter-rouge">sign1 &amp; x | sign2 &amp; ~x</code>가 될 것이다. 우선 부호가 0인 경우 그대로 두고 싶으므로 sign1은 x1111…11의 형태가 되고, sign2는 0이어야 한다. 부호가 1인 경우 sign1은 0이고 sign2는 x111…11이 되어야 한다. 그러므로 sign의 후보값은 0111…11이나 111…11이다. 이 중 111…11이 ~를 사용하면 바로 0이 되기 때문에 사용하기 간편하다. 그러므로 sign을 부호가 0이면 0이 되도록 하고, 부호가 1이면 111…11이 되도록 만들어준 다음 <code class="language-plaintext highlighter-rouge">x = ~sign &amp; x | sign &amp; ~x</code>로 x를 구할 수 있다. 그리고 x » 31을 하면 부호에 따라 0이 되거나 11…11이 되므로 <code class="language-plaintext highlighter-rouge">int sign = x &gt;&gt; 31</code>를 사용한다.</p>

<p>다음으로 이진 탐색을 구현한다. !!(x » 16)이 왼쪽 16비트에 1의 여부에 따라 0 또는 1이 된다. 그리고 1일 경우엔 x를 오른쪽으로 16비트 밀어주고, 아닐 경우에는 그대로 둬야 한다. 이를 코드로 옮기면 <code class="language-plaintext highlighter-rouge">x &gt;&gt; (!!(x &gt;&gt; 16) * 16)</code>이 된다. 여기서 *를 사용하는 것은 허락되지 않지만 «로 간단히 수정할 수 있으므로, 우선은 이해하기 쉽게 저렇게 둔다. 나머지도 마찬가지로 8, 4, 2, 1의 경우에도 찾아줘야 한다. 다만 마지막에 2개만 남았을 경우 <code class="language-plaintext highlighter-rouge">!!x</code>로 값을 체크해서 1인지 0인지 알아야 한다. 그리고 이 경우 찾은 비트 위치는 <code class="language-plaintext highlighter-rouge">!!(x &gt;&gt; 16) * 16</code>, <code class="language-plaintext highlighter-rouge">!!(x &gt;&gt; 8) * 8</code>, … , <code class="language-plaintext highlighter-rouge">!!(x &gt;&gt; 1) * 1</code>, <code class="language-plaintext highlighter-rouge">!!x</code>의 합으로 나온다. 주의할 것은 x를 동일한 것으로 사용하고 있으므로 비트 위치를 먼저 계산하고 비트를 밀어줘야 한다. 그러므로 이진탐색은 아래처럼 된다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  int bit16 = (!!(x &gt;&gt; 16) * 16);
  x = x &gt;&gt; bit16;
  int bit8 = (!!(x &gt;&gt; 8) * 8);
  x = x &gt;&gt; bit8;
  int bit4 = (!!(x &gt;&gt; 4) * 4);
  x = x &gt;&gt; bit4;
  int bit2 = (!!(x &gt;&gt; 2) * 2);
  x = x &gt;&gt; bit2;
  int bit1 = (!!(x &gt;&gt; 1) * 1);
  x = x &gt;&gt; bit1;
  int bit0 = !!x;
</code></pre></div></div>
<p>그리고 마지막으로 이 비트들을 다 더해준 다음 1을 더한 것이 필요한 비트값이 된다. 전체 코드는 아래와 같다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int howManyBits(int x) {
  int sign = x &gt;&gt; 31;
  x = (~sign &amp; x) | (sign &amp; ~x);

  int bit16 = (!!(x &gt;&gt; 16) * 16);
  x = x &gt;&gt; bit16;
  int bit8 = (!!(x &gt;&gt; 8) * 8);
  x = x &gt;&gt; bit8;
  int bit4 = (!!(x &gt;&gt; 4) * 4);
  x = x &gt;&gt; bit4;
  int bit2 = (!!(x &gt;&gt; 2) * 2);
  x = x &gt;&gt; bit2;
  int bit1 = (!!(x &gt;&gt; 1) * 1);
  x = x &gt;&gt; bit1;
  int bit0 = !!x;

  return bit16 + bit8 + bit4 + bit2 + bit1 + bit0 + 1 ;
}
</code></pre></div></div>

<p>이렇게 만들어주면 에러가 발생하는데, 왜 그런지는 모르지만 bit16, … , bit0를 먼저 선언하고 작성해야 한다. 그리고 *를 다시 «로 바꿔서 작성해야 한다. 최종적으로 아래처럼 된다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int howManyBits(int x) {
  int bit16, bit8, bit4, bit2, bit1, bit0;
  int sign = x &gt;&gt; 31;
  x = (~sign &amp; x) | (sign &amp; ~x);

  bit16 = (!!(x &gt;&gt; 16) &lt;&lt; 4);
  x = x &gt;&gt; bit16;
  bit8 = (!!(x &gt;&gt; 8) &lt;&lt; 3);
  x = x &gt;&gt; bit8;
  bit4 = (!!(x &gt;&gt; 4) &lt;&lt; 2);
  x = x &gt;&gt; bit4;
  bit2 = (!!(x &gt;&gt; 2) &lt;&lt; 1);
  x = x &gt;&gt; bit2;
  bit1 = (!!(x &gt;&gt; 1));
  x = x &gt;&gt; bit1;
  bit0 = !!x;

  return bit16 + bit8 + bit4 + bit2 + bit1 + bit0 + 1 ;
}
</code></pre></div></div>
<h3 id="floatscale2">floatScale2</h3>
<p>부동 소수점을 표현하는 uf가 주어졌을 때, 이를 2배해서 반환하는 함수를 만들어야 한다. 부동 소수점을 기억해보면 첫 번째, 비트가 부호를 의미하고, 그 다음 8개가 exp를, 마지막 23개가 frac을 표현하는데 쓰인다. 이들은 exp의 값에 따라서 세 가지 해석법을 가진다.</p>

<p>첫 번째로 exp가 0도 0xFF도 아닌 경우다. 이 경우 $(-1)^s * M * 2^E$로 표현되는 수를 나타내는데, $E = exp - Bias로$ 표현한다. 이때, Bias는 $2^(k-1)-1$이다. 그리고 M은 $1 + frac$인데 frac의 비트는 소수점 아래의 수들을 표현하는데 사용된다. 만약 이 상황에서 값을 2배로 해주려면 exp를 1을 더해주면 된다.</p>

<p>두 번째로 exp가 0인 경우다. 이 경우 $E = 1 - Bias$이고 $M = frac$이 된다. 이때, 수가 2배가 되면 frac이 두 배가 되는 것이다. 즉 왼쪽으로 1칸 밀어주거나, 두 번 더하면 된다.</p>

<p>마지막으로 exp가 0xFF인 경우다. 이 때는 수가 무한대를 표현하기 때문에 수를 바꿀 필요가 없다. 또한 이 경우 frac이 0인 경우는 무한대이고, 나머지는 Nan으로 표현된다. 문제에서는 Nan인 경우 수를 그대로 반환하라고 했으므로, 이 경우에는 무조건 수를 그대로 반환하면 된다.</p>

<p>문제를 푸는 법은 간단하다. exp와 frac의 비트를 구할 수 있는 비트를 만들어서 이 둘을 구해준다. 그리고 exp의 값에 따라서 3경우를 if-else로 구현해주면 된다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>unsigned floatScale2(unsigned uf) {
  unsigned expBits = 0xFF &lt;&lt; 23;
  unsigned fracBits = (((0x7F &lt;&lt; 8) + 0xFF) &lt;&lt; 8) + 0xFF;
  unsigned exp = (uf &amp; expBits) &gt;&gt; 23;
  unsigned frac = (uf &amp; fracBits);
  if(exp == 0) {
    uf += frac;
  } else if(exp == 0xFF) {
    return uf;
  } else {
    uf += (0x01 &lt;&lt; 23);
  }
  return uf;
}
</code></pre></div></div>

<h3 id="floatfloat2int">floatFloat2Int</h3>
<p>이번에는 부동 소수점 표기법을 정수로 바꿔줘야 한다. 이때 정수로 표현할 수 없는 범위는 0x80000000을 반환한다. 이 문제도 이전처럼 exp에 따라 3가지 경우의 수가 발생한다. 그 중에 exp가 0인 것은 결과가 0이 나오고, exp가 0xFF인 경우는 0x80000000를 돌려보낸다. 이 둘은 명백히 범위를 벗어나기 때문에 간단하게 해결된다.</p>

<p>문제는 exp가 0도 0xFF도 아닌 경우다. 이 경우에도 정수로 표현할 수 있는 범위를 벗어나는 경우가 있기 때문이다. 2의 지수가 되는 $E = exp -Bias$로, 이때 Bias는 127이다. 만약 E가 31 이상인 경우 값이 너무 크므로 범위를 벗어나고, 반대로 E가 0보다 작으면 값이 너무 작아서 0이 된다. 이 경우의 수를 단순히 코드로 옮기면 <code class="language-plaintext highlighter-rouge">if(exp - 127 &gt;= 31)</code>와 <code class="language-plaintext highlighter-rouge">if(exp - 127 &lt; 0)</code>이 되겠다. 그런데 exp의 값에 따라서 -127을 했더니 값이 너무 커지거나 작아지는 경우가 생길 수도 있다. 그러므로 위와 같이 표현하기 보다 <code class="language-plaintext highlighter-rouge">if(exp &gt;= 127 + 31)</code>과 <code class="language-plaintext highlighter-rouge">if(exp &lt; 127)</code>로 적어줘야 한다.</p>

<p>마지막으로 정수로 표현할 수 있는 범위 안의 수를 계산해보자. M 표현법에 따라 frac의 제일 앞 자리에 1이 붙어야 한다. 그러므로 <code class="language-plaintext highlighter-rouge">frac += 1 &lt;&lt;23</code>으로 1을 붙여준다. 그리고 E의 값에 따라 »을 사용해서 필요한 부분만 남긴다. 예를 들어서 E가 0이라면 frac의 제일 앞 자리만 남고, E가 1이라면 frac의 앞 2자리만 남게 된다. 이를 코드로 옮기면 <code class="language-plaintext highlighter-rouge">frac = frac &gt;&gt; (23 - (exp - 127))</code>이 된다. 이 경우는 exp - 127을 해도 괜찮은 것이 앞서서 if-else로 exp가 127보다 크고 또 158보다 작아서 값의 범위를 벗어나지 않기 때문이다. 이렇게 하면 frac에 정수값이 들어가게 된다. 마지막으로 부호에 따라서 -frac을 반환하거나 frac을 반환하면 된다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int floatFloat2Int(unsigned uf) {
  unsigned expBits = 0xFF &lt;&lt; 23;
  unsigned fracBits = (((0x7F &lt;&lt; 8) + 0xFF) &lt;&lt; 8) + 0xFF;
  unsigned signBits = 1 &lt;&lt; 31;
  unsigned exp = (uf &amp; expBits) &gt;&gt; 23;
  unsigned frac = (uf &amp; fracBits);
  unsigned sign = (uf &amp; signBits);
  if(exp == 0) {
    return 0;
  } else if(exp == 0xFF) {
    return 0x80000000u;
  } else {
    if(exp &gt;= 127 +31) {
      return 0x80000000u;
    } else if(exp &lt; 127) {
      return 0;
    } else {
      frac += 1 &lt;&lt; 23;
      frac = frac &gt;&gt; (23 - (exp - 127));
      if(sign) {
        return ~frac + 1;
      } else {
        return frac;
      }
    }
  }
}
</code></pre></div></div>

<h3 id="floatpower2">floatPower2</h3>
<p>2의 지수 x가 주어졌을 때, $2^x$를 부동 소수점으로 표현해야 한다. 이때 값이 너무 크다면 +INF를 반환하고, 너무 작다면 0을 반환한다. 이 문제에서 x는 사실상 부동 소수점 표기의 E라고 볼 수 있다. 여기서 수의 범위가 문제인데 E가 0이 아닌 경우 $2^(-126)$ ~ $2^(127)$까지 표현 가능하다. 또한 E가 0인 경우엔 frac이 수를 표현하기 때문에 $2^(-126) \times 2^(-23)$까지 표현할 수 있게 된다. 즉, $2^(-149)$까지 표현할 수 있다. 그러므로 E의 범위인 -149 ~ 127을 벗어나면 +INF나 0을 반환해주면 된다. 그리고 범위 안에 들어온다면 -149 ~ -126 사이라면 exp는 0이고 frac만으로 표현해야 하므로 <code class="language-plaintext highlighter-rouge">(1 &lt;&lt; (149 + x))</code>를 반환한다. 그 외의 경우는 $E = exp - 127$로 exp를 구하고 « 23을 해주면 간단하게 부동 소수점 표기를 구할 수 있다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>unsigned floatPower2(int x) {
  if(x &gt; 127) {
    return 0xFF &lt;&lt; 23;
  } else if(x &lt; -126) {
    if(x &lt; -149) {
      return 0;
    } else {
      return (1 &lt;&lt; (149 + x));
    }
  } else {
    x += 127;
    return x &lt;&lt; 23;
  }
}
</code></pre></div></div>
:ET