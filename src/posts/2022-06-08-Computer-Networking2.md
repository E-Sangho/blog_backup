---
title: Computer Networking Chapte 2
date: 2022-06-08 14:55:05
layout: series
series: NetWorking
thumbnail: ../assets/images/networking.jpg
summary: Computer Networking
categories: [CS]
---

# 2. Application Layer

이 장에서 네트워크 애플리케이션의 개념과 구현을 공부한다.
애플리케이션 계층 프로토골, 클라이언트와 서버, 프로세스, 그리고 트랜스포트 계층 인터페이스를 포함하는 주요 애플리케이션 계층 개념을 정의하면서 이 장을 시작한다.

## 2.1 Principles of Network Application

네트워크 애플리케이션 개발의 중점은 다른 엔드 시스템에서 동작하고, 네트워크를 통해 서로 통신하는 프로그램을 만드는 것이다.
그러므로 새로운 애플리케이션을 개발할 때 여러 종단 시스템에서 실행되는 소프트웨어를 작성해야 한다.
중요한 것은 라우터나 링크 계층 스위치처럼 네트워크 코어 장비에서 실행되는 소프트웨어를 작성할 필요가 없다는 것이다.

### 2.1.1 Network Application Architectures

애플리케이션 구조는 애플리케이션이 종단 시스템에서 어떻게 동작하는지 지시한다.
현대 네트워크 애플리케이션은 클라이언트-서버 구조나 P2P 구조를 주로 사용한다.

클라이언트-서버 구조에서 항상 켜져 있는 호스트를 서버라고 부른다.
서버는 클라이언트라고 부르는 수 많은 호스트의 요청을 받는다.
서버는 요청에 따라 객체를 클라이언트에게 보내준다.
클라이언트-서버 구조는 서버를 기반으로 작동하므로, 클라이언트는 서로 직접적으로 통신하지 않는다.
또 다른 특징은 서버가 고정 IP 주소를 사용한다는 것이다.
서버는 항상 동작하므로 클라이언트는 서버 주소로 패킷을 보내 항상 서버에 연결할 수 있다.

클라이언트-서버 애플리케이션이 하나의 서버만 사용한다면, 요청이 많아졌을 때 처리하지 못하게 된다.
그래서 수 많은 호스트를 갖춘 데이터 센터가 가상 서버를 생성하는데 사용된다.
검색엔진, 웹 결제, 이메일, 소셜 네트워킹 같은 인기있는 서비스는 여러 데이터 센터를 사용한다.

P2P 구조에서는 항상 켜져 있는 기반구조 서버에 최소로 의존한다.
대신에 애플리케이션된 간헐적으로 연걸된 호스트쌍이 직접 소통하게 만든다.
이때 연결된 호스트 쌍을 피어(peer)라고 한다.
특정 서버를 사용하지 않고 피어가 통신하므로 이 구조를 P2P(peer-to-peer)라고 한다.
대표적인 예시가 토렌트와 스카이프 등이 있다.

P2P 구조의 특징 중 하나가 자가 확장성(self-scalability)다.
예를 들어 각 피어가 파일을 요구함으로써 작업 부하를 만들어낸다.
이때 각 피어는 파일을 다른 피어에게 분배함으로써 서비스 능력을 추가한다.
또한 P2P는 가격이 저렴한데, 서버 기반구조와 대역폭이 필요 없기 때문이다.
그러나 P2P 애플리케이션은 분산 구조 특성으로 인해 보안, 성능, 신뢰성에 문제가 있다.

### 2.1.2 Processes Communicating

운영체제 용어에서 실제 통신하는 것은 프로그램이 아니라 프로세스(process)다.
프로세스는 엔드 시스템에서 실행되는 프로그램이다.
정확히 말하자면 프로그램은 하드 디스크에 저장된 파일이다.
그리고 이 파일을 실행하면 메모리에 올라가고 이를 프로세스라고 한다.
다시 말해 프로세스는 실행중인 프로그램이다.
통신 프로세스가 같은 엔드 시스템에서 실행될 때, OS를 통해 프로세스 간에 통신이 가능하다.
그러나 이 책은 같은 호스트에서 프로세스가 통신하는 방법은 관심이 없다.
대신에 다른 엔드 시스템에서 실행되는 프로세스 통신만 다룬다.

2개의 다른 엔드 시스템에서 프로세스는 컴퓨터 네트워크를 통한 메세지 교환으로 통신한다.

#### Client and Server Processes

네트워크 애플리케이션은 서로 메세지를 보내는 두 프로세스로 구성된다.
프로세스 쌍에서 통신 세션에서 통신을 초기화 하는 프로세스를 클라이언트라고 하고, 세션을 시작하기 위해 접속을 기다리는 프로세스를 서버라고 한다.

#### The Interface Between the Process and the Computer Network

프로세스는 소켓(socket)을 통해 네트워크로 메세지를 보내고 받는다.
소켓은 호스트의 어플리케이션 계층과 트랜스포트 계층 간의 인터페이스다.
동시에 소켓은 네트워크 애플리케이션이 인터넷에 만든 프로그래밍 인터페이스이므로 API(Application Programming Interface)라고도 한다.

#### Addressing Processes

목적지로 메세지를 보내기 위해선 목적지 주소가 필요하다.

### 2.1.3 Transport Services Available to Applications

소켓은 애플리케이션 프로세서에서 트랜스포트 프로토콜로 메세지를 넘겨준다.
트랜스포트 프로토콜은 여러 종류가 있으며, 그 중에서 가장 적합한 것을 골라서 쓰게 된다.
트랜스포트 계층을 신뢰적 데이터 전송, 처리율, 시간, 보안 4가지 측면에서 살펴보자.

#### Reliable Data Transfer

네트워크 전송 과정에서 패킷이 손실될 수 있다.
프로토콜은 데이터 전송이 손실 없이 되었음을 보장해줘야 한다.
이런 서비스를 신뢰적 데이터 전송이라 한다.
트랜스포트 계층 프로토콜이 신뢰적 데이터 전송을 제공하지 않을 수 있다.
이는 어느 정도의 손실이 허용되는 경우에만 사용된다.
예를 들어 오디오, 비디오 같은 경우 약간의 손실은 큰 영향을 끼치지 않는다.
반면 은행 데이터 같이 중요한 정보는 반드시 신뢰적 데이터 전송이 이뤄져야 한다.

#### Trhoughput

네트워크 상태에 따라 전송율의 차이가 생긴다.
트랜스포트 프로토콜은 최소한의 속도를 보장한다.

#### Timing

일정 시간 안에 도착할 것을 보장한다.

#### Security

보안이 적용되어야 함

### 2.1.4 Transport Services Provided by the Internet

인터넷은 애플리케이션에게 UDP(User Datagram Protocol)과 TCP(Transmission Control Protocol)이라는 2가지 프로토콜을 제공한다.

#### TCP Services

TCP는 아래 2가지 서비스를 제공한다.

-   연결 지향 서비스(Connection-oriented service): 애플리케이션 계층 메세지를 전송하기 전에 TCP는 클라이언트와 서버가 서로 전송 제어 정보를 교환하도록 한다. 이는 클라이언트와 서버에 패킷이 도착할 준비를 시작할 수 있게 한다. 이 단계가 지나면 TCP 연결이 이뤄진다. 이 연결은 두 프로세스가 서로 메세지를 보낼 수 있다. 애플리케이션이 메세지 전송을 마치면 연결은 끊어진다.
-   신뢰적 데이터 전송 서비스(Reliable data transfer service)

> TCP나 UDP는 데이터를 암호화하지 않는다. 이 때문에 중요한 내용이 중간에 누출될 수 있다. 이 때문에 TCP를 강화한 SSL(Secure Sockets Layer)를 개발했다. SSL은 기존의 TCP가 하는 일은 그대로 하고, 추가로 암호화, 데이터 무결성, 종단 인증 등의 보안 기능이 추가되었다. SSL은 트랜스포트 프로토콜이 아니라 애플리케이션 계층에서 구현된 것이다. 애플리케이션은 SSL로 데이터를 보내고, SSL은 이름 암호화한다. 그리고 암호화된 정보를 TCP로 전송한다. 수신 소켓은 이를 SSL로 전달해서 해독한다. 그리고 이를 수신 프로세스로 전달한다. 이 과정은 8장에서 자세히 다룰 예정이다.

TCP는 네트워크가 혼잡하면 속도를 낮춘다.
이는 프로세스에게 이득은 아니지만, 전체적 인터넷 성능 향상을 위해 필요한 작업이다.
TCP는 각 네트워크가 공평하게 대역폭을 공유하도록 제한한다.

#### UDP Services

UDP는 TCP와 달리 연결 지향 서비스를 제공하지 않는다.
즉, 두 프로세스가 통신하기 전에 전송 정보를 교환하지 않는다.
UDP는 비신뢰적 데이터 전송 서비스를 사용한다.
쉽게 말해서 메세지를 보내면, 그 메세지가 수신되는 것을 보장하지 않는다.
게다가 메세지 순서를 보장하지 않아서 뒤섞일 수도 있다.
또한 TCP와 달리 네트워크가 혼잡해도 제어하지 않는다.
그래서 원하는 속도로 데이터 전송이 가능하다.
물론 네트워크가 혼잡으로 이보다 속도가 느려질 수도 있다.

#### Services Not Provided by Internet Transport Protocols

### 2.1.5 Application-Layer Progocols

애플리케이션 계층 프로토콜은 프로세스가 서로 메세지를 보내는 방법을 정의하는데, 그 내용은 다음과 같다.

-   교환 메세지 타입(요청이나 응답)
-   메세지 타입의 문법
-   필드에 있는 정보의 의미
-   프로세스가 언제, 어떻게 메세지를 보내고 응답하는지 정하는 규칙

애플리케이션 계층 프로토콜이 같은 경우에만 서로 통신할 수 있다.
예를 웹은 HTTP를 주로 사용하므로 어떤 웹 서버로부터도 정보를 가져올 수 있다.
반면 스카이프 같은 기업은 비개방 애플리케이션 계층 프로토콜을 사용해서 통신할 수 없다.

애플리케이션 계층 프로토콜은 네트워크 애플리케이션의 일부분일 뿐이다.

### 2.1.6 Network Applications Covered in This Book

이 책은 5개의 중요한 네트워크 애플리케이션만을 다룬다.
각각 웹, 파일 전송, 이메일, 디렉터리 서비스, 비디오 스트리밍, P2P 애플리케이션이다.
먼저 웹의 HTTP를 다루고, FTP를 다룬다.
그 후 이메일, DNS, CDN을 다뤄보겠다.

## 2.2 The Web and HTTP

### 2.2.1 Overview of HTTP

웹에서 클라이언트와 서버는 서로 HTTP(HyperText Transfer Protocol) 메세지를 교환하여 통신한다.
HTTP는 메세지의 구조와 클라이언트와 서버가 어떻게 메세지를 교환하는지 정의한다.

웹 페이지는 객체로 구성된다. 웹 브라우저는 HTTP의 클라이언트를 구현한 것으로, 이 때문에 웹에서 브라우저와 클라이언트 용어를 혼용해서 사용한다.
HTTP의 서버인 웹 서버는 URL로 각각을 지정할 수 있다.
HTTP는 웹 클라이언트가 웹 서버에게 어떻게 웹 페이지를 요청하는지, 서버가 클라이언트로 어떻게 웹 페이지를 전송하는지 정의한다.

HTTP는 TCP를 전송 프로토콜로 사용한다.
서버는 클라이언트에 관한 어떠한 정보도 저장하지 않는다.
그래서 클라이언트가 같은 객체를 2번 요청해도 이를 확인할 수 없고 객체를 다시 보내게 된다.
HTTP 서버는 클라이언트 정보를 유지하지 않으므로, HTTP를 stateless protocol이라고 한다.

### 2.2.2 Non-Persistent and Persistent Connections

클라이언트와 서버 사이에는 여러 신호가 오간다.
이 신호는 연속적일 수도 있지만, 끊어져서 들어올 수도 있다.
통신이 TCP로 일어날 때 고민이 생긴다.
각 요청/응답 쌍을 분리된 TCP 통신을 사용할 것인가, 아니면 모든 요청/응답을 하나의 TCP 통신을 사용할 것인지다.
전자를 비지속 연결(non-persistent connection)이라 하고 후자를 지속 연결(persistent connection)이라고 한다.
HTTP는 기본적으론 지속 연결을 사용하지만, 설정을 변경해서 비지속 연결을 사용할 수 있다.

#### HTTP with Non-Persistent Connections

비지속 연결에서 서버가 클라이언트에게 웹페이지를 전송하는 것을 알아보자.

1. HTTP 클라이언트는 서버로 TCP 연결을 시작한다.
2. 클라이언트는 앞 단계에서 설정된 TCP 연결 소켓으로 서버에 요청을 보낸다.
3. 서버는 요청을 받고 저장장치에서 페이지에서 요청한 객체를 추출한다. 그리고 응답 메세지에 객체를 캡슐화해서 전송한다.
4. 서버는 TCP에게 연결을 끊을 것을 요청한다. TCP는 클라이언트에게 응답 메세지가 올 때까지 연결을 끊지 않는다.
5. 클라이언트가 응답 메세지를 받으면 TCP 연결을 종료시킨다.

서버가 객체를 보낸 후에 TCP 연결이 끊어지므로 비지속 연결이다.
각 TCP 연결은 하나의 요청과 하나의 응답만을 전송한다.
그래서 여러 요청이 발생하면 각각의 TCP 통신이 발생한다.

TCP 통신이 여럿 발생한다면, 각 연결은 순서대로 일어날지 아니면 동시에 일어날지 설명하지 않았다.
이는 브라우저에서 몇 개의 통신이 동시에 일어날지 설정할 수 있기 때문이다.

클라이언트가 요청하고 그 파일을 수신받기까지의 시간을 측정해보자.
이때 패킷이 클라이언트로부터 서버에 가고, 돌아오는 시간을 RTT(round trip time)로 정의한다.
RTT는 패킷 전파 지연, 큐잉 지연, 처리 지연 시간도 같이 계산한다.
클라이언트가 서버에 TCP 통신을 요청하면, 서버는 이에 응답한다.
이 과정에서 하나의 RTT가 생긴다.
그리고 클라이언트가 서버에 파일을 요청하고, 서버는 파일을 전송한다.
여기서 또 하나의 RTT가 생기고, 추가로 파일을 전송하는 시간이 더해진다.
결국 총 2RTT + 파일 전송 시간 만큼의 시간이 소요된다.

비지속 연결은 몇 가지 단점이 있다.
우선 각 요청마다 새로운 연결이 이뤄져야 한다.
각 연결마다 TCP 버퍼가 할당되고, TCP 변수가 서버와 클라이언트에게 유지되어야 한다.
이는 서버에게 큰 부담이 될 수 있는데, 동시에 수백 건의 요청을 받을 수 있기 때문이다.
또한 매 연결마다 2RTT가 필요하다.

#### HTTP with Persistent Connections

지속 연결에서 서버는 TCP 연결을 응답후에도 유지한다.
클라이언트와 서버 사이의 요청/응답은 같은 연결에서 계속 이뤄진다.
이때 요청은 응답을 기다리지 않고 연이어 이뤄질 수 있는데, 파이프라이닝으로 해결한다.
서버는 특정 시간동안 요청이 들어오지 않으면 연결을 끊는다.
HTTP의 기본 모드는 파이프라이닝으로 지속 연결을 사용한다.

### 2.2.3 HTTP Message Format

#### HTTP Request Message

아래는 전형적인 HTTP 요청 메세지다.

```
GET /somedir/page.html HTTP/1.1
Host: www.someschool.edu
Connection: close
User-agent: Mozilla/5.0
Accept-language: fr
```

우리는 이 메시지로부터 많은 것을 알 수 있다.
우선 위 메세지는 ASCII 텍스트로 쓰여 있어서 사람이 읽을 수 있다.
다음으로 메세지가 5줄로 쓰여있는데 첫 번째 줄은 요청 라인이라 부르고, 나머지는 헤더 라인이라고 한다.
요청 라인은 method, URL, HTTP 버전 세 가지 정보를 담고 있다.
여기서 method는 GET, POST, HEAD, PUT, DELETE 등의 명령을 사용한다.
위 예시는 GET을 사용해서 페이지를 요청하고 있다.

다음으로 헤더 라인을 살펴보자.
헤더는 Host로 메세지의 목적지를 표시한다.
Connection은 브라우저와 연결 방식을 결정한다.
close면 연결 이후 서버가 연결을 끊는 것을 요청한 것이다.
다시 말해 비지속 연결을 한다.
User-agent는 사용하는 브라우저 정보를 보내준다.
마지막으로 Accept-language는 사용하는 언어를 적어준다.
해당 언어가 존재하면 서버에서 그 언어로 데이터를 보내주지만, 없다면 기본 설정된 언어로 보내준다.

HTTP 요청은 헤더 라인 뒤에 entity body를 가지고 있다.
GET 요청은 엔티티 바디가 비어있다.
엔티티 바디는 POST 메소드 사용시에 쓰이는 것으로, 사용자가 정보를 보낼 때 사용한다.
특히 로그인과 같이 특정 양식을 채워서 보내는 요청에서 많이 사용한다.

그렇지만 URL에 쿼리를 추가하면 GET으로도 데이터 전송이 가능하다.
예를 들어 "www.somesite.com/animalsearch?monkeys&bananas"는 URL 뒤에 쿼리로 monkeys, bananas라는 정보를 같이 보내준다.
구글에서 검색을 해보면 검색 키워드가 주소에 쿼리로 추가된 것을 볼 수 있다.

HEAD, PUT, DELETE

#### HTTP Response Message

아래는 HTTP 응답 메세지의 예다.

```
HTTP/1.1 200 OK
Connection: close
Date: Tue, 18 Aug 2015 15:44:04 GMT
Server: Apache/2.2.3 (CentOS)
Last-Modified: Tue, 18 Aug 2015 15:11:03 GMT
Content-Length: 6821
Content-Type: text/html!
(data data data data data ...)
```

응답 메세지는 3부분으로 나뉜다.
첫 번째 줄인 status line, 다음 6줄은 header line, 마지막은 entity body다.
여기서 entity body는 요청한 객체를 담고 있다.
status line은 프로토콜 버전, status code, status message를 담고 있다.

헤더 라인을 보면 "Connection: close"가 적혀있다.
이는 클라이언트에게 TCP 연결이 끊긴다는 것을 알려준다.
"Date"는 HTTP 응답이 전송된 시간이 적혀 있다.
"Server"는 서버가 어떤 환경인지 알려주는데, 위 예는 아파치 서버를 사용하고 있다.
"Last-Modified"는 객체가 마지막으로 변경된 시간이나 생성 시간을 표시한다.
"Content-Length"는 객체의 바이트 수를 표시한다.
마지막으로 "Content-Type"은 객체가 HTML 텍스트임을 명시한다.

### 2.2.4 User-Server Interaction: Cookies

앞서 설명했듯이 HTTP 서버는 stateless다.
이로 인해 동시에 수천개의 TCP 연결을 사용할 수 있게 되었다.
그렇지만 웹 사이트가 사용자를 식별하는 작업이 필요할 때가 있다.
예를 들어 로그인 상태를 유지한다거나 장바구니 기능 같이 데이터를 유지해야 하는 경우가 있다.

이 때문에 HTTP는 쿠키를 사용한다.
쿠키는 사이트가 사용자 정보를 유지하게 해준다.
쿠키 기술은 4가지 부분으로 이뤄져 있다.
쿠키 헤더 라인은 HTTP 응답 메세지에 포함되어 있다.
쿠키 헤더 라인은 HTTP 요청 메세지에 포함된다.
쿠키 파일은 사용자의 엔드 시스템에 보관되고, 브라우저로 관리된다.
백엔드 데이터베이스에서 관리된다.

### 2.2.5 Web Caching

Web Cache(or proxy server)는 웹 서버를 대신해서 HTTP 요청에 응답해주는 네트워크 엔티티다.
웹 캐시는 독자적인 저장소가 있고, 여기에 최근에 요청한 객체를 복사해서 저장해놓는다.
브라우저가 요청을 하면 먼제 웹 캐시와 TCP 연결된다.
이때 웹 캐시가 요청한 객체를 가지고 있으면, 이를 HTTP 응답으로 브라우저에 보낸다.
만약 웹 캐시에 없다면, 웹 캐시는 서버와 TCP 연결로 해당 객체를 가져온다.
그리고 이를 저장소에 복사해서 저장하고, 브라우저에게 HTTP 응답으로 객체를 보내준다.
캐시는 클라이언트임과 동시에 서버로 사용된다.

웹 캐시를 사용하는데는 2가지 이유가 있다.
첫 번째, 웹 캐시는 응답 시간을 크게 줄여준다.
두 번째, 웹 캐시는 트래픽을 크게 줄인다.

CDN(Content Distribution Network)의 사용으로 웹 캐시는 인터넷에서 중요한 역할을 차지하게 되었다.
CDN 회사는 수 많은 분산 캐시를 설치하고, 트래픽을 지역에서 해결한다.
CDN에 관해선 2.6절에서 자세히 살펴보겠다.

#### The Conditional GET

캐싱이 사용자 체감 시간을 줄이지만, 또 다른 문제를 야기한다.
바로 웹 캐시에 저장된 객체가 갱신된 경우다.
다시 말해 캐시가 객체를 저장한 후에 서버에서 객체를 업데이트한 경우가 생길 수 있다.
다행히다 HTTP는 캐시가 만료되었는지 확인할 수 있다.
이 방법을 조건부 GET(conditional GET)이라고 한다.
HTTP 요청은 다음 2가지 조건을 만족하면 조건부 GET이라고 한다.

1. 요청이 GET 메소드를 사용하는 경우
2. 요청이 "If-Modified-Since" 헤더를 포함하는 경우

조건부 GET이 사용되는 예시를 보자.
앞서 설명했듯 캐시는 객체를 저장하고 있다.
그런데 1주일 후 새로운 요청을 했다고 하자.
브라우저는 조건부 GET으로 갱신 조사를 한다.

```
GET /fruit/kiwi.gif
HTTP/1.1 Host: www.exotiquecuisine.com
If-modified-since: Wed, 9 Sep 2015 09:23:24
```

캐시는 위 내용을 받고 서버로 데이터 요청을 보낸다.
만약 데이터 내용이 변했다면 새로운 객체가 캐시로 보내지고, 캐시는 브라우저로 전송한다.
데이터 내용이 변하지 않았다면 서버는 내용이 없는 응답 메세지를 보낸다.

```
HTTP/1.1 304 Not Modified
Date: Sat, 10 Oct 2015 15:39:29
Server: Apache/1.3.0 (Unix)!
(empty entity body)
```

여기서 304 status code를 사용하고 있는데, 304는 변경이 없다는 뜻이다.
그러므로 캐시는 이전의 복사본을 그대로 사용하게 된다.

## 2.3 Electronic Mail in the Internet
