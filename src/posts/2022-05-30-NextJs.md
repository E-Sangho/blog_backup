---
title: Next.js
date: 2022-05-30 09:09:32
layout: series
series: Next.js
thumbnail: ../assets/images/nextjs.png
summary:
categories: [Next.js]
---

# Next.js

## Create Next.js Project

Next.js 프로젝트를 시작하기 위해서 create-next-app을 사용한다.
`npx create-next-app@latest`로 프로젝트를 만들 수 있다.
타입스크립트를 사용하려면 뒤에 --typescript를 붙여서 `npx create-next-app@latest --typescript`로 적어주면 된다.
create-next-app을 실행시키면 프로젝트 이름을 입력해줘야 한다.
나는 nextjs-test로 만들어줬다.
그리고 프로젝트 폴더를 VSCode에서 열어준다.
터미널에서 `npm run dev`을 입력해서 프로젝트가 정상적으로 작동하는지 확인한다.

![Next.js](../assets/images/startNextjs.png)

이제 폴더에서 필요 없는 파일을 삭제한다.
pages의 api 폴더는 필요 없으므로 지워준다.
그리고 index.tsx 파일을 아래처럼 바꾸고 페이지를 보면, 홈 화면에 Hello가 출력된 것을 볼 수 있다.

```javascript
// index.tsx
export default function Home() {
	return "Hello";
}
```

## Overview

### Pre-Rendering and Client-Side-Rendering

Next.js와 React의 가장 큰 차이점은 Pre-Rendering이 된다는 것이다.
Pre-Rendering은 클라이언트에게 전달되기 전에 미리 랜더링 하는 것이다.
왜 pre-rendering이 필요한지 알기 위해 React의 랜더링 시스템을 알아보자.

React로 만든 웹 페이지를 접속해면 처음엔 흰색 화면이 나오고 랜더링이 일어난다.
이는 React가 기본적으로 빈 HTML으로 시작해서, 자바스크립트 파일로 컴포넌트를 만들기 때문에 발생한다.
이처럼 자바스크립트 파일로 UI를 만드는 것은 클라이언트에서 일어나기 때문에 이를 **client-side-rendering**이라고 한다.

client-side-rendering은 자바스크립트로 컴포넌트를 만든다.
그렇기 때문에 자바스크립트 실행을 막으면 아무런 페이지도 보이지 않는다.
물론 자바스크립트 실행을 막는 경우는 거의 없으므로 별 문제 없으리라 생각할 수 있다.
그런데 네트워크 속도가 느리면 생각보다 큰 문제가 될 수 있다.
크롬에서 개발자 도구를 열고, 네트워크에 들어가자.
그리고 네트워크를 느린 3G로 바꾸고 다시 페이지를 켜보자.

![ReactSlowNetwork](../assets/images/reactSlowNetwork.png)

네트워크가 느리면 자바스크립트 파일을 가져오는데 오랜 시간이 걸린다.
그래서 사용자가 빈 화면을 오래 봐야 하고, 사용 경험에 부정적인 영향을 줄 수밖에 없다.

반면 Next.js는 **pre-rendering**을 한다.
pre-rendering은 클라이언트 측에서 자바스크립트로 모두 만드는 대신에, 서버에서 HTML을 만들어서 전달한다.
그래서 client-side-rendering과는 달리 기본적인 HTML 구조를 볼 수 있다.
대신에 자바스크립트 파일이 다 불러와지기 전에 자바스크립트를 사용하는 기능은 쓸 수 없다.
그래서 HTML은 존재하지만 interactive 하지 않은 상태로 시작하고, 자바스크립트 파일을 불러오면 interactive 해진다.

pre-rendering의 또 다른 장점은 SEO(Search Engine Optimization)가 유리하다는 것이다.
구글 검색엔진은 자바스크립트가 로드 되지 않은 페이지를 스캔한다.
앞서 말했듯이 client side rendering은 초기에 빈 화면만 존재하므로, 아무런 검색에 걸리지 않는다.
이는 react-helmet 등을 사용해서 해결할 순 있지만 번거롭다.
반면 pre-rendering을 하면 기본적인 HTML이 존재하므로 SEO에 유리하다.

pre-rendering은 server-side rendering, static site generation 두 종류로 나뉜다.
server-side rendering은 각 페이지 요청마다 서버에서 HTML을 만든다.
그리고 만들어진 HTML과 JSON, 자바스크립트 파일을 클라이언트에게 보내서 나머지를 만들게 한다.
이렇게 하면 클라이언트는 interactive하지 않은 HTML 페이지를 먼저 보게 된다.
그리고 React가 JSON과 자바스크립트로 해당 페이지를 interactive하게 만드는데, 이 과정을 **hydration**이라고 한다.
다시 말해 hydration은 HTML 코드와 자바스크립트 코드를 연결시켜서 페이지를 interactive하게 만드는 것이다.

static site generation 역시 서버에서 HTML을 만든다.
그렇지만 server-side rendering과는 다르게 runtime에 쓰일 서버가 없다.
그 대신에 어플리케이션이 배포되는 build time에 모든 페이지의 HTML을 만든다.
그리고 HTML은 CDN(Content Delivery Network)에 저장되어서 각 요청마다 사용된다.
SSR은 각 페이지를 요청 받은 시점에 HTML을 만드는 반면, SSG는 미리 페이지를 만들어두므로 더 빠르다.
대신에 SSG는 컨텐츠 변경이 생길 때마다 새로 빌딩해야 하므로 변경 사항이 많은 페이지에 적용하기 어렵다.
그러므로 블로그 같이 고정된 페이지는 SSG로 만들지만, 실시간 정보가 반영되는 사이트는 SSR로 만드는 것이 좋다.

지금까지 설명을 보면 pre rendering이 client side rendering보다 우월해보인다.
하지만 상황에 따라서 위 방법들을 섞어 쓰는 것이 가장 좋다.
데이터 업데이트가 많은 페이지는 처음에는 SSR로 하되 나머지 페이지는 CSR을 사용하면 좀 더 효과적일 것이다.
반대로 블로그, 상품 판매 페이지처럼 변화가 적은 페이지는 SSG를 사용하는 것이 좋다.
Next.js의 장점은 위처럼 선택지가 많고 그 중에서 가장 적절한 방법을 택할 수 있다는 것이다.

### pages

Next.js는 프레임워크이므로 정해진 위치에 코드를 작성하면 알아서 작동한다.
앞서 index.tsx를 보면 일반적인 리액트 파일과 다르게 ReactDOM.render() 없이도 페이지를 만들고 있다.
이것이 프레임워크의 힘으로 양식을 따라 만들기만 하면 번거로운 과정 없이도 페이지를 만들 수 있다.

Next.js의 또 다른 장점은 라우터를 별도로 만들 필요가 없다는 것이다.
Next.js에선 pages에 작성한 파일명이 곧 라우터 이름이 된다.
그리고 해당 파일에서 export default로 내보내는 것이 페이지의 내용이 된다.
예를 들어 about.tsx 파일을 아래처럼 만들면 /about 페이지가 만들어진다.

```javascript
// about.tsx
export default function About() {
	return "about";
}
```

### Navigation

a 태그를 사용해서 네비게이션 기능을 만들면 페이지 이동시마다 새로 랜더링이 일어난다.
React는 이 문제를 해결하기 위해 react router dom의 Link 컴포넌트를 사용했다.
Link는 주소만 바꾸고 페이지를 새로고침 하지 않는다.
그래서 React의 state와 컴포넌트가 그대로 유지되고, 바뀐 것만 업데이트 해준다.

Next.js는 역시 **Link**라는 동명의 컴포넌트를 사용한다.
다만 Next.js에서는 Link 컴포넌트 안에 a 태그로 링크를 만들어줘야 한다.
이때 링크로 이동하게 될 주소는 a가 아니라 Link에 적어줘야 한다.

```javascript
// components/Navbar.tsx
import Link from "next/link";

export default function Navbar() {
	return (
		<nav>
			<Link href="/">
				<a>Home</a>
			</Link>
			<Link href="/about">
				<a>About</a>
			</Link>
		</nav>
	);
}
```

```javascript
// index.tsx
import Navbar from "../components/Navbar";
export default function Home() {
	return (
		<>
			<Navbar />
			Home
		</>
	);
}
```

이때 Link는 랜더링 후에 사라진다.
그러므로 스타일을 적용하고 싶으면 Link가 아니라 a 태그에 적용해야 한다.

```javascript
// Navbar.tsx
import Link from "next/link";

export default function Navbar() {
	return (
		<nav>
			<Link href="/">
				<a style={{ color: "red" }}>Home</a> // This style applied to a.
			</Link>
			<Link href="/about" style={{ color: "blue" }}>
				{" "}
				// This style doesn't work.
				<a>About</a>
			</Link>
		</nav>
	);
}
```

추가로 현재 위치를 알기 위해서 useRouter를 쓸 수 있다.
아래처럼 useRouter를 받아와서 값을 출력해보자.

```javascript
// Navbar.tsx
import Link from "next/link";
import { useRouter } from "next/router";

export default function Navbar() {
	const router = useRouter();
	console.log(router);
	/*
        {
            "pathname": "/about",
            "route": "/about",
            "query": {},
            "asPath": "/about",
            ...
        }
    */
	return (
		<nav>
			<Link href="/">
				<a style={{ color: "red" }}>Home</a>
			</Link>
			<Link href="/about" style={{ color: "blue" }}>
				<a>About</a>
			</Link>
		</nav>
	);
}
```

출력된 결과를 보면 pathname에 현재 위치가 적혀있다.
이를 사용해서 현재 위치의 색만 바꿔주는 것도 가능하다.

```javascript
// Navbar.tsx
export default function Navbar() {
	const router = useRouter();
	return (
		<nav>
			<Link href="/">
				<a style={{ color: router.pathname === "/" ? "red" : "black" }}>
					Home
				</a>
			</Link>
			<Link href="/about" style={{ color: "blue" }}>
				<a
					style={{
						color: router.pathname === "/about" ? "red" : "black",
					}}
				>
					About
				</a>
			</Link>
		</nav>
	);
}
```

### CSS Modules

CSS를 적용하려면 여러가지 방법이 있다.
그 중에서 하나인 CSS 모듈을 소개하겠다.
CSS 모듈을 사용하려면 fileName.module.css 파일을 만들어준다.
그리고 styles로 파일을 import 해주면, styles의 속성에 스타일 이름이 들어있다.
이를 className에 사용해서 스타일을 적용할 수 있다.

```javascript
// Navbar.module.css
.active {
	color: red;
}
```

```javascript
// Navbar.tsx
import Link from "next/link";
import { useRouter } from "next/router";
import styles from "./Navbar.module.css";

export default function Navbar() {
	const router = useRouter();
	return (
		<nav>
			<Link href="/">
				<a className={router.pathname === "/" ? styles.active : ""}>
					Home
				</a>
			</Link>
			<Link href="/about" style={{ color: "blue" }}>
				<a
					className={
						router.pathname === "/about" ? styles.active : ""
					}
				>
					About
				</a>
			</Link>
		</nav>
	);
}
```

브라우저에서 만들어진 DOM의 class를 확인해보자.
그러면 "Navbar_active\_\_5L8wg" 같은 랜덤한 이름이 생성된 것을 볼 수 있다.
이는 CSS Module의 장점으로 스타일 중복을 막는 기능이다.
기본적인 CSS는 스타일 이름이 겹치면 여러 스타일이 적용되는 단점이 있다.
그 때문에 각 스타일 이름을 서로 겹치지 않게 만들어야 한다.
반면 CSS Module은 스타일 이름을 구분하기 위해, 개별적인 문자열을 추가한다.
그 덕분에 같은 스타일을 작성하더라도 서로 다른 이름으로 적용되고 중복될 걱정이 없다.

한 번에 여러 CSS Module을 적용하려면 여러 스타일 이름을 string으로 전달해야 한다.
간편한 방법은 백틱(`)을 사용하거나, 배열에 join() 함수를 사용하는 방법이 있다.

```javascript
// Navbar.module.css
.link {
	text-decoration: none;
}

.active {
	color: red;
}

```

```javascript
// Navbar.tsx
export default function Navbar() {
	const router = useRouter();
	return (
		<nav>
			<Link href="/">
				<a
					className={`${styles.link} ${
						router.pathname === "/" ? styles.active : ""
					}`}
				>
					Home
				</a>
			</Link>
			<Link href="/about" style={{ color: "blue" }}>
				<a
					className={[
						styles.link,
						router.pathname === "/about" ? styles.active : "",
					].join()}
				>
					About
				</a>
			</Link>
		</nav>
	);
}
```

중복을 제거해준다는 점에서 유용하지만, 여전히 불편한 점이 많은 방식이다.
여전히 클래스명을 기억해가며 두 파일을 오가야 하고, 여러 스타일을 적용하는 것이 쉽지 않다.
사실 React에서 이미 비슷한 기능을 봤었는데, 그 때도 같은 이유로 이 방법을 사용하지 않았다.
그러므로 다른 CSS를 적용하는 방법을 알아보자.

### styled jsx

next js 고유한 기능
style 태그에 jsx를 적어준다. {``}

\_app.js

custom app

## Reference

1. [client-side-rendering & server-side-rendering](https://nextjs.org/learn/foundations/how-nextjs-works/rendering)
2. [CDN](https://nextjs.org/learn/foundations/how-nextjs-works/cdns-and-edge)
