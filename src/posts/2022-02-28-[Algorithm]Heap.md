---
layout: post
title: Heap
date: 2022-02-28 23:23:38
categories:
tag:
toc: true
---

# C++

## 1. Heap 소개

이 글에서는 Heap 자료구조를 알아보려고 한다.
Heap은 Complete Binary Tree 형태로 만들어지는데, root에 최대값이 위치한다.
그래서 root에서 최대값을 O(1)이면 찾을 수 있다.
또한 root의 값을 제거해도 다시 최대값이 root에 오도록 만들어져 있다.
이 때문에 Heap은 최대값을 여러 번 구할 경우 사용하기 좋은 자료구조다.

Heap은 트리로 만들어져서 데이터 추가, 제거가 용이하다.
데이터 추가, 제거시에 $O(log n)$이 소요된다.
배열에서 구조를 유지하면서 추가, 제거를 하려면 $O(n)$이 걸린다는 것을 보면, Heap이 상당히 빠르다는 것을 알 수 있다.

자료구조를 이해할 때 가장 중요한 것은 왜 이런 자료구조가 생겼는지다.
다시 말해 기존의 구조에서 어떤 문제점이 있고, Heap이 어떤 것을 개선했는지 이해하는 것이 중요하다.
그러므로 배열의 문제점을 소개하고 Heap이 이를 어떻게 개선했는지 알아보자.

## 2. Heap 아이디어

자료구조에서 중요한 것은 읽기, 검색, 추가, 제거의 시간 복잡도다.
일반적으로 쓰이는 배열은 읽기가 $O(1)$으로 탁월하다.
이는 데이터의 인덱스만 알고 있다면 바로 값을 읽을 수 있기 때문이다.
데이터를 추가, 제거 하는 경우도 인덱스만 알고 있다면 O(1)으로 가능하다.
하지만 검색 능력은 상당히 떨어진다.
예를 들어서 최대값을 찾으려고 하면 배열의 모든 원소를 탐색해야 한다.
그래서 배열의 검색은 시간 복잡도가 $O(n)$이 된다.
이는 데이터 추가, 제거에도 영향을 끼친다.
추가하려는 위치를 모르면 배열 내를 모두 탐색해야 하기 때문이다.
그래서 인덱스를 모를 때, 추가, 삭제하려면 시간 복잡도가 $O(n)$이 된다.

결국 배열이 효과적인 경우는 인덱스를 아는 경우 뿐이다.
다시 말해 데이터를 저장하고 값을 찾기는 유리하지만, 조건을 만족하는 데이터를 찾기 어렵다.
이 때문에 알고리즘에서 많은 문제가 생기곤 한다.
특히 반복문 안에서 쓰인다면 시간 복잡도가 $O(n^2)$까지 올라가게 된다.
이는 알고리즘에서 허용하는 최악의 시간 복잡도다.
결국 값을 탐색하는 경우 배열로 데이터를 저장하는 것은 비효율적이다.
그래서 탐색에 유리한 자료 구조가 필요하다.

배열이 검색 능력이 떨어지는 이유는 데이터를 규칙 없이 저장하기 때문이다.
만약 배열이 큰 값을 앞에 저장한다면, 최대값을 쉽게 검색할 수 있다.
하지만 이 방법은 문제를 해결했다고 볼 수 없다.
왜냐하면 추가, 제거 시에 문제가 생기기 때문이다.
최대값을 추가, 제거했을 때 구조가 유지되어야 하는데, 이를 유지하려면 값을 정렬해서 기록해야 한다.
그런데 정렬해서 추가, 제거하는데 이미 $O(n)$의 낭비가 생긴다.
그래서 최대값을 앞에 저장하는 것 외에도 추가적인 규칙이 필요하다.

현재 문제는 데이터 추가, 제거 시에 모든 값을 정렬하기 때문에 발생한다.
그러므로 특정 경로의 데이터만 정렬하게 만들어서 수를 줄여야 한다.
이 때 사용하기 가장 좋은 것이 Tree다.
Tree로 만든다면 해당 경로에서만 탐색하면 되기 때문이다.
다만 Tree를 만들 때, 좌우 크기가 너무 차이가 나면 안 된다.
한쪽이 너무 크면 Tree가 깊어지고, 정렬해야 하는 수가 늘어난다.
그러므로 좌우로 밸런스가 잡힌 Complete Binary Tree를 사용한다.

지금까지 살펴본 내용으로 Heap을 만들려면 2가지가 필요한 것을 알 수 있다.

1. 값을 정렬해야 한다.(검색 능력 개선)
2. Complete Binary Tree를 사용한다.(추가/제거 능력 개선)

이렇게 하면 검색, 추가, 제거 능력이 크게 개선된다.
다만 Tree를 사용한 것 때문에 읽기 능력은 현저히 떨어진다.
Tree의 root 값은 읽기 쉽지만, 그 외의 값은 읽을 수 없게 된다.
결국 읽기 능력과 맞바꿔서 검색, 추가, 제거 능력을 향상시켰다고 할 수 있다.

## 3. Heap 규칙

Heap은 Complete Binary Tree 구조로 만든다.
그리고 부모가 자식보다 크도록 정렬한다.
이를 사용하면 데이터 추가, 삭제도 간단히 해결된다.

### 3.1 Insert Data

1. 데이터를 트리의 끝에 추가한다.
2. 부모와 자식을 비교한다.
3. 자식이 부모보다 크면 위치를 바꾼다.
4. 부모가 자식보다 클 때까지 이를 반복한다.

이 과정은 아무리 많아도 Tree의 깊이 이상은 일어나지 않는다.
Tree의 깊이는 $O(logn)$이므로 삽입의 시간 복잡도는 $O(logn)$이다.

### 3.2 Delete Data

Heap은 root의 값만 읽을 수 있다.
그러므로 제거 가능한 값도 root의 값 뿐이다.

1. root를 제거한다.
2. root에 마지막 원소를 넣는다.
3. root와 자식을 비교한다.
4. 부모가 자식보다 작으면 위치를 바꾼다.
5. 규칙을 만족할 때까지 반복한다.

이 역시도 Tree의 깊이 만큼만 일어난다.
그러므로 시간 복잡도는 $O(logn)$이다.

## 4. Heap 사용

자료구조를 구현할 때 가장 어려운 부분은 다차원을 1차원으로 끌어내리는 것이다.
Heap의 트리 구조는 아래 규칙으로 간단하게 만들 수 있다.

-   부모 노드의 인덱스: $\lfloor i/2 \rfloor$
-   왼쪽 자식 노드의 인덱스: $2i$
-   오른쪽 자식 노드의 인덱스: $2i + 1$

트리 구조만 만든다면 나머지 함수는 직접 만들 수 있다.
하지만 여기서 나머지 구현을 적진 않는다.
Heap을 직접 적을 필요 없이 간단히 사용할 수 있기 때문이다.

Heap을 사용하기 위해선 우선순위 큐를 사용하면 된다.
큐는 먼저 들어오는 데이터가 먼저 나가는 자료구조다.
우선순위 큐는 여기서 조금 변형한 것으로, 우선순위가 높은 데이터가 먼저 나간다.
우선순위 큐는 내부적으로 Heap으로 구현되있다.
그러므로 Heap을 사용해야 하는 경우는 우선순위 큐를 쓰면 된다.

대부분의 언어는 우선순위 큐 라이브러리가 존재한다.
예를 들어 C++는 queue 라이브러리 안에 priority_queue가 존재한다.
그러므로 필요한 경우는 직접 구현하지 않고 라이브러리를 불러와서 쓰면 된다.

## 5. Priority Queue

### 5.1 C++

C++에서 우선순위 큐를 사용하려면 아래처럼 사용하면 된다.

> priority_queue<T, [Container], [Compare]>

-   T: 저장할 타입
-   Container: 데이터를 저장할 곳
-   Compare: 비교 함수

여기서 T를 제외하고 사용해도 상관없다.
위의 템플릿 만으론 이해하기 어렵다.
아래 예시를 보면 좀 더 쉽게 이해할 수 있다.

```
#inlcude <queue>

using namespace std;

int main() {
    priority_queue<int> pq;

    priority_queue<int, vector<int>, greater<int>> pq2;
}
```

여기서 pq는 Contianer, Compare를 생략한 것이다.
pq는 `priority_queue<int, vector<int>, less<int>> pq`와 동일하다.
pq는 최대값이 우선순위가 높은 것이고, pq2는 최소값이 우선순위가 높다.
사실상 우선순위 큐를 선언하면 위의 두 형태가 대부분이다.

만약 정렬 형태를 바꾸고 싶다면 Compare 함수를 수정해야 한다.
이때 정렬된 마지막 원소의 우선 순위가 높아진다.
예를 들어서 아래처럼 설정하면 작은 수부터 출력한다.

```
bool compare (int a, int b) {
    return a > b;
}
```

그 외에도 일반 큐에서 사용했듯이, push, pop, top, empty, size 등을 사용할 수 있다.

우선순위 큐에서 가장 어려운 부분은 Compare 함수다.
Compare 함수를 정의하려면 아래처럼 하면 된다.

```
struct compare {
    bool operator () (int a, int b) {
        // writre compare code
    }
}
```

여기서 볼 수 있듯이 compare 구조체를 만들어줘야 한다.
이때 compare 함수에 들어가는 내용이 약간 어렵다.
잠시 sort 함수를 얘기해야 한다.
sort 함수에서 아래처럼 사용한다고 생각해보자.

```
bool compare (int a, int b) {
    return a > b;
}
```

이 경우 내림차수로 정렬될 것이다.
이는 sort에서 compare가 true라면 넘어가고, false라면 위치를 바꾸기 때문이다.
우선순위 큐는 배열로 구현되어 있다.
그리고 정렬시에 sort와 같은 일이 각 트리의 원소에서 일어난다.
문제는 우선순위가 높은 원소가 배열의 끝에 오도록 만들어졌다는 점이다.
그래서 위의 함수를 사용하면 가장 작은 원소가 끝에 오게 된다.
이는 곧 최소 우선순위 큐를 만든다.
sort에서 위의 함수가 큰 순서대로 정렬하는 반면, 우선순위 큐에서는 작은 순서로 정렬하는 것이다.
그래서 둘의 정렬 순서가 다르기 때문에 종종 잘못 만들게 된다.
