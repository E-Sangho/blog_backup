---
layout: post
title: Regular Expressions
date: 2022-01-18 18:04:08
categories:
tag:
toc: true
---

## Regex

문자열을 사용하면 종종 정규 표현식을 사용한다.
정규 표현식은 조건에 맞는 문자열을 찾는 방법으로 2가지 방법으로 정규 표현식을 만들 수 있다.
첫 번째는 /를 사용하는 것으로 `let re = /ab+c/`와 같은 식으로 만든다.
여기서 /사이의 부분이 정규 표현식으로 위는 ab 다음에 c가 오는 경우를 찾는다.
정규식을 만드는 방법은 조금 뒤에 다룬다.
두 번째 방법은 RegExp 함수를 사용하는 것으로 `let re = new RegExp("ab+c")`로 사용한다.

둘의 차이점은 /는 스크립트가 불러와질 때 컴파일 하고, RegExp는 코드 실행 시점에 컴파일 된다는 점이다.
그렇기 때문에 정규식이 상수라면 /를 사용하는 것이 좋다.
반면에 정규식이 변경되는 경우는 RegExp를 사용하는 것이 좋다.
대부분 사용자가 직접 입력하거나, 다른 곳에서 정규식을 가져오는 경우에 RegExp를 사용한다.

다음으로 정규식 작성 방법을 알아보자.
단순하게 /abc/와 같이 작성할 수도 있고, /ab\*c/ 같이 특수 문자를 조합해서 사용할 수 있다.
단순 패턴은 문자를 그대로 대응시킬때 사용한다.
예를 들어서 문자열에서 abc를 찾는 경우에 사용한다.
이는 "abc"를 찾아서 지정하지만, "ab c" 같이 abc를 그대로 포함하지 않는 문자는 찾지 않는다.

특수 문자는 특정한 패턴이 있는 문자열을 찾을 때 사용된다.
예를 들어서 /ab*c/는 ac, abc, abbc, abbbc 같은 패턴을 찾을 때 사용된다.
여기서 *는 앞의 문자가 0개 이상이란 것을 표현하는 것이다.
이 외에도 다양한 특수 문자가 있으며 MDN의 [Regular Expressions](https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Regular_Expressions)에서 리스트를 볼 수 있다.
아래는 그 중 자주 쓰는 것만 정리했다.

| RegExp | Meaning                                                                      |
| ------ | ---------------------------------------------------------------------------- |
| ^x     | 문자열이 x로 시작됨                                                          |
| x$     | 문자열이 x로 끝남                                                            |
| x\*    | x가 0번 이상 반복됨                                                          |
| x+     | x가 1번 이상 반복됨                                                          |
| x?     | x가 0 또는 1번 나옴                                                          |
| .      | 단일 문자와 대응 e.g.) /.n/는 "an", "on"과 대응                              |
| (x)    | 하나의 그룹으로 만듬. 일반적인 괄호 표현과 동일한 의미                       |
| (?:x)  | 하나의 그룹으로 만들지만, 기억하지 않음.                                     |
| x(?=y) | x 뒤에 y가 오는 경우만 찾음                                                  |
| x(?!y) | x 뒤에 y가 없는 경우만 찾음                                                  |
| x\|y   | x 또는 y가 있음                                                              |
| x{n}   | x가 n번 반복됨                                                               |
| x{n,m} | x가 최소 n, 최대 m번 반복됨. m이 생략되면 m=$\infty$로 간주                  |
| [xyz]  | 괄호 안의 어떤 문자와도 대응. -로 범위 지정 가능 e.g.) [a-d]는 [abcd]와 동일 |
| [^xyz] | ^는 not을 의미. 괄호 안의 어떤 문자와도 대응되지 않음                        |

위는 가장 기본적인 것으로 문자열의 종류와 사용횟수를 정하는게 대부분이다.
예를 들어서 a+는 a가 1번 이상 반복된다는 것을 의미하고, [a-z]{3}는 소문자가 3개 연속된 것을 의미한다.
정규 표현식은 숙련되지 않았더라도 표를 보면서 진행할 수 있다.
이는 위 표를 보면 알 수 있듯이 각각의 설명이 굉장히 단순하기 때문이다.
다만 (?:x)에서 기억하지 않는다는 표현이 이해하기 어려울텐데 이는 조금 있다가 설명하겠다.

정규 표현식은 위의 기본 표현 외에도 특수 문자를 표기하는 방법이 있다.
특수 문자는 \를 사용해서 표기하고 아래처럼 해석한다.

| RegExp | Meaning                                                          |
| ------ | ---------------------------------------------------------------- |
| \      | 뒤에 나오는 문자를 특별하게 해석하게 만듬                        |
| \b     | word boundary 문자와 공백 사이의 문자. 검색 결과에 포함되지 않음 |
| \B     | word boundary가 아닌 문자에 대응                                 |
| [\b]   | 백스페이스                                                       |
| \d     | 숫자에 대응. [0-9]와 동일                                        |
| \D     | 숫자가 아닌 경우에 대응. [^0-9]와 동일                           |
| \n     | 줄바꿈                                                           |
| \s     | 공백문자                                                         |
| \S     | 공백 문자가 아닌 한 문자                                         |
| \t     | 탭                                                               |
| \w     | [A-Za-z0-9]와 동일                                               |
| \W     | [^a-za-z0-9]와 동일                                              |

위에서 예시를 들어보자면 [a-zA-Z0-9]는 \w로 대체할 수 있다.
그 외에도 ., +, ? 같이 정규표현식에서 사용하는 문자는 \를 붙여서 사용해야 한다.
만약 .을 찾아야 한다고 하자.
이때 .라고 적는다면 단일 문자로 인식해서 찾을 수 없다.
이 경우 \\.로 검색해야 .를 찾을 수 있다.

정규 표현식의 끝에 Flag를 추가할 수 있다.
예를 들어서 "/[0-9]/g"와 같이 사용할 수 있다.
각 Flag의 의미는 아래와 같다.

| Flag | Meaning                                       |
| ---- | --------------------------------------------- |
| g    | Global 모든 패턴을 검색                       |
| i    | Ignore Case 문자열의 대소문자를 식별하지 않음 |
| m    | Multi Line 문자열이 다중 라인인 경우도 검색   |

## Using RegExp

정규 표현식은 문자열에서 조건을 만족하는 문자열을 찾는데 사용한다.
이때 정규 표현식을 기준으로 쓸 수도 있고, 문자열을 기준으로도 쓸 수 있다.
정규 표현식 기준으로 사용하면 RegExp.###(string) 형태로 사용한다.
문자열 기준으로 사용하면 string.###(RegExp) 형태가 된다.

### 정규 표현식 기준

#### exec

> RegExp.exec(string)

exec는 RegExp를 만족하는 것을 배열로 반환하는데, 조건을 만족하는 것이 없으면 null로 반환한다.
배열에는 찾은 문자열, 문자열의 위치, 원본 문자열이 담겨 있다.
찾은 문자열은 0번째 index에 저장되어 있다.
이렇게 반환되는 이유는 문자열을 반복적으로 찾기 위해서다.
RegExp의 플래그를 g로 설정했으면 이전 index를 저장한다.
이때 한 번 더 실행하면 index 다음 위치부터 찾기 시작한다.
예를 들어서 아래처럼 작성하면 조건을 만족하는 문자를 모두 찾을 수 있다.

```
const regex1 = RegExp('foo*', 'g');
const str1 = 'table football, foosball';
let array1;

while ((array1 = regex1.exec(str1)) !== null) {
  console.log(`Found ${array1[0]}. Next starts at ${regex1.lastIndex}.`);
  // expected output: "Found foo. Next starts at 9."
  // expected output: "Found foo. Next starts at 19."
}
```

다만 이 방법은 나중에 문자열 기준에서 설명할 matchAll을 사용하는 것이 더 간편하다.
문자를 찾았는지만 필요할 경우 다음의 test로 true/false만 받아올 수 있다.

#### test

> RegExp.test(string)

문자열이 정규 표현식을 만족하는지 여부를 체크한다.
특정 문자가 포함되었는지 여부를 확인할 때 사용하면 좋다.

```
const str = 'table football';

const regex = new RegExp('foo*');
const globalRegex = new RegExp('foo*', 'g');

console.log(regex.test(str));
// expected output: true

console.log(globalRegex.lastIndex);
// expected output: 0

console.log(globalRegex.test(str));
// expected output: true

console.log(globalRegex.lastIndex);
// expected output: 9

console.log(globalRegex.test(str));
// expected output: false
```

### 문자열 기준

#### match

> str.match(RegExp)

match는 정규 표현식을 만족하는 문자열을 반환한다.
exec처럼 g를 사용하는지 여부에 따라 반환되는 내용이 달라진다.
g를 붙이면 조건을 만족하는 모든 내용이 배열에 담겨서 나간다.
g가 없으면 조건을 만족하는 첫 번째 경우만 찾아준다.
예를 들어 문자열에서 모든 대문자를 찾는 경우는 아래처럼 사용할 수 있다.

```
const paragraph = 'The quick brown fox jumps over the lazy dog. It barked.';
const regex = /[A-Z]/g;
const found = paragraph.match(regex);

console.log(found);
// expected output: Array ["T", "I"]
```

#### matchAll

> string.matchAll(RegExp)

정규 표현식 중 플래그 g가 있는 경우만 쓸 수 있다.
이때 찾은 내용은 배열로 반환하며, 각 원소는 exec처럼 찾은 문자, index, 원본 문자가 들어 있다.
exec와 차이점은 while을 사용하지 않고도 해결가능하다는 것이다.

```
const regexp = new RegExp('foo[a-z]*','g');
const str = 'table football, foosball';
const matches = str.matchAll(regexp);

for (const match of matches) {
  console.log(`Found ${match[0]} start=${match.index} end=${match.index + match[0].length}.`);
}
// expected output: "Found football start=6 end=14."
// expected output: "Found foosball start=16 end=24."

// matches iterator is exhausted after the for..of iteration
// Call matchAll again to create a new iterator
Array.from(str.matchAll(regexp), m => m[0]);
// Array [ "football", "foosball" ]
```

#### search

> str.search(RegExp)

정규 표현식을 만족하는 대상을 찾는다.
이때 반환값은 대상의 index가 된다.
그러므로 문자열의 위치를 찾고자 할 때 사용하면 된다.

```
var str = "hey JudE";
var re = /[A-Z]/g;
var re2 = /[.]/g;
console.log(str.search(re)); // returns 4, which is the index of the first capital letter "J"
console.log(str.search(re2)); // returns -1 cannot find '.' dot punctuation
```

#### replace

문자열에서 replace를 사용할때 정규 표현식을 사용할 수 있다.
찾을 문자 대신에 정규 표현식을 사용하면 된다.

```
const p = 'The quick brown fox jumps over the lazy dog. If the dog reacted, was it really lazy?';

console.log(p.replace('dog', 'monkey'));
// expected output: "The quick brown fox jumps over the lazy monkey. If the dog reacted, was it really lazy?"


const regex = /Dog/i;
console.log(p.replace(regex, 'ferret'));
// expected output: "The quick brown fox jumps over the lazy ferret. If the dog reacted, was it really lazy?"

```

## (?:x)

앞서 (?:x)의 설명을 하지 않고 넘어갔다.
우선 (x)는 하나의 그룹으로 만들고 기억한다는 의미다.
이때 기억한다는 의미가 중요하다.
정규 표현식을 사용하다보면 그룹의 내용을 사용해야 하는 경우가 있다.
예를 들어서 첫 번째로 찾은 숫자를 2개로 늘려주고 싶다고 하자.
그런데 replace로 해결하려면 문제가 생긴다.
replace로 교체할 문자가 아직 정해지지 않았기 때문이다.
이때 사용하는 것이 (x)에 기억된 문자다.
()를 사용해서 정규 표현식을 만들면, 해당 문자를 임시로 저장한다.
그리고 저장된 문자를 사용할 수 있게 되는데, $1, $2, $3 ... 등으로 사용할 수 있다.
이때 숫자는 몇 번째 () 안에 있는지에 따라 다르다.
예를 들어서 "a2b3c4d".replace(/(\d)/g, "$1$1")라고 적어주면 "a22b3c4d"가 된다.
즉, $1이 2를 의미한다는 것을 알 수 있다.

또한 정규 표현식 내부에도 사용가능하다.
이때는 정규 표현식에서 특수하게 해석할 때 사용하는 \를 숫자에 붙여 쓴다.
예를 들어서 `ABBCDEEF.match(/(.)\1g)`를 보자.
여기서 (.)는 하나의 문자를 의미한다.
만약 \1이 없었다면 단순히 A를 찾고 끝났을 것이다.
그런데 \1은 (.)에서 찾은 문자와 대응된다.
그러므로 같은 문자가 2개 오는 경우만 찾을 수 있게 된다.
위 방법으로 찾으면 ["BB", "EE"]만 찾을 것이다.

## RegExp to find tag, url

태그 짝을 구하는 Regex: <(\S*)?\s*?[^>]_?>.\*?<\/\1>
태그만 구하는 Regex: <(\S_)?\s\*?[^>]\*?>
url: ((https?:\/\/)|(www\.))([^\/"><\n\s]+)((\/[^"><\n\s]+)+)?

정규 표현식을 사용해서 태그와 url을 찾을 수 있다.
태그를 구하는 법부터 알아보자.

### Tag

태그의 형태를 생각해보자.
태그는 \<tagName props...> 형태다.
처음부터 모든 것을 하려면 어려우므로 우선 \<header> 태그를 찾는다고 생각해보자.
이때 정규 표현식 형태는 /\<header props>/이 된다.
문제는 props가 정해져 있지 않다는 점이다.
props를 정규 표현식으로 표현하려면 생각보다 복잡하다.
다행히도 태그를 찾을 때, 이런 일은 필요없다.
왜냐하면 태그는 항상 "<"로 시작해서 ">"로 끝나기 때문이다.
태그 내부의 props는 ">"를 절대로 포함하지 않는다.
그러므로 props는 "[^>]_"로 찾을 수 있다.
이때 props가 반드시 존재하는 것은 아니므로 뒤에 ?를 붙인다.
props와 header 사이에 빈 문자가 존재하므로 이를 \s로 표시해줘야 한다.
이를 종합하면 정규 표현식은 `/\<header\s_?[^>]\_?>/`가 된다. 이제 header 부분만 바꿔주면 된다. 태그는 소문자로만 이뤄져있으므로 [a-z]로도 충분하겠지만, react를 사용할 경우까지 생각하면 `(\S*)`가 적당하다. 최종적으로 태그를 구하는 정규 표현식은 `/<(\S*)?\s\*?[^>]\*?>/`이다.

이제 태그 짝을 구하는 법을 알아보자.
태그의 형태는 \<header>...\</header>이다.
우선 뒤의 header 부분이 앞의 header과 동일해야 한다.
이는 (\S*)가 기억되고 있으므로 \1로 표시할 수 있다.
그리고 ...부분은 줄바꿈이나 글자이므로 (.|\n)*?로 표시하면 충분하다.
그러므로 `/<(\S*)?\s*?[^>]*?>(.|\n)*?<\/\1>/`로 표시한다.

### url

url을 구하는 방법은 너무 다양하고, url의 종류가 너무 많아서 다 다루기가 어렵다.
대표적인 경우만 다루겠다.
우선 url은 크게 3부분으로 나뉜다.
시작 부분인 http://, https://, www.과 사이트 주소, 내부 주소로 나뉜다.
시작 주소를 표시하는 것은 어렵지 않다.
`((https?:\/\/)|(www\.))`로 쉽게 표시할 수 있다.
여기서 ?는 s가 있을 수도 있고, 없을 수도 있으므로 해줬다.
그리고 www.의 .도 특수문자로 처리해줬다.

사이트 주소는 문자와 .만을 사용하는 경우가 대부분이다.
그리고 내부 주소는 /를 사용해서 구분한다.
그러므로 /가 나오기 전까지의 구간을 사이트 주소로 생각할 수 있다.
하지만 `[^\/]+`만으로는 조금 부족하다.
문자열에서 찾을 경우라면 띄워쓰기, <, >, 줄바꿈 등 다양한 경우가 있을 수 있기 때문이다.
경우에 따라선 오히려 [a-zA-Z0-9@#$%...]처럼 모든 것을 적어주는 것이 좋을 수도 있다.
일단은 `([^\/"><\n\s]+)`정도로 하고 넘어간다.
마지막 사이트 내부는 항상 \로 구분하고 있다.
일관적인 방식이므로 쉽게 찾을 수 있지만, 역시 사이트 내부에 어떤 문자를 쓸지에 따라서 다른 형태를 적용해야 할 수도 있다.
/가 있어야 하는 부분을 제외하고는 사이트 주소와 비슷하게 찾을 수 있다.
일단 `((\/[^"><\n\s]+)+)?` 정도로 해줬다.

url은 인터넷에서 직접 검색해서 하나 사용하는 것을 추천한다.
그리고 몇 가지 안 맞는 경우만 고쳐서 쓰는게 좋다.
이때 [regex101](https://regex101.com/)에서 테스트하면서 진행하면 쉽게 할 수 있다.

참고

1. [What does "matches x and remembers the match" means in regexp](https://stackoverflow.com/questions/27723210/what-does-matches-x-and-remembers-the-match-means-in-regexp)
2. [RegExp](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/RegExp)
