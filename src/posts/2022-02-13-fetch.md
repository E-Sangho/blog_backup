---
layout: post
title: Fetch API
date: Sun Feb 13 23:23:30 JST 2022
categories:
tag:
toc: true
---

## AJAX

### What is AJAX?

AJAX은 Asynchronous JavaScript and XML의 약자로, JavaScript와 XML을 사용해서 비동기적으로 데이터를 교환하는 방법이다.
간단히 말해 브라우저에서 JavaScript로 데이터를 요청하면, 서버에서 XML로 데이터를 전송해주는 법이다.
다만 AJAX라는 이름은 오해의 여지가 있는 이름이다.
XML이라 명시했지만 AJAX는 XML 이외의 다른 형태의 데이터도 전송 가능하다.
그래서 대부분 JSON으로 데이터를 보내고 XML은 사용하지 않는다.
이를 보면 AJAX의 이름을 바꿔야 하겠지만, AJAX는 XML을 사용하는 기법이라기 보다는 고유명사처럼 사용된다.
JavaScript를 사용해서 데이터를 비동기적으로 통신하는 방법을 일컬어서 AJAX라고 부르는 것이다.
결국 AJAX의 핵심은 **Ascynchronous JavaScript**로, 자바스크립트로 비동기적으로 데이터를 교환하는 방법은 모두 AJAX라고 생각할 수 있다.

### How AJAX Works

AJAX 이전엔 웹브라우저가 정보를 요청하면 서버에선 해당 페이지를 전체를 전달했다.
그런데 이 방법은 굉장히 비효율적이었다.
서버는 작은 변화만 있어도 새로 HTML 파일을 생성해야하고, 브라우저는 이를 새로 랜더링 해야 했기 때문이다.
심지어 새로 만든 페이지를 돌려받기 전에는 빈 페이지를 봐야 하므로 로딩도 오래 걸렸다.
이런 문제는 웹 페이지와 데이터가 동기화 되어 있기 때문에 생긴다.
페이지의 디자인과 데이터가 하나로 묶여 있기 때문에 데이터의 변환이 일어나면 페이지 디자인도 새로 수정해야 하는 것이다.

AJAX는 이를 해결하기 위해 디자인과 데이터를 분리한다.
우선 디자인으로 형태만 만들어두는데, 나중에 데이터를 추가할 공간을 만들어 둔다.
그리고 데이터를 받아오면 이를 디자인에 추가해서 보여준다.
예를 들어서 SNS를 생각해보자.
SNS를 보면 각 계정마다 웹 페이지의 형태는 거의 동일하다.
하나 다른 점이라면 포스팅되는 내용인데, 자세히 살펴보면 모두 같은 디자인으로 이뤄져있다.
결국 디자인은 같지만 받아오는 데이터에 따라 다르게 표시된다는 것이다.

클라이언트가 서버에 페이지를 요청하면 HTML, CSS가 전달된다.
브라우저는 이 파일들로 디자인 형태를 만드는데, 그 안에는 데이터가 들어올 경우 보여줄 공간이 있다.
그 후 HTML은 JavaScript 파일을 요청해서 실행하게 된다.
JavaScript는 데이터를 요청하는 내용이 들어 있는데, 보통 버튼을 클릭하거나 페이지를 불러올 때 실행된다.
서버에서는 요청에 맞는 데이터를 반환하고, 이를 비워둔 공간에 추가한다.

이 방식의 가장 큰 장점은 웹 페이지의 일부만 수정한다는 점이다.
그 덕분에 페이지를 새로고침 하지 않아 사용자의 편이성이 증가한다.
뿐만 아니라 서버 입장에서도 일일이 새로 만드는 낭비를 하지 않는다.

### Using AJAX

AJAX를 사용하려면 몇 가지 선택지가 있다.
대표적으로 XMLHttpRequest, fetch API, Axios jQuery 등이 있다.
각기 방법은 다르지만 핵심은 요청을 보낸다는 사실과, 받은 데이터를 사용한다는 점이다.

## Asynchronous Function

프로그래밍은 일반적으로 이전의 연산이 끝나야 다음 코드가 실행된다.
그렇지만 JavaScript 코드 중에는 연산이 끝나지 않았는데도 다음 코드가 먼저 실행되는 경우가 있다.
이들을 비동기 함수라고 하며, 비동기 함수의 연산이 끝나기도 전에 다음 함수가 실행된다.
당연하게도 비동기 함수가 포함되면 프로그램의 작동 순서가 비직관적이게 된다.
위의 코드가 아래보다 먼저 작동할 것이란 예상과 다르게 뒤죽박죽으로 섞여서 사용이 어려워지기 때문이다.
그럼에도 불구하고 JavaScript에서 비동기 함수를 사용하는 이유는 JavaScript가 싱글 스레드 언어이기 때문이다.

JavaScript가 싱글 스레드라는 것은 곧 Call Stack이 하나 뿐이라는 의미다.
코드가 진행되면서 실행해야 하는 함수는 Call Stack에 쌓이는데, 만약 처리가 느린 함수가 들어오면 다음 작업이 시작되지 못하고 막혀버린다.
이 특성은 웹에서 치명적인 것이 데이터 전송과 수신이 빈번하게 일어나기 때문이다.
만약 데이터를 요청했다면 그에 대한 응답을 받기 전에는 코드가 멈추게 되는데, 매 번 이런 일이 발생한다면 지나치게 느리게 작동할 것이다.
JavaScript는 이렇게 시간이 오래 걸리는 함수를 모두 비동기 함수로 만들었다.
그래서 시간이 걸리는 함수가 포함되더라도 다음 단계의 코드를 실행시킨다.

잠시 JavaScript가 런타임 과정을 살펴보자.
JavaScript 코드가 실행될 때, Call Stack, API, Event Loop, Callback Queue를 사용한다.
코드가 진행되면서 Call Stack에 함수가 쌓이게 된다.
만약 동기함수라면 바로 처리되어서 결과가 나타나지만, 비동기 함수라면 조금 다른 경로를 거친다.
Call Stack에서 비동기 함수가 처리되어야 할 순번이 되면, Call Stack은 비동기 함수를 API로 넘겨준다.

API는 환경에 따라 다르지만, 웹이라면 Web API가 될 것이다.
API는 JavaScript 외부에 존재하는 것으로 C 같은 low-level 언어로 작성되어 있다.
그래서 JavaScript에서 할 수 없는 일도 할 수 있고 동시에 여러 일을 할 수도 있다.
또한 API는 기존 코드와 별개로 일을 처리하기 때문에 JavaScript가 싱글 스레드라는 단점을 보완해준다.

API가 비동기 함수의 처리를 끝내면 이를 다시 JavaScript에 돌려줘야 한다.
이를 위해서 Callback Queue와 Event Loop를 사용한다.
비동기 함수를 실행한 결과는 Callback Queue에 쌓인다.
그리고 Event Loop는 Call Stack이 비어 있는지 확인하고, 만약 비어 있으면 Callback Queue의 내용을 순서대로 Call Stack에 전달한다.
이렇게 해서 API로 건너갔던 함수의 결과가 다시 JavaScript 내부로 돌아오게 된다.

그런데 비동기 함수간의 순서가 중요한 경우가 있다.
순서대로 코드를 작성하더라도 비동기 함수의 특성상 작동하는 순서는 보장할 수 없다.
그렇기 때문에 Callback 함수를 사용하는데, 앞의 비동기 함수가 끝나면 실행할 함수를 Callback 함수로 전달하는 것이다.

문제는 Callback 함수도 결함이 있다는 점이다.
우선 함수 안에 함수가 반복되기 때문에 가독성이 안 좋다.
게다가 기존 코드를 수정하려면 굉장히 번거롭다.
이 때문에 Callback 함수를 사용하는 대신에 Promise를 사용한다.

## Promise

Callback 함수로 비동기 연산을 진행하면 크게 2가지 문제가 있다.
첫 번째로 에러처리가 힘들고, 두 번째로 가독성이 나쁘다.
이 두 문제점은 다른 문제점으로 파생되는데, 예를 들어서 코드를 수정하기 어렵다거나, 다른 사람이 읽기 어렵다는 문제점이 있다.
이런 문제점을 해결하기 위해서 ES6부터 Promise를 도입했다.

Promise는 이름 그대로 약속을 의미하는데, 가까운 미래에 데이터가 돌아올 것을 약속한다.
예를 들어 데이터를 요청하는 비동기 함수가 있다고 하자.
이 함수는 현 시점에는 데이터가 없지만, 시간이 지나면 데이터가 돌아올 것이다.
Promise는 돌아오는 데이터를 지정해주는데, 이것만으로도 큰 장점이 있다.

잠시 Callback 함수로 돌아가보자.
Callback 함수는 함수에 이름을 주는 것이 의미가 없다.
왜냐하면 각 Callback 함수의 실행 순서가 중요할 뿐이지, 그 함수 내부에서 앞선 함수를 호출하지 않기 때문이다.
그래서 Callback 함수는 내부적으로 이어지는 구조로 밖에 만들 수 없다.

반면 Promise는 이름을 가지고 있으므로, 이름을 별도로 지정해서 사용할 수 있다.
이 작은 차이 하나로 사용성이 크게 증가하는데, 이는 앞으로 Promise의 사용법에서 차차 알 수 있다.
우선 Promise를 사용하는 방법을 알아보자.
아래는 Promise를 선언하는 방법이다.

> new Promise(executor)

여기서 executor는 Callback 함수로 resolve와 reject를 변수로 사용한다.
Promise가 하는 일은 간단한데, 변수로 받은 executor를 실행하는 것이다.

```
new Promise((resolve, reject) => {
    // Do Something
})
```

resolve와 reject를 설명하기 전에 Promise의 3가지 상태를 설명해야 한다.

-   대기(pending): 초기 상태. 아직 아무런 연산도 하지 않음.
-   이행(fulfilled): 성공
-   거부(rejected): 실패

처음 Promise가 선언될 때는 대기 상태로 존재한다.
그리고 안의 Callback 함수의 실행에 따라서 이행이나, 거부 단계가 된다.
Callback 함수는 두 변수 resolve, reject를 사용한다.
resolve()는 비동기 연산이 성공했을 때 사용하며, 결과값을 반환하는데 사용한다.
반면 reject()는 실패시에 사용하며, 오류의 원인을 돌려준다.
resolve나 reject를 실행하면 Callback 함수는 종료되고, Promise는 이행이나 거부 상태가 된다.

```
new Promise(function(resolve, reject) {
    // Do asynchronous things

    // if succeed
    // resolve(value);      // fulfilled

    // failed
    // reject(error);       // rejected
})
```

위처럼 resolve를 실행하면 fulfilled 상태가 되고, reject를 실행하면 rejected 상태가 된다.
Promise는 이행과 거부시에 사용할 함수를 then으로 쓸 수 있다.

> Promise.then(onFulfilled, onRejected)

여기서 onFulfiled와 onRejected는 Callback 함수로 각각 이행, 거부 시에 실행하는 함수다.

```
function getInformation() {
    return new Promise((res, rej) => {
        let info = [1, 2, 3];
        res(info);
    })
}

getInformation
    .then((info) => {
        console.log(info);
    }, (err) => {
        console.log(err);
    });
```

여기서 Promise의 장점은 then이 다시 Promise를 반환한다는 점이다.
그래서 then 이후에도 then을 이어서 계속 다음에 작동할 함수를 적어줄 수 있다.

Promise는 그 외에도 catch가 존재하는데, catch는 거부시에 작동하는 함수다.

> Promise.catch(onRejected)

catch는 내부적으로 then(null, onRejected)로 만들어지므로 then과 다를 바 없다.
그렇지만 then을 이행시에 사용할 함수를 적고, catch에 거부시에 사용할 함수를 적음으로써 가독성을 높일 수 있다.

```
function getInformation() {
    return new Promise((res, rej) => {
        let info = [1, 2, 3];
        res(info);
    })
}

getInformation
    .then((info) => {
        console.log(info);
    })
    .catch((err) => {
        console.log(err);
    });
```

## async/await

async는 async 함수를 만들기 위한 키워드로, 함수 앞에 async를 붙여서 만든다.

```
async funciton a () {
    ...
}

let a = async () => {
    ...
}
```

async 함수는 항상 Promise를 반환한다.
이때 만약 함수의 반환값이 Promise가 아니라면 Promise로 변환해서 반환해준다.

```
async funciton a() {
    return 1;
}

f()
// The result of f() is
// Promise {<fulfilled>: 1}
```

그러므로 async 함수는 뒤에 then, catch를 사용해서 쓸 수 있다.

다른 키워드로 await이 있는데, await은 async 함수 안에서 사용할 수 있는 키워드다.
await은 Promise 앞에 사용하는데, JavaScript는 await을 만나면 코드를 더 진행시키지 않고 멈춘다.
그리고 Promise 처리가 완료될 때까지 기다리고 결과값을 받은 다음에 다음 줄부터 실행된다.
예를 들어 아래 코드를 보자.

```
async function f() {
    let result = await promise;
    console.log(result);
    return result;
}
```

일반적인 함수였으면 promise는 Web API로 넘어가고 다음줄이 실행된다.
그리고 result가 출력될텐데, 아직 그 안에 아무런 내용이 없으므로 빈 내용이 출력된다.
그렇지만 await을 사용했으므로 promise가 값을 반환할때까지 기다린 다음 코드를 이어간다.
이 경우 result에 promise에서 받아온 값이 들어 있으므로 결과물이 제대로 출력된다.

Promise를 사용하면 비동기 함수를 좀 더 간편하게 쓸 수 있었다.
그렇지만 매 번 then을 사용해나가면서 흐름이 끊겨 보인다.
반면 async/await을 쓰면 위에서 아래로 내려가는 코드의 흐름을 그대로 따른다.
그렇기 때문에 코드의 작동 순서도 알기 좋고, 가독성도 더 좋아진다.

Promise에선 에러가 발생할 경우를 위해 then/catch를 사용했다.
async 함수에서는 try/catch를 사용하는데, try 안의 await이 에러를 일으키면 catch로 코드가 넘어간다.
이때 catch에서 반환된 에러를 사용할 수 있다.

```
async function f() {
    try {
        let result = await fetch(url);
    } catch(err) {
        console.log(err);
    }
}
```

아니면 Promise가 반환되는 것을 사용해서 밖에서 catch를 사용할 수도 있다.

```
async function f() {
    return let result = await fetch(url);
}

f().catch(err);
```

## fetch API

결론부터 말하자면 AJAX를 사용하려면 **fetch API**를 사용하면 된다.
XMLHttpRequest 등의 다른 방식도 존재하지만 여러 단점 때문에 현재는 대부분 fetch를 사용한다.
XMLHttpRequest는 떨어지는 가독성, 이벤트 기반이라 event listener에 묶이는 등의 문제점이 존재한다.
이런 단점 때문에 사람들이 jQuery를 많이 사용했었는데, ES6에서 fetch API가 등장했다.
fetch API는 promise 기반으로 만들어졌기 때문에 사용하기 간편하고 가독성이 좋다.
게다가 기본적으로 내장되어 있어 별다른 라이브러리 없이 사용할 수 있다는 점도 큰 장점이다.

> let promise = fetch(url, [options])

-   url: 요청을 보낼 URL
-   [options]: method, header 등을 지정하는 변수

[options]에 아무 내용도 적지 않으면 GET 메소드로 요청이 이뤄지고, 해당 url로 부터 정보를 받아온다.
fetch()는 promise를 반환하므로 요청의 성공, 실패에 따라 코드가 진행되도록 만들 수 있다.

fetch()가 반환한 promise는 안에 response를 포함하고 있다.
요청의 성공이나 실패에 상관없이 항상 response를 반환하는데, 그 안에 headers나 status 같은 내용이 들어 있다.
Promise에 then을 사용할 때, response를 여러 방법으로 바꿀 수 있다.

-   response.text()
-   response.json()
-   response.formData()
-   response.body()

그 중에서 가장 많이 쓰이는 것은 `response.json()`으로, 이를 가지고 하나의 예시를 보겠다.

```
let result = fetch(url);

result.then((response) => response.json())
```

위와 같이 사용하면 fetch로 받은 내용을 json 형태로 반환하게 된다.
다만 주의할 것은 response는 여러 개를 동시에 사용할 수 없다.
만약 response.json()을 사용했다면, 내용이 모두 처리된 상태로 넘어간다.
그래서 추가로 response.text()를 사용해도 작동하지 않는다.

[options]에 method나 headers를 추가해서 다른 형태로도 사용할 수 있다.
가장 많이 쓰이는 것은 POST method로, 그 외의 설정은 경우에 따라 MDN을 참조하는 것이 좋다.

```
let response = await fetch(url, {
    method: 'POST'
})

let result = await response.json();
console.log(result);
```
