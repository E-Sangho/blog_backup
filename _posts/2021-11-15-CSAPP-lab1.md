---
layout: post
title: "CS:APP Lab 1 Datalab"
date: Mon Nov 15 09:37:13 JST 2021
categories: CSAPP
tag: Lab Lab1
toc: true
---
## Before we start
과제를 하면서 내가 아직 모르는 부분이 많다는 것을 느꼈다. 문제를 풀어보면 각 연산자의 특징으로 사용할 것을 짐작하고, 가능한 각 경우의 수를 테스트한 경우가 많았다. 그런데 각 연산자를 제대로 알지 못하다보니 생각보다 오랜 시간이 걸렸다. 그래서 과제를 설명하기 전에 어떤 성질이 있는지를 알고 있으면 편하게 풀 수 있다. 핵심적인 것은 Tmax, 1, 0, -1, Tmin을 어떻게 바꾸는지, 그리고 각 연산자를 사용하는 몇 가지 팁을 정리하려고 한다.

### &
&는 두 operhands가 모두 1일 경우만 1이 되고, 그 외에는 0이 된다. 그리고 x와 Tmax, 1, 0, -1, Tmin과의 연산을 살펴보자.

Tmax는 0111...11의 형태이므로 &를 사용하면 부호를 제외한 나머지 비트 벡터를 구할 수 있다.

1은 마지막 비트를 구할 수 있다. 이는 >>와 같이 쓰면 부호를 구하는데 굉장히 유용하다. 어떤 수의 부호를 구하고 싶다면 그 비트를 오른쪽으로 밀어주는 것을 생각한다. 그러므로 가장 먼저 떠올리는 것은 `x >> 31`이 된다. 하지만 이는 양수에서만 잘 작동하고 음수에서는 잘 작동하지 않는다. 왜냐하면 >>는 비트를 오른쪽으로 밀어준 후에 제일 왼쪽 비트를 넣어주는데, 음수는 1이 계속 복사되므로 원하는 대로 부호 비트만 남지 않는다. 그래서 `& 1`과 같이 사용해서 `(x >> 31) & 1`로 사용하면 부호를 간단히 구할 수 있다.

0과의 연산은 무조건 0이 나오기 때문에 그다지 쓸만하지는 않다.

-1과의 연산은 해당 수를 그대로 내놓는다.

Tmin과의 연산은 부호 비트를 계산하는데 사용할 수 있다. 이 경우 부호 비트가 제일 왼쪽에 남기 때문에 그대로 사용하거나, 앞서 말한 `(x >> 31) & 1`과 함께 사용해서 `((x & Tmin) >> 31) & 1`로 써도 된다.

### |
|가 유용한 점은 if-else 형태를 사용할 수 있다는 점이다. 예를 들어서 아래와 같은 코드를 작성하고 싶다고 하자.

```
if (condition) {
  code1
} else {
  code2
}
```

하지만 우리 과제에서 if-else를 사용하는 것을 제한했기 때문에 사용할 수 없다. 대신 `(condition) & code1 | !(condition) & code2` 형태로 이를 대체할 수 있다. 물론 &를 사용하기 때문에 condition이 어떤 결과값을 내놓는지와 code1, code2를 잘 조율해야 한다. 확실한 것은 조건에 따라 나뉘는 경우에 1순위로 생각할 수 있는 방법이다.

### ~
~를 Tmax, 1, 0, -1, Tmin에 사용하면 각각 Tmin, -2, -1, 0, Tmax가 된다. 보통은 `-x = ~x + 1`을 이용해서 -x를 구하는데 사용한다. 만약 -를 각각 Tmax, 1, 0, -1, Tmin에 적용하면 각각 Tmin + 1, -1, 0, 1, Tmin이 된다. 여기서 눈여겨 볼 점은 0과 Tmin이 그대로 자기자신이 된다는 점이다.

### ^
^는 같은 수끼리 사용했을 경우에만 0이 된다. 그러므로 딱 하나 예외를 둔 경우에 사용되는 경우가 많다. 또한 결과값을 바꿔주는데도 유용하다. 예를 들어 어떤 코드가 0을 넣으면 0이 나오고, 1을 넣으면 1이 나온다고 하자. 그런데 이 결과를 서로 바꾸고 싶을 수도 있다. 이 때 ^를 사용해서 `code ^ 1`로 써주면 0은 1이 되고 1은 0이 되는 결과를 간단히 만들 수 있다. 다음으로 Tmax, 1, 0, -1, Tmin과의 연산 결과는 각각 아래 테이블처럼 된다.

|   ^  | Tmax | 1 | 0 | -1 | Tmin |
|   -  |   -  | - | - | -  |   -  |
| Tmax | 0 | 0111...10 | Tmax | Tmin | -1 |
|   1  | 0111...10| 0 | 1 | 1111...10 | 1000...01 |
|   0  | Tmax| 1 | 0 | -1 | Tmin |
|  -1  | Tmin| 111...10 | -1 | 0 | Tmax |
| Tmin |  -1 | 1000...01 | Tmin | Tmax | 0 |

### !
!으로 0을 1로 그 외의 수를 0으로 만들 수 있다. 이를 이용해서 `!!x`를 사용하면 0은 0으로 보내고, 그 외의 수는 1로 보내줄 수 있다.

## Lab1 datalab
이 과제에세 제출하면 되는 것은 **bits.c** 파일뿐으로, 13개의 프로그래밍 퍼즐을 포함하고 있다. 각 과제의 뼈대 함수를 정수에 사용하는 기본적인 코드만으로 완성시켜야 하는데, 반복문이나 조건문 같은 것은 사용할 수 없다. 다시 말해 **!, ~, &, ^, |, +, <<, >> 만으로 코드를 완성 시켜야 한다.** 또한 8bits보다 긴 상수를 사용할 수 없다. 자세한 것은 **bits.c** 파일의 주석을 확인하자.

## Evaluation

### Correctness points
각 문제는 난이도별로 1~4점으로 배점되어 있으며 총합 36점이다. 작성한 함수는 **btest**라는 프로그램으로 채점하며 다음 장에 사용법이 있다.

### Performance points
이 과제의 목적은 단순히 문제를 푸는 것 만이 아니라, 최대한 짧고 간단하게 코드를 작성하는 법을 배우는 것이다. 그래서 각 함수마다 사용가능한 연산 횟수를 지정해놓았는데, 이 값은 굉장히 커서 심각하게 비효율적인 경우가 아니라면 통과할 수 있다. 각 조건을 만족하면 2점씩 받는다.

## Autograding your work
-**btest**: bits.c 안의 함수의 정확도를 확인한다. 사용하려면 `make`->`./btest`로 사용할 수 있다. 중요한 것은 bits.c 파일을 수정할 때마다 btest를 다시 작동시켜야 한다. 또한 -f를 사용하면 각 함수별로 체크하는 것도 가능하다. 예를 들어 `./btest -f bitXor`라고 쓰면, bitXor만 체크한다.
-**dlc**: 이 프로그램은 사용하면 안 되는 연산자를 사용하거나, 너무 많은 연산자를 사용하는 등의 결함을 검출해주는 프로그램이다. `./dlc bits.c`로 작동 가능하다. 추가로 -e를 사용해서 각 함수별로 얼마나 많은 연산자를 사용했는지 검사할 수 있다. `./dlc -e bits.c`
-**driver.pl**: btest와 dlc를 사용해서 정확도와 효율성 점수를 채점한다. `./driver.pl`로 사용하면 되며 과제의 채점은 driver.pl로 하면 된다.

## Solve

### bitXor
^를 &와 ~만으로 구현해야 한다. 간단히 ^, &, ~를 테이블로 한 번 표현해보겠다.

| ^ | 1 | 0 |
| - | - | - |
| 1 | 0 | 1 |
| 0 | 1 | 0 |

| & | 1 | 0 |
| - | - | - |
| 1 | 1 | 0 |
| 0 | 0 | 0 |

| ~ | 0 | 1 |
| - | - | - |
|   | 1 | 0 |

여기서 &를 생각해보자. &는 기본적으로 1이 나오는 경우의 수를 줄이는 연산이다. 그렇기 때문에 우리가 ^를 만들고 싶다면 아래 두 결과를 만들어서 &를 사용해줘야 한다.

| a | 1 | 0 |
| - | - | - |
| 1 | 1 | 1 |
| 0 | 1 | 0 |

| b | 1 | 0 |
| - | - | - |
| 1 | 0 | 1 |
| 0 | 1 | 1 |

그렇다면 a와 b는 무엇이 될 수 있을까? 이는 ~이 1과 0을 바꾸는 연산임을 기억하면 쉽게 유추할 수 있다. a와 bㅇ에 ~을 붙이면 아래처럼 된다.

| ~a | 1 | 0 |
| -  | - | - |
| 1  | 0 | 0 |
| 0  | 0 | 1 |

| ~b | 1 | 0 |
| -  | - | - |
| 1  | 1 | 0 |
| 0  | 0 | 0 |

이 둘은 모양만 봐도 &로 쉽게 만들 수 있다. 즉 ~a = (~x & ~y)가 되고, ~b = (x & y)가 된다. 다시 말해서 a = ~(~x & ~y), b = ~ (x & y)고 ^ = a & b = ~(x & y) & ~(~x & ~y)로 계산할 수 있다.

또는 ~x & y와 x & ~y의 결과로도 만들 수 있다. 이 경우도 살펴보자. 우선 두 연산의 결과는 아래와 같다.

| x & ~y | 1 | 0 |
|   -    | - | - |
|   1    | 0 | 1 |
|   0    | 0 | 0 |

| ~x & y | 1 | 0 |
|   -    | - | - |
|   1    | 0 | 0 |
|   0    | 1 | 0 |

그리고 이들에 ~을 붙인 다음 &를 계산하고 다시 ~을 붙이면 된다. 결국 ~(~(x & ~y) & ~(~x & y))도 답이 된다.

결국 내가 찾아낸 답은 2가지로 하나는 ~(x & y) & ~(~x & ~y)이고, 다른 하나는 ~(~(x & ~y) & ~(~x & y))다. 다만 연산자의 수가 전자가 7개 후자가 8개이므로 전자를 사용하는 것이 더 적절하다. 

```
int bitXor(int x, int y) {
  return ~(x & y) & ~(~x & ~y);
}
```

### tmin
2의 보수 중에서 가장 작은 값을 반환하는 함수다. 2의 보수 계산법을 기억해보면 가장 작은 수는 10000...000이다. 그러므로 1000...00을 만들면 된다. 해법은 간단히 1 << 31을 하면 된다. 이는 32bits에만 성립하므로 다른 환경에서도 똑같은 결과가 나오는 것을 고민해봤지만, logical shift 없이는 할 수 있는 방법을 찾지 못했다. 문제의 조건에서 제약이 많아서 아마 이 외의 답은 없을듯 하다.

```
int tmin(void) {
  return 1 << 31;
}
```

### isTmax
x가 들어왔을 때, 2의 보수의 최대값이면 1을 아니라면 0을 반환하면 된다. 사용가능한 연산은 !, ~, &, ^, |, +로 shift를 사용할 수 없다.

당연히 문제를 보는 순간 !(x ^ 0x7FFFFFFF)를 떠올릴 것이다. 하지만 우리는 너무 큰 상수를 사용할 수 없게 되어 있다. 그러므로 저 수를 직접 만들어주거나, 다른 방향으로 접근해야 한다.

우리가 사용할 수 있는 수 중에서 의미있는 것은 사실상 x, 1, 0 뿐이다. 왜냐하면 나머지 2, 3, ... 등은 1의 합으로 표현될 뿐더러 별다른 특성이 없다. 그러므로 x, 1, 0에 위의 연산을 넣었을 경우를 생각해보자.

!는 0인 경우만 1이 되고 나머지 경우는 0이 된다. 우리 문제의 경우 최대값인 경우에만 1이 나오고 나머지 경우는 0이 나와야 한다. 어떤형식으로 사용될지는 아직 모르지만 확실한 것은 !이 사용되어야 한다는 것이다.

~은 간단한 방법으로 수를 확장해준다. ~x(-x-1), ~1(-2), ~0(-1)이 사용가능한데 ~1은 그다지 의미 없는 수이므로, ~로 수를 확장하면 x, 1, 0, -1, ~x를 사용가능하다고 생각해도 된다.

&은 두 수가 1일 경우에만 1이 나온다. &는 결국 두 수가 얼마나 비슷한지와 관련된 연산이다. 그래서 x와 1, 0, -1, ~x를 계산해봐도 그다지 의미있는 수는 나오지 않으므로 &는 사용되지 않는다.

^는 두 수가 완전히 같을 때만 0이 나온다. 우리가 원하는 경우가 하나 뿐인 경우에 사용할 수 있다.

|는 경우의 수를 표현하기 좋아서 예외 사항이 하나 있을 경우 사용가능하다.

다시 돌아가서 우리가 1이 나오길 원하는 수는 Tmax(011...11)이다. Tmax로 생각해볼 수 있는 유의미한 계산은 다음과 같다.

- Tmax + 1 = Tmin
- 2 * Tmax + 2 = 0

그 중에서 아래 식을 사용해서 문제를 풀어봤다.

2 * Tmax + 2는 사실 2 * (Tmax + 1)이고 2를 곱하는 것은 수를 왼쪽으로 한 칸씩 미는 것과 동일하다. 결국 저 식을 해석하자면 Tmax에 1을 더하면 100...00이 되고 이를 왼쪽으로 한 칸 밀어주면 0이 된다는 것이다. 만약 Tmax만 이를 만족한다면 !를 사용해서 굉장히 간단하게 해결할 수 있다. 문제는 -1(111...11) 또한 이를 만족한다는 사실이다. 그 외의 수는 별 문제 없이 만족하므로 저 경우만 해결해주면 된다.

지금까지의 분석 결과를 정리하면, 

- 마지막에 !를 써서 Tmax만 1로 만든다.
- 2 * (Tmax + 1) = 0을 써야한다. shift가 허용되지 않으므로 x + x + 2를 쓴다.
- -1의 경우만 예외 처리해야 하므로 |를 사용한다.

결국 식은 !((x + x + 2) | (x+1))의 형태에서 조금 조정을 해줘야 한다. x가 Tmax라면 !(0 | 1) 이라서 0이 되고, x가 -1이면 !(0 | 0)이라서 0이 된다. 그 외의 숫자는 !(1 | 1)로 0이 된다. 이는 우리가 원하던 결과가 아니니 조금 수정이 필요하다. 그런데 우리가 원하는 결과는 각각 !(0 | 0), !(0 | 1), !(1 | 0)이 되는 경우로 마지막 수가 반대로 되면 된다. 그러므로 !를 사용하면 간단히 해결할 수 있다. 결국 식은 **!((x + x + 2) | !(x + 1))**이 되어야 한다.

### allOddBits
홀수번째에 모두 1이 있는지 확인하는 문제다. 단, least significant digit이 0번째이고, most significant digit이 31번째로 생각해야 한다. 이는 만약 0xAAAAAAAA를 사용할 수 있다면 굉장히 간단하다. 왜냐하면 x & 0xAAAAAAAA으로 짝수번째 자리는 수에 상관 없이 0으로 만들고, 홀수번째가 1인 경우에만 1로 만든다. 그 다음 이를 Xor로 0xAAAAAAAA와 비교해서 수가 같은 경우만 남기면 된다. 왜냐하면 Xor로 수가 같지 않다는 뜻은 홀수 번째에 1이 없다는 의미기 때문이다. 마지막으로 Xor을 사용하면 둘이 같을 경우 0이 나오므로 !를 사용해서 값을 바꿔줘야 한다. 결국 답은 !((x & 0xAAAAAAAA) ^ 0xAAAAAAAA)가 된다.

문제는 상수로 사용할 수 있는 수가 0x00~0xFF가 끝이라는 것이다. 이 보다 큰 수는 상수로 사용할 수 없도록 해놓았으므로 직접 만들어줘야 한다. 이는 <<로 굉장히 간단히 해결할 수 있다. 8칸 밀어주고 원래 수를 더하고, 다시 16칸 밀어주고 원래 수를 더해주면 된다. 결국 정답은 다음처럼 된다.

```
int allOddBits(int x) {
  int AAAAAAAA = 0xAA;
  AAAAAAAA += AAAAAAAA << 8;
  AAAAAAAA += AAAAAAAA << 16;
  return !((x & AAAAAAAA) ^ AAAAAAAA);
}
```

### negate
-x를 구하면 되는 굉장히 간단한 문제다. ~x = -x -1이므로, -x = ~x + 1이 된다.

```
int negate(int x) {
  return ~x + 1;
}
```

### isAsciiDigit
부등호를 표현하는 식을 구현할 수 있는지 묻는 문제다. $a \leq b$ 식을 다르게 표현하면 $0 \leq b - a$가 된다. 여기서 $-a$는 $~a + 1$로 구할 수 있으므로 식은 $0 \leq b + ~a + 1$이 된다. 결국 우리는 $b + ~a +1$이 0이상인지 여부를 확인할 수 있으면 된다. 수가 만약 음수라면 제일 앞의 비트가 1일 것이므로, 제일 앞 자리 비트를 확인해주면 된다. 지금까지의 아이디어를 코드로 바꾸면 `(b + ~a + 1) >> 31`인데, 수가 양수일 경우엔 0이 되고, 음수일 경우엔 1이 된다. 우리는 결과값이 반대로 되길 원하므로 !를 사용해서 반대로 적용해준다. `!(b + ~a + 1) >> 31`

우리가 적용해야 하는 범위는 0x30에서 0x39까지 이므로 식이 두 개가 나오고 둘 다 만족해야 한다. 그러므로 식은 `!(0x39 + ~x + 1) >> 31 & !(x + ~0x30 + 1) >> 31`이다.

### conditional
x ? y : z를 구현하는 문제다. 우선 x가 참이면 1이 나오고 거짓이면 0이 나와야 한다. 이는 !!(x)로 간단히 할 수 있다. 그리고 if/else와 같은 효과를 위해 |를 사용한다. 형태는 (condition1) & y | (condition2) & z 형태가 되어야 한다. 그리고 condition1, 2는 x가 참, 거짓일 경우 번갈아가며 111...111이 되고 거짓일 경우 000...000이 되도록 하면 된다.

우선 왼쪽 조건을 구하면 !를 사용해서 오른쪽도 적절히 수정가능할 것이다. 그러므로 왼쪽 조건부터 구해보겠다. x를 !!x로 참인 경우는 1로 거짓인 경우는 0으로 일괄적으로 바꿀 수 있다. 그러므로 우리가 해야할 것은 1일 경우 111...111이 되고, 0일 경우 000...000이 되도록 하면 된다. 수를 잘 살펴보면 111...111은 -1이고 000...000은 -0이다. 다시 말해서 a에 -를 붙여주는 연산인 ~a+1을 해줘야 한다. 그러므로 왼쪽 조건은 ~!!x+1이 된다.

왼쪽 조건을 찾았으므로 오른쪽도 찾아보자. 우선 ~a+1이 a가 1일 경우엔 111...111이 되고, 0일 때는 0이 된다. 왼쪽에는 x가 참일 때 a에 1을 넣고, 거짓일 때 0이 들어가야 했다. 반대로 오른쪽에는 x가 참일 때 0을 넣고, 거짓일 경우 1이 들어가야 한다. 이는 간단히 !를 사용하면 해결된다. 그러므로 오른쪽의 a에 들어갈 것은 !!!x가 된다. !!는 의미가 없으므로 간단히 !x로 정리해준다. 결과적으로 식은 아래처럼 된다.

```
int conditional(int x, int y, int z) {
  return ((~!!x+1) & y) | ((~!x+1) & z);
}
```

### isLessOrEqual
y-x >= 0을 그대로 이용하면 비트의 범위를 벗어나 오류가 발생한다. 그러므로 수의 부호를 바탕으로 계산해야 한다. 우선 둘의 부호가 같은 경우, y - x를 해도 표현 가능한 범위를 벗어나지 않는다. 서로 부호가 다르다면 수의 크기를 비교할 필요 없이 부호만으로 계산이 가능하다.

우선 어떤 수가 주어졌을 때, 부호를 알아낼 수 있어야 한다. 단순히 shift만으로 해결되지 않는 것이, arithmetic shift이기 때문에 오른쪽으로 밀어줘도 왼쪽에 sign digit이 하나씩 추가 되기 때문이다. 그래서 shift 이후에 & 1을 사용해서 첫 번째 자리만 남기고 나머지는 없애 줘야 한다.

두 수의 부호가 같은지를 확인할 때는 앞에서 구한 x_sign과 y_sign을 이용하면 바로 구할 수 있다. 이 때는 &1을 해줄 필요가 없는 것이 어차피 000...001, 000...000으로만 ^ 연산을해서 마지막 자리 빼고는 모두 확실히 0이 된다.

if문 또는 conditional을 구현하는 것을 기억하면 조건문은 `(condition) & ... | (!condition) & ...`으로 나타난다. 여기서 우리는 두 부호가 동일한지 아닌지에 따라 갈리므로 condition은 `x_sign ^ y_sign` 이 된다. 만약 두 부호가 동일하다면 앞서 말했듯이 y-x로도 범위를 벗어나지 않으므로 계산 결과의 부호를 사용해주면 된다. 부호가 다르다면 x의 부호가 -라면 자동적으로 y가 더 크게 된다.

```
int isLessOrEqual(int x, int y) {
  int calc = y + ~x + 1;
  int calc_sign = (calc >> 31) & 1;
  int x_sign = (x >> 31) & 1;
  int y_sign = (y >> 31) & 1;
  int xor_sign = x_sign ^ y_sign;
  return (xor_sign & x_sign) | ((!xor_sign) & (!calc_sign));
}
```

### logicalNeg
!를 사용하지 않고 !를 만드는 문제다. !는 0일 경우만 1이 되고 그 외에는 모두 0이 된다. 즉, 어느 한 경우만 특징적인 것이 있는 연산을 사용해야 한다. 경우의 수는 2가지다 &는 0과 -0의 계산 결과가 0이다. 그리고 ^ 역시 똑같은 수를 사용할 경우 0이 나온다는 특징은 있다.

만약 x와 -x가 동일하다면 이는 0일 것이다. 이를 코드로 옮기면 `(x ^ (~x + 1))` 이다. x가 0인 경우 이 코드는 0이 된다. 그 외의 수는 모두 1로 만들어야 한다. 그 외의 수들은 모두 부호가 다르므로 ^를 사용했을 때, 제일 앞 비트가 1이 된다. 그러므로 >> 31을 사용해준다. 이를 정리하면 `(x ^ (~x + 1)) >> 31`이다.

여기까지 한 결과 0은 0으로 보내고, 그 외의 수는 모두 1로 보냈다. 다음으로 0을 1로 보내고 1을 0으로 보내고 싶다. 이는 ^을 쓰면 간단하다. 왜냐하면 ^ 테이블을 기억해보면 1과의 연산이 0^1 = 1, 1^1 = 0 이기 때문이다.

### howManyBits

### floatScale2
부동 소수점을 표현하는 uf가 주어졌을 때, 이를 2배해서 반환하는 함수를 만들어야 한다. 부동 소수점을 기억해보면 첫 번째, 비트가 부호를 의미하고, 그 다음 8개가 exp를, 마지막 23개가 frac을 표현하는데 쓰인다. 이들은 exp의 값에 따라서 세 가지 해석법을 가진다.

첫 번째로 exp가 0도 0xFF도 아닌 경우다. 이 경우 $(-1)^s * M * 2^E$로 표현되는 수를 나타내는데, $E = exp - Bias로$ 표현한다. 이때, Bias는 $2^(k-1)-1$이다. 그리고 M은 $1 + frac$인데 frac의 비트는 소수점 아래의 수들을 표현하는데 사용된다. 만약 이 상황에서 값을 2배로 해주려면 exp를 1을 더해주면 된다.

두 번째로 exp가 0인 경우다. 이 경우 $E = 1 - Bias$이고 $M = frac$이 된다. 이때, 수가 2배가 되면 frac이 두 배가 되는 것이다. 즉 왼쪽으로 1칸 밀어주거나, 두 번 더하면 된다.

마지막으로 exp가 0xFF인 경우다. 이 때는 수가 무한대를 표현하기 때문에 수를 바꿀 필요가 없다. 또한 이 경우 frac이 0인 경우는 무한대이고, 나머지는 Nan으로 표현된다. 문제에서는 Nan인 경우 수를 그대로 반환하라고 했으므로, 이 경우에는 무조건 수를 그대로 반환하면 된다.

문제를 푸는 법은 간단하다. exp와 frac의 비트를 구할 수 있는 비트를 만들어서 이 둘을 구해준다. 그리고 exp의 값에 따라서 3경우를 if-else로 구현해주면 된다.

```
unsigned floatScale2(unsigned uf) {
  unsigned expBits = 0xFF << 23;
  unsigned fracBits = (((0x7F << 8) + 0xFF) << 8) + 0xFF;
  unsigned exp = (uf & expBits) >> 23;
  unsigned frac = (uf & fracBits);
  if(exp == 0) {
    uf += frac;
  } else if(exp == 0xFF) {
    return uf;
  } else {
    uf += (0x01 << 23);
  }
  return uf;
}
```

### floatFloat2Int
이번에는 부동 소수점 표기법을 정수로 바꿔줘야 한다. 이때 정수로 표현할 수 없는 범위는 0x80000000을 반환한다. 이 문제도 이전처럼 exp에 따라 3가지 경우의 수가 발생한다. 그 중에 exp가 0인 것은 결과가 0이 나오고, exp가 0xFF인 경우는 0x80000000를 돌려보낸다. 이 둘은 명백히 범위를 벗어나기 때문에 간단하게 해결된다.

문제는 exp가 0도 0xFF도 아닌 경우다. 이 경우에도 정수로 표현할 수 있는 범위를 벗어나는 경우가 있기 때문이다. 2의 지수가 되는 $E = exp -Bias$로, 이때 Bias는 127이다. 만약 E가 31 이상인 경우 값이 너무 크므로 범위를 벗어나고, 반대로 E가 0보다 작으면 값이 너무 작아서 0이 된다. 이 경우의 수를 단순히 코드로 옮기면 `if(exp - 127 >= 31)`와 `if(exp - 127 < 0)`이 되겠다. 그런데 exp의 값에 따라서 -127을 했더니 값이 너무 커지거나 작아지는 경우가 생길 수도 있다. 그러므로 위와 같이 표현하기 보다 `if(exp >= 127 + 31)`과 `if(exp < 127)`로 적어줘야 한다.

마지막으로 정수로 표현할 수 있는 범위 안의 수를 계산해보자. M 표현법에 따라 frac의 제일 앞 자리에 1이 붙어야 한다. 그러므로 `frac += 1 <<23`으로 1을 붙여준다. 그리고 E의 값에 따라 >>을 사용해서 필요한 부분만 남긴다. 예를 들어서 E가 0이라면 frac의 제일 앞 자리만 남고, E가 1이라면 frac의 앞 2자리만 남게 된다. 이를 코드로 옮기면 `frac = frac >> (23 - (exp - 127))`이 된다. 이 경우는 exp - 127을 해도 괜찮은 것이 앞서서 if-else로 exp가 127보다 크고 또 158보다 작아서 값의 범위를 벗어나지 않기 때문이다. 이렇게 하면 frac에 정수값이 들어가게 된다. 마지막으로 부호에 따라서 -frac을 반환하거나 frac을 반환하면 된다.

```
int floatFloat2Int(unsigned uf) {
  unsigned expBits = 0xFF << 23;
  unsigned fracBits = (((0x7F << 8) + 0xFF) << 8) + 0xFF;
  unsigned signBits = 1 << 31;
  unsigned exp = (uf & expBits) >> 23;
  unsigned frac = (uf & fracBits);
  unsigned sign = (uf & signBits);
  if(exp == 0) {
    return 0;
  } else if(exp == 0xFF) {
    return 0x80000000u;
  } else {
    if(exp >= 127 +31) {
      return 0x80000000u;
    } else if(exp < 127) {
      return 0;
    } else {
      frac += 1 << 23;
      frac = frac >> (23 - (exp - 127));
      if(sign) {
        return ~frac + 1;
      } else {
        return frac;
      }
    }
  }
}
```

### floatPower2