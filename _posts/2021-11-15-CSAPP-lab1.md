---
layout: post
title: "CS:APP Lab 1 Datalab"
date: Mon Nov 15 09:37:13 JST 2021
categories: CSAPP
tag: Lab Lab1
toc: true
---
## Lab1 datalab
이 과제에세 제출하면 되는 것은 **bits.c** 파일뿐으로, 13개의 프로그래밍 퍼즐을 포함하고 있다. 각 과제의 뼈대 함수를 정수에 사용하는 기본적인 코드만으로 완성시켜야 하는데, 반복문이나 조건문 같은 것은 사용할 수 없다. 다시 말해 **!, ~, &, ^, |, +, <<, >> 만으로 코드를 완성 시켜야 한다.** 또한 8bits보다 긴 상수를 사용할 수 없다. 자세한 것은 **bits.c** 파일의 주석을 확인하자.

## Evaluation

### Correctness points
각 문제는 난이도별로 1~4점으로 배점되어 있으며 총합 36점이다. 작성한 함수는 **btest**라는 프로그램으로 채점하며 다음 장에 사용법이 있다.

### Performance points
이 과제의 목적은 단순히 문제를 푸는 것 만이 아니라, 최대한 짧고 간단하게 코드를 작성하는 법을 배우는 것이다. 그래서 각 함수마다 사용가능한 연산 횟수를 지정해놓았는데, 이 값은 굉장히 커서 심각하게 비효율적인 경우가 아니라면 통과할 수 있다. 각 조건을 만족하면 2점씩 받는다.

## Autograding your work
-**btest**: bits.c 안의 함수의 정확도를 확인한다. 사용하려면 `make`->`./btest`로 사용할 수 있다. 중요한 것은 bits.c 파일을 수정할 때마다 btest를 다시 작동시켜야 한다. 또한 -f를 사용하면 각 함수별로 체크하는 것도 가능하다. 예를 들어 `./btest -f bitXor`라고 쓰면, bitXor만 체크한다.
-**dlc**: 이 프로그램은 사용하면 안 되는 연산자를 사용하거나, 너무 많은 연산자를 사용하는 등의 결함을 검출해주는 프로그램이다. `./dlc bits.c`로 작동 가능하다. 추가로 -e를 사용해서 각 함수별로 얼마나 많은 연산자를 사용했는지 검사할 수 있다. `./dlc -e bits.c`
-**driver.pl**: btest와 dlc를 사용해서 정확도와 효율성 점수를 채점한다. `./driver.pl`로 사용하면 되며 과제의 채점은 driver.pl로 하면 된다.

## Solve

### bitXor
^를 &와 ~만으로 구현해야 한다. 간단히 ^, &, ~를 테이블로 한 번 표현해보겠다.

| ^ | 1 | 0 |
| - | - | - |
| 1 | 0 | 1 |
| 0 | 1 | 0 |

| & | 1 | 0 |
| - | - | - |
| 1 | 1 | 0 |
| 0 | 0 | 0 |

| ~ | 0 | 1 |
| - | - | - |
|   | 1 | 0 |

여기서 &를 생각해보자. &는 기본적으로 1이 나오는 경우의 수를 줄이는 연산이다. 그렇기 때문에 우리가 ^를 만들고 싶다면 아래 두 결과를 만들어서 &를 사용해줘야 한다.

| a | 1 | 0 |
| - | - | - |
| 1 | 1 | 1 |
| 0 | 1 | 0 |

| b | 1 | 0 |
| - | - | - |
| 1 | 0 | 1 |
| 0 | 1 | 1 |

그렇다면 a와 b는 무엇이 될 수 있을까? 이는 ~이 1과 0을 바꾸는 연산임을 기억하면 쉽게 유추할 수 있다. a와 bㅇ에 ~을 붙이면 아래처럼 된다.

| ~a | 1 | 0 |
| -  | - | - |
| 1  | 0 | 0 |
| 0  | 0 | 1 |

| ~b | 1 | 0 |
| -  | - | - |
| 1  | 1 | 0 |
| 0  | 0 | 0 |

이 둘은 모양만 봐도 &로 쉽게 만들 수 있다. 즉 ~a = (~x & ~y)가 되고, ~b = (x & y)가 된다. 다시 말해서 a = ~(~x & ~y), b = ~ (x & y)고 ^ = a & b = ~(x & y) & ~(~x & ~y)로 계산할 수 있다.

또는 ~x & y와 x & ~y의 결과로도 만들 수 있다. 이 경우도 살펴보자. 우선 두 연산의 결과는 아래와 같다.

| x & ~y | 1 | 0 |
|   -    | - | - |
|   1    | 0 | 1 |
|   0    | 0 | 0 |

| ~x & y | 1 | 0 |
|   -    | - | - |
|   1    | 0 | 0 |
|   0    | 1 | 0 |

그리고 이들에 ~을 붙인 다음 &를 계산하고 다시 ~을 붙이면 된다. 결국 ~(~(x & ~y) & ~(~x & y))도 답이 된다.

결국 내가 찾아낸 답은 2가지로 하나는 ~(x & y) & ~(~x & ~y)이고, 다른 하나는 ~(~(x & ~y) & ~(~x & y))다. 다만 연산자의 수가 전자가 7개 후자가 8개이므로 전자를 사용하는 것이 더 적절하다. 

```
int bitXor(int x, int y) {
  return ~(x & y) & ~(~x & ~y);
}
```

### tmin
2의 보수 중에서 가장 작은 값을 반환하는 함수다. 2의 보수 계산법을 기억해보면 가장 작은 수는 10000...000이다. 그러므로 1000...00을 만들면 된다. 해법은 간단히 1 << 31을 하면 된다. 이는 32bits에만 성립하므로 다른 환경에서도 똑같은 결과가 나오는 것을 고민해봤지만, logical shift 없이는 할 수 있는 방법을 찾지 못했다. 문제의 조건에서 제약이 많아서 아마 이 외의 답은 없을듯 하다.

```
int tmin(void) {
  return 1 << 31;
}
```

### isTmax
x가 들어왔을 때, 2의 보수의 최대값이면 1을 아니라면 0을 반환하면 된다. 사용가능한 연산은 !, ~, &, ^, |, +로 shift를 사용할 수 없다.

당연히 문제를 보는 순간 !(x ^ 0x7FFFFFFF)를 떠올릴 것이다. 하지만 우리는 너무 큰 상수를 사용할 수 없게 되어 있다. 그러므로 저 수를 직접 만들어주거나, 다른 방향으로 접근해야 한다.

우리가 사용할 수 있는 수 중에서 의미있는 것은 사실상 x, 1, 0 뿐이다. 왜냐하면 나머지 2, 3, ... 등은 1의 합으로 표현될 뿐더러 별다른 특성이 없다. 그러므로 x, 1, 0에 위의 연산을 넣었을 경우를 생각해보자.

!는 0인 경우만 1이 되고 나머지 경우는 0이 된다. 우리 문제의 경우 최대값인 경우에만 1이 나오고 나머지 경우는 0이 나와야 한다. 어떤형식으로 사용될지는 아직 모르지만 확실한 것은 !이 사용되어야 한다는 것이다.

~은 간단한 방법으로 수를 확장해준다. ~x(-x-1), ~1(-2), ~0(-1)이 사용가능한데 ~1은 그다지 의미 없는 수이므로, ~로 수를 확장하면 x, 1, 0, -1, ~x를 사용가능하다고 생각해도 된다.

&은 두 수가 1일 경우에만 1이 나온다. &는 결국 두 수가 얼마나 비슷한지와 관련된 연산이다. 그래서 x와 1, 0, -1, ~x를 계산해봐도 그다지 의미있는 수는 나오지 않으므로 &는 사용되지 않는다.

^는 두 수가 완전히 같을 때만 0이 나온다. 우리가 원하는 경우가 하나 뿐인 경우에 사용할 수 있다.

|는 경우의 수를 표현하기 좋아서 예외 사항이 하나 있을 경우 사용가능하다.

다시 돌아가서 우리가 1이 나오길 원하는 수는 Tmax(011...11)이다. Tmax로 생각해볼 수 있는 유의미한 계산은 다음과 같다.

- Tmax + 1 = Tmin
- 2 * Tmax + 2 = 0

그 중에서 아래 식을 사용해서 문제를 풀어봤다.

2 * Tmax + 2는 사실 2 * (Tmax + 1)이고 2를 곱하는 것은 수를 왼쪽으로 한 칸씩 미는 것과 동일하다. 결국 저 식을 해석하자면 Tmax에 1을 더하면 100...00이 되고 이를 왼쪽으로 한 칸 밀어주면 0이 된다는 것이다. 만약 Tmax만 이를 만족한다면 !를 사용해서 굉장히 간단하게 해결할 수 있다. 문제는 -1(111...11) 또한 이를 만족한다는 사실이다. 그 외의 수는 별 문제 없이 만족하므로 저 경우만 해결해주면 된다.

지금까지의 분석 결과를 정리하면, 

- 마지막에 !를 써서 Tmax만 1로 만든다.
- 2 * (Tmax + 1) = 0을 써야한다. shift가 허용되지 않으므로 x + x + 2를 쓴다.
- -1의 경우만 예외 처리해야 하므로 |를 사용한다.

결국 식은 !((x + x + 2) | (x+1))의 형태에서 조금 조정을 해줘야 한다. x가 Tmax라면 !(0 | 1) 이라서 0이 되고, x가 -1이면 !(0 | 0)이라서 0이 된다. 그 외의 숫자는 !(1 | 1)로 0이 된다. 이는 우리가 원하던 결과가 아니니 조금 수정이 필요하다. 그런데 우리가 원하는 결과는 각각 !(0 | 0), !(0 | 1), !(1 | 0)이 되는 경우로 마지막 수가 반대로 되면 된다. 그러므로 !를 사용하면 간단히 해결할 수 있다. 결국 식은 **!((x + x + 2) | !(x + 1))**이 되어야 한다.

### allOddBits
홀수번째에 모두 1이 있는지 확인하는 문제다. 단, least significant digit이 0번째이고, most significant digit이 31번째로 생각해야 한다. 이는 만약 0xAAAAAAAA를 사용할 수 있다면 굉장히 간단하다. 왜냐하면 x & 0xAAAAAAAA으로 짝수번째 자리는 수에 상관 없이 0으로 만들고, 홀수번째가 1인 경우에만 1로 만든다. 그 다음 이를 Xor로 0xAAAAAAAA와 비교해서 수가 같은 경우만 남기면 된다. 왜냐하면 Xor로 수가 같지 않다는 뜻은 홀수 번째에 1이 없다는 의미기 때문이다. 마지막으로 Xor을 사용하면 둘이 같을 경우 0이 나오므로 !를 사용해서 값을 바꿔줘야 한다. 결국 답은 !((x & 0xAAAAAAAA) ^ 0xAAAAAAAA)가 된다.

문제는 상수로 사용할 수 있는 수가 0x00~0xFF가 끝이라는 것이다. 이 보다 큰 수는 상수로 사용할 수 없도록 해놓았으므로 직접 만들어줘야 한다. 이는 <<로 굉장히 간단히 해결할 수 있다. 8칸 밀어주고 원래 수를 더하고, 다시 16칸 밀어주고 원래 수를 더해주면 된다. 결국 정답은 다음처럼 된다.

```
int allOddBits(int x) {
  int AAAAAAAA = 0xAA;
  AAAAAAAA += AAAAAAAA << 8;
  AAAAAAAA += AAAAAAAA << 16;
  return !((x & AAAAAAAA) ^ AAAAAAAA);
}
```

### negate
-x를 구하면 되는 굉장히 간단한 문제다. ~x = -x -1이므로, -x = ~x + 1이 된다.

```
int negate(int x) {
  return ~x + 1;
}
```
