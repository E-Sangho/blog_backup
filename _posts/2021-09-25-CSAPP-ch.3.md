---
layout: post
title: "CSAPP - ch.3"
date: Sat Sep 25 16:51:37 JST 2021
categories: CSAPP
tag:
toc: true
---

Processor[^1]

## Machine-Level Programming

### Why we need to learn about low level language

이번 장에서 기계어(Machine Code)와 어셈블리어(Assembly Language)를 알아보겠다.
이 둘을 알아보기 전에 왜 컴퓨터가 이진법을 사용하는지 간단하게 설명해보겠다.
컴퓨터가 이진법을 사용하는 이유는 트랜지스터로 만들어졌기 때문이다.
트랜지스터는 배선에 전기를 흐르거나 흐르지 않도록 만드는 스위치다.
매우 간단한 장치지만 이를 사용해 전기가 흐르는 상태인 1과 전기가 흐르지 않는 상태 0을 만든다.
그리고 트랜지스터를 조합하면 앞서 배운 AND, OR, XOR 등의 논리 회로를 만들 수 있다.
논리 회로를 사용하면 덧셈과 뺄셈을 구현할 수 있고, 이는 곧 곱하기와 나누기로 이어진다.
결국 트랜지스터 같이 간단한 장치로 계산을 수행할 수 있게 된다.
그리고 트랜지스터로 다양한 계산을 수행하도록 만든 것이 컴퓨터다.
그래서 컴퓨터는 이진법을 읽어서 계산하는 장치라고 말한다.

컴퓨터가 이진법만 읽을 수 있으므로, 초창기 컴퓨터는 0과 1만으로 프로그래밍을 했었다.
이를 두고 기계어(Machine Language)라고 하는데, 기계어를 소개하기 전에 노이만의 일화를 하나 소개하겠다.
노이만에게는 도널드 길리스라는 제자가 있었는데, 길리스는 기계어로 프로그램을 만드는 것에 어려움을 격었다.
그래서 기계어 코드를 좀 더 쉽게 표현하는 어셈블리어를 제작하려고 했었다.
어려운 기계어를 쉽게 표현했으니 칭찬 받을 것으로 기대했겠지만, 노이만은 이를 두고 불 같이 화를 냈다.
노이만은 컴퓨터 같은 비싼 도구로 낭비를 한다고 생각한 것이다.
수학을 좋아했던 노이만 입장에선 0과 1로만 이루어진 기계어는 매우 아름답게 보였을 것이다.
세기의 천재인 노이만이 프로그래밍하는데 충분하다고 했던, 그리고 아름답다고 여겼을 기계어가 어떻게 생겼는지 보자.
아래는 나무위키에서 긁어온 Hello World를 출력하는 기계어라고 한다.

```
b8 21 0a 00 00
a3 0c 10 00 06
b8 6f 72 6c 64
a3 08 10 00 06
b8 6f 2c 20 57
a3 04 10 00 06
b8 48 65 6c 6c
a3 00 10 00 06
b9 00 10 00 06
ba 10 00 00 00
bb 01 00 00 00
b8 04 00 00 00
cd 80
b8 01 00 00 00
cd 80
```

역시 노이만은 천재였던 만큼 범인과는 시야가 달랐던 것 같다.
보통의 프로그래머라면 기계어로 프로그램을 만들려고 시도하지 않을 것이다.
저런 방법으로 코딩하다가 오류라도 나면 눈앞이 캄캄할 것 같다.
그래서 나온 것이 어셈블리어다.

어셈블리어는 기계어와 단 둘뿐인 저급 언어(Low Level Language)다.
여기서 저급 언어라는 것은 언어가 떨어진다는 뜻이 아니라 컴퓨터와 더 가까운 언어라는 뜻이다.
앞서 봤듯이 기계어가 사람이 사용하기엔 지나치게 불편한 언어다.
그래서 이를 보완하기 위해 어셈블리어가 개발되었다.
어셈블리어의 특징은 기계어와 1:1 대응된다는 것이다.
그래서 표현법이 숫자에서 문자로 변경되었을 뿐이라서 성능이 거의 변하지 않는다.
아래는 기계어에 대응되는 어셈블리어다.

```
001000 00001 00000 0000000000001010
addi $0, $1, 10
```

위의 코드가 무엇인지 모르더라도 딱 봐도 가독성이 크게 좋아보인다.
뿐만 아니라 C언어 보다 속도가 훨씬 빨라서 어떤 프로그램이든 성능이 좋다.
그렇기 때문에 과거 컴퓨터의 성능이 좋지 못할 때는 어셈블리어로 코드를 작성해 성능을 끌어 올렸다.
지금까지 설명을 보면 어셈블리어만으로 모든 프로그램을 작성하면 좋아 보이지만 실상은 그렇지 않다.

앞서 기계어가 마치 특정한 언어인것 마냥 설명했지만, 기계어는 언어가 아니다.
정확히 말하자면 제조사별 CPU에 사용하는 명령어 집합이다.
그렇기 때문에 제조사가 바뀌거나 CPU가 바뀐다면 서로 다른 기계어를 사용한다.
과거의 닌텐도 게임이 컴퓨터에서 직접적으로 동작하지 않는 이유도, 서로 다른 CPU를 사용하기 때문이다.

그리고 어셈블리어는 기계어에 1:1 대응되는 언어라고 했다.
각 CPU마다 다른 기계어를 사용한다는 것은 곧 서로 다른 어셈블리어를 쓴다는 것이다.
그래서 내가 A라는 컴퓨터에서 어셈블리어로 코드를 만들었을 때, B라는 컴퓨터에서 동작할지 장담할 수 없다.
뿐만 아니라 어셈블리어는 모든 과정을 일일이 지정해줘야 한다.
현대 프로그램은 너무나 복잡하기 때문에 사소한 것까지 지정해야 하는 어셈블리어는 생산성이 너무 떨어진다.

결국 여러가지 단점 때문에 저급 언어는 파이썬, 자바 같은 고급 언어보다 덜 쓰인다.
그렇다고해서 고급 언어로 작성한 코드의 성능이 크게 떨어지는 것도 아니다.
고급 언어로 작성한 파일을 컴파일러가 알아서 변환해주기 때문이다.
현대 컴파일러 성능은 굉장히 뛰어나다.
그래서 컴파일러가 변환한 코드는 어셈블리 코더가 직접 작성한 것과 거의 유사한 성능을 보인다.
뿐만 아니라 고급 언어로 작성하면 다른 컴퓨터에서 실행이 가능해서 어셈블리어 같은 불편함은 없다.

그럼에도 불구하고 저급 언어를 익히는 것은 중요하다.
컴파일러가 일을 대신해주므로 직접 작성할 필요는 없지만, 읽고 이해할 수 있는 정도의 기술은 필요하기 때문이다.
최종적으로 변환된 어셈블리 코드를 읽어서 최적화 성능을 알 수 있고, 비효율성을 개선할 수 있다.
그리고 바이러스에 대항하려면 어떻게 데이터가 공유, 유지, 접근 되는지 알아야 한다.
그러므로 이번 장에서는 어떻게 어셈블리어가 만들어지고 사용되는지 알아보겠다.

## GCC Compiler

-   ob
    컴퓨터는 기계어 코드(machine code)를 실행한다.
    컴파일러는 기계어 코드를 생성한다.
    GCC C 컴파일러는 기계어 코드를 어셈블리 코드의 형태로 출력을 만들어 인스트럭션을 만든다.[^2]
    GCC는 어셈블러와 링커를 호출하여 어셈블리 코드로부터 실행 가능한 기계어 코드를 생성한다.

C 같은 고급 언어로 프로그램을 작성하면, 기계 수준에서 어떻게 구현되는지 보여주지 않는다.
반면 어셈블리 코드로 프로그램을 만들면 프로그래머가 저급 인스트럭션을 명시해야 한다.
고급 언어가 제공하는 높은 수준의 추상화가 더 생산적이고 안정적이다.
컴파일러의 타입체크 기능은 에러 검출하는데 도움이 된다.
최신 최적화 컴파일러가 만들어 낸 코드는 어셈블리 프로그래머가 손으로 작성한 것과 유사하다.
무엇보다 어셈블리 코드는 컴퓨터 기계에 의존적인 반면, 고급 언어로 작성된 프로그램은 다른 컴퓨터에서 호환가능하다.

컴파일러가 어셈블리 코드를 만들어 내는 일을 하지만, 코드를 읽고 이해할 수 있어야 한다.
컴파일러를 커맨드라인 인자와 함께 호출하면 컴파일러는 어셈블리 코드 형태로 파일을 출력한다.
이 코드를 이해하면 컴파일러의 최적화 성능을 알 수 있고, 코드의 비효율성을 분석할 수 있다.
또한 바이러스가 프로그램을 감염시키는 방법 중 상당수가 프로그램이 런타임 제어 정보를 저장하는 방식과 관련이 있다.
많은 공격들이 정보를ㅁ변경하고, 시스템의 제어권을 획득하기 위해 시스템 프로그램의 약점을 활용한다.
왜 이런 취약성이 발생하고, 어떻게 공격을 막을지 이해하려면 기계수준 표현을 알아야 한다.
결국 프로그래머들이 기계어 코드를 알아야 하는 이유는 **어셈블리어로 직접 프로그램을 작성하는 것이 아니라 컴파일러가 생성한 코드를 이해하기 위해서다.**

이 장에서는 1개의 어셈블리어를 배우고, C 프로그램이 어떻게 기계어 코드 형태로 컴파일 되는지 공부한다.
최적화 컴파일러는 C 코드의 실행 순서를 조정하고, 불필요한 계산을 제거하는 등의 최적화를 진행한다.
그래서 소스 코드와 어셈블리 코드 간의 관계를 이해하는 것은 어려운 일이다.

이 장의 내용은 x86-64에 기초하고 있다.

기술적인 내용은 C, 어셈블리 코드, 기계어 코드 간의 관계에 대한 간략한 설명으로 시작한다.

C 프로그램을 2개의 파일 p1.c와 p2.c에 작성한다고 하자.
유닉스 커맨드 라인으로 다음과 같이 컴파일 한다.
`gcc -Og -o p p1.c p2.c`
위 명령어는 GCC C 컴파일러를 지정한다.
커맨드 라인 옵션으로 -Og를 주면 컴파일러는 본래 C 코드의 전체 구조를 따르는 기계어 코드를 생성하는 최적화 수준을 적용한다.
최적화 수준을 올리면 프로그램은 빨리 동작하지만, 컴파일 시간이 증가하고, 디버깅 도구를 실행하기 어려워질 위험이 있따.
또한 높은 수준의 최적화를 적용하면 코드가 너무 많이 변경되어 본래 코드와 생성된 기계어 코드 간의 관계를 이해하기 어렵다.
그래서 -Og 최적화를 적용하였으며, 최적화를 -01, -02로 높이면 어떤 변화가 생기는지 보자.

gcc명령은 소스 코드를 실행 코드로 변환하기 위해 프로그램들을 호출한다.

1. C 전처리기가 #include로 명시된 파일을 코드에 삽입해주고, #define으로 선언된 매크로를 확장해준다.
2. 컴파일러는 2개의 소스 파일의 어셈블리 버전인 p1.s와 p2.s를 생성한다.
3. 어셈블러는 어셈블리 코드를 바이너리 목적코드인 p1.o와 p2.o로 변환한다.(목적코드는 기계어 코드의 한 유형이다.)
4. 모든 인스트럭션이 바이너리 표현을 포함하고 있지만 전역 값들의 주소는 아직 채워지지 않았따.
5. 링커는 2개의 목적코드 파일을 라이브러리 함수들을 구현한 코드와 함께 합쳐서 최종 실행 파일인 p를 생성한다.(명령줄 디렉티브 -op로 명시하여)
6. 실행코드는 우리가 다룰 2번째 형태의 기계어 코드다.

기계수준 프로그램의 형식과 동작은 인스트럭션 집합구조(Instruction set Architecture) 즉 ISA에 의해 정의된다.
기계수준 프로그램이 사용하는 주소는 가상주소이며, 메모리가 매우 큰 바이트 배열인 것처럼 보이게 하는 메모리 모델을 제공한다.
실제로는 여러 개의 메모리 하드웨어와 운영체데 소프트웨어로 구현되어 있다.

컴파일러는 C의 프로그램을 프로세서가 실행하는 인스트럭션으로 변환하는 대부분의 일을 한다.
어셈블리 코드 표현은 기계어 코드와 매우 유사하다.
주요 특징은 바이너리 기계어 코드 형식과 비교할 때 더 읽기 쉬운 텍스트 형식이라는 것이다.
어셈블리 코드를 이해할 수 있고, 어떻게 그들이 본래 C 코드와 연관되었는지 이해할 수 있는 것이 컴퓨터가 어떻게 프로그램을 실행하는지 이해하는 데 중요한 단계다.

x86-64를 위한 기계어 코드는 본래 C 코드와 상당히 다르다.

-   프로그램 카운터(일반적으로 PC라고 하며, x86-64에서는 %rip라고 한다)는 실행할 다음 인스트럭션의 메모리 주소를 가리킨다.
-   정수 레지스터 파일은 64비트 값을 저장하기 위한 16개의 이름을 붙인 위치를 갖는다. 이들 레지드터는 주소(C언어의 포인터에 해당하는)나 정수 데이터를 저장할 수 있따. 일부 레지스터는 프로그램의 중요한 상태를 추적하는데 사용할 수 있으며, 다른 레지스터들은 함수의 리텁 값뿐만 아니라 프로시저의 지역변수와 인자 같은 임시 값을 저장하는 데 사용한다.
-   조건코드 레지스터들은 가장 최근에 실행한 산술 또는 논리 인스트럭션에 관한 상태 정보를 저장한다. 이들은 if나 while문을 구현할 때 필요한 제어나 조건에 따른 데이터 흐름의 변경을 구현하기 위해 사용된다.
-   벡터 레지스터들의 집합은 하나 이상의 정수나 부동소수점 값들을 각각 저장할 수 있다.

C가 데이터 타입을 선언하고 메모리에 할달할 수 있는 모델을 제공하는 반면, 기계어 코드는 메모리를 단순한 바이트 주소지정이 가능한 큰 배열로 본다.
C에서 배열과 구조체 같은 연결된 데이터 타입들은 기계어 코드에서는 연속적인 바이트들로 표시된다.
스칼라 데이터 타입의 경우에도 어셈블리 코드는 부호형, 비부호형, 다른 타입의 포인터들, 심지어 포인터와 정수형 사이에서도 구분을 하지 않는다.

프로그램 메모리는 프로그램의 실행 기계어 코드, 운영체제를 위한 일부 정보, 프로시저 호출과 리턴을 관리하는 런타임 스택, 사용자에 의해 할당된 메모리 블록들을 포함하고 있다.
언제나 가상주소의 일부 제한된 영역만이 유효하다.

하나의 기계어 인스트럭션은 매우 기초적인 동작만을 수행한다.
예를 들어, 레이스터 들에 저장된 두 수를 더하고, 메모리와 레지스터 간에 데이터를 교환하거나, 새로운 인스트럭션 주소로 조건에 따라 분기하는 등의 동작을 한다.
컴파일러는 일련의 인스트럭션을 생성해서 산술연산식의 계산, 반복문, 프로시저 호출과 리턴 등의 프로그램 구문을 구현해야 한다.

다음과 같은 프로시저 정의를 포함하고 있는 C코드 파일을 작성한다고 하자

```
// mstore.c
long mult2(long, long);

void mulstore(long x, long y, long *dest) {
    long t = mult2(x, y);
    *dest = t;
}
```

C 컴파일러가 생성한 어셈블리 코드를 보기 위해 명령줄에서 -S 옵션을 사용할 수 있다.
`gcc -Os -S mstore.c`
이는 GCC로 하여금 컴파일러를 실행하도록 해서 mstore.s를 만들고 더이상 진행하지 않는다.(대개 그 다음에 어셈블러를 호출해서 목적코드 파일을 생성한다.)

```
multsrotre:
    pushq   %rbx
movq    %rdx, %rbx
call    mult2
movq    %rax, (%rbx)
popq    %rbx
ret
```

위 코드의 각 라인은 하나의 기계어 인스트럭션에 대응된다.
예를 들어, pushq 인스트럭션은 레지스터 %rbx가 프로그램 스택에 저장(push)되어야 한다는 것을 의미한다.
지역 변수 이름이나 데이터 타입에 관한 모든 정보는 삭제되었다.

만일 명령어 라인 옵션을 사용한다면 GCC는 코드를 컴파일하고 에셈블할 것이다.

`gcc -Og -c mstore.c`

위는 mstore.o 파일을 생성하는데, 다음과 같은 14바이트 16진수 데이터가 내장되어 있다.

53 38 89 d3 e8 00 00 00 00 48 89 03 5b c3

이것은 위에 나열된 어셈블리 인스트럭션에 대응되는 목적코드다.
결국 컴퓨터로 실행되는 프로그램은 단순히 일련의 인스트럭션을 인코딩한 일련의 바이트다.
컴퓨터는 인스트럭션들이 생성된 소슼 ㅗ드에 대한 정보를 거의 갖고 있지 않다.

기계어 코드 파일의 내용을 조사하려면, 역어셈블러라고 하는 프로그램을 사용한다.
이 프로그램은 기계어 코드로부터 어셈블리어 코드와 유사한 형태를 생성한다.
리눅스 시스템에서 OBJDUPM에 -d 커맨드 라인을 사용하면 이 역할을 수행할 수 있다.

`objdump -d msotre.o`

```
0000000000000000 <multstore>
0: 53               push    %rbx
1: 48 89 d3         mov     %rdx,%rbx
4: e8 00 00 00 00   callq   9 <multstore_0x9>
9: 48 89 03         mov %rax,(%rbx)
c: 5b               pop %rbx
d: c3               retq
```

위의 각 그룹은 하나의 인스트럭션으로 오른쪽에 보여준 어셈블리어와 동일하다.

기계어 코드의 몇몇 특징과 이들의 역어셈블된 표현을 알아보자.

-   x86-64 인스트럭션의 길이는 1~15 바이트다. 인스트럭션 인코딩은 자주 사용되는 인스트럭션과 연산자가 적은 것의 길이를 짧게 하고, 그 반대의 경우 길이를 길게 인코딩한다.
-   인스트럭션은 시작 위치에서부터 바이트를 기계어 인스트럭션으로 유일하게 디코딩한다. 예를 들어 pushq %rbx 인스트럭션만 바이트 값 53으로 시작된다.
-   역어셈블러는 기계어 코드 파일의 바이트 순서로만 어셈블리 코드를 결정한다.
-   역어셈블러는 GCC가 생성한 어셈블리 코드와는 약간 다른 명명법을 인스트럭션에 사용한다. 위의 예제에서 많은 인스트럭션들이 접미어 'q'를 생략하였다. 접미어는 크기를 나타내는 것으로 대부분의 경우 생략할 수 있다. 반대로 역어셈블러는 접미어 'q'를 call과 ret 명령에 붙이는데, 마찬가지로 이도 생략할 수 있다.

실제 실행 가능 코드를 생성하기 위해서 링커는 목적코드에 실행해야 한다.
이 중 1개의 파일은 main 함수를 포함해야 한다.
main.c 파일에 다음 같은 함수가 있다고 하자.

```
#include <stdio.h>

void multstore(long, long, long *);

int main() {
    long d;
    multstore(2, 3, &d);
    printf("2 * 3 --> %ld\n", d);
    return 0;
}
long mult2(long a, long b) {
    long s = a * b;
    return s;
}
```

그리고 실행 가능 프로그램인 prog를 다음처럼 생성한다.

`gcc -Og -o prog main.c mstore.c`

이렇게하면 파일의 크기가 늘어난다.
그 이유는 우리가 제공한 2개의 프로시저 뿐만 아니라 운영체제와 상호작용하기 위한 코드, 그리고 프로그램을 시작하고 종료하기 위한 코드까지 포함하기 때문이다.
파일을 다음처럼 역어셈블해보자.

`odjump -d prog`

```
0000000000400540 <multstore>
400540: 53               push    %rbx
400541: 48 89 d3         mov     %rdx,%rbx
400544: e8 00 00 00 00   callq   9 <multstore_0x9>
400549: 48 89 03         mov %rax,(%rbx)
40054c: 5b               pop %rbx
40054d: c3               retq
40054e: 90               nop
40054f: 90               nop
```

이 코드는 mstore.c를 역어셈블해서 생성한 것과 거의 동일하다.
한 가지 차이점은 왼쪽에 나타낸 주소가 다르다.
두 번째 차이점은 링커가 callq 인스트럭션이 함수 mult2를 호출 할 때 사용해야하는 주소를 채웠다는 점이다.
링커의 한 가지 임무는 함수들을 위한 실행 코드의 위치들과 함수 호출을 일치시키는 것이다.
마지막 차이는 마지막에 추가된 2줄이 있다.
이 2줄의 인스트럭션은 리턴 인스트럭션 이후에 발행하므로 아무런 효과도 없다.
함수를 위한 코드 길이를 16바이트로 늘려서 코드의 다음 블록을 메머리 시스템 성능 면에서 더 잘배치하기 위해 삽입되었다.

GCC가 생성하는 어셈블리 코드는 사람이 읽기 어렵다.
한편으로는 우리가 걱정할 필요 없는 정보를 포함하고 있지만, 다른 한편으로는 프로그램의 동작 방법이나, 프로그램에 대한 설명을 제공하지 않는다.
아래 명령으로 mstore.s를 만든다.

`gcc -Og -S mstore.c`

이 파일의 전체 내용은 다음과 같다.

```
        .file   "010-mstore.c"
        .text
        .globl  multstore
        .type   multstore, @function
multstore:
        pushq   %rbx
        movq    %rdx, %rbx
        call    mult2
        movq    %rax, (%rbx)
        popq    %rbx
        ret
        .size   multstore, .-multstore
        .ident  "GCC: (Ubuntu 4.8.1-2ubuntu1~12.04) 4.8.1"
        .section        .note.GNU-stack,"",@progbits
```

'.'으로 시작하는 모든 라인은 어셈블러와 링커에 지시하기 위한 디렉티브다.
일반적으로 이들은 무시해도 된다.
반면 인스트럭션들이 무엇을 하고, 어떻게 소스 코드와 연관되는지에 대한 설명이 없다.

어셈블리 코드를 보다 깔끔하게 나타내기 위해 대부분의 디렉티브들을 생략하겠지만, 라인 번호와 설명하는 주석들은 포함시킬 것이다.

```
void multstore(long x, long y, long *dest)
x in %rdi, y in %rsi, dest in %rdx

multstore:
pushq   %rbx            Save %rbx
movq    %rdx, %rbx      Copy dest to %rbx
call    mult2           Call mult2(x, y)
movq    %rax, (%rbx)    Store result at *dest
popq    %rbx            Restore %rbx
ret                     Return
```

```
---

[^1]Processor는 "컴퓨터 시스템을 통제하고, 프로그램의 연산을 실행하고 처리하는 장치"를 말한다. 쉽게 말해 CPU를 말한다.
[^2]인스트럭션은 컴퓨터에게 시키는 일의 단위다.
```
