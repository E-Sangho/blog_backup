---
layout: post
title: "CSAPP - ch.3"
date: Sat Sep 25 16:51:37 JST 2021
categories: CSAPP
tag:
toc: true
---

Processor[^1]

## Machine-Level Programming

### Why we need to learn about low level language

이번 장에서 기계어(Machine Code)와 어셈블리어(Assembly Language)를 알아보겠다.
이 둘을 알아보기 전에 왜 컴퓨터가 이진법을 사용하는지 간단하게 설명해보겠다.
컴퓨터가 이진법을 사용하는 이유는 트랜지스터로 만들어졌기 때문이다.
트랜지스터는 배선에 전기를 흐르거나 흐르지 않도록 만드는 스위치다.
매우 간단한 장치지만 이를 사용해 전기가 흐르는 상태인 1과 전기가 흐르지 않는 상태 0을 만든다.
그리고 트랜지스터를 조합하면 앞서 배운 AND, OR, XOR 등의 논리 회로를 만들 수 있다.
논리 회로를 사용하면 덧셈과 뺄셈을 구현할 수 있고, 이는 곧 곱하기와 나누기로 이어진다.
결국 트랜지스터 같이 간단한 장치로 계산을 수행할 수 있게 된다.
그리고 트랜지스터로 다양한 계산을 수행하도록 만든 것이 컴퓨터다.
그래서 컴퓨터는 이진법을 읽어서 계산하는 장치라고 말한다.

컴퓨터가 이진법만 읽을 수 있으므로, 초창기 컴퓨터는 0과 1만으로 프로그래밍을 했었다.
이를 두고 기계어(Machine Language)라고 하는데, 기계어를 소개하기 전에 노이만의 일화를 하나 소개하겠다.
노이만에게는 도널드 길리스라는 제자가 있었는데, 길리스는 기계어로 프로그램을 만드는 것에 어려움을 격었다.
그래서 기계어 코드를 좀 더 쉽게 표현하는 어셈블리어를 제작하려고 했었다.
어려운 기계어를 쉽게 표현했으니 칭찬 받을 것으로 기대했겠지만, 노이만은 이를 두고 불 같이 화를 냈다.
노이만은 컴퓨터 같은 비싼 도구로 낭비를 한다고 생각한 것이다.
수학을 좋아했던 노이만 입장에선 0과 1로만 이루어진 기계어는 매우 아름답게 보였을 것이다.
세기의 천재인 노이만이 프로그래밍하는데 충분하다고 했던, 그리고 아름답다고 여겼을 기계어가 어떻게 생겼는지 보자.
아래는 나무위키에서 긁어온 Hello World를 출력하는 기계어라고 한다.

```
b8 21 0a 00 00
a3 0c 10 00 06
b8 6f 72 6c 64
a3 08 10 00 06
b8 6f 2c 20 57
a3 04 10 00 06
b8 48 65 6c 6c
a3 00 10 00 06
b9 00 10 00 06
ba 10 00 00 00
bb 01 00 00 00
b8 04 00 00 00
cd 80
b8 01 00 00 00
cd 80
```

역시 노이만은 천재였던 만큼 범인과는 시야가 달랐던 것 같다.
보통의 프로그래머라면 기계어로 프로그램을 만들려고 시도하지 않을 것이다.
저런 방법으로 코딩하다가 오류라도 나면 눈앞이 캄캄할 것 같다.
그래서 나온 것이 어셈블리어다.

어셈블리어는 기계어와 단 둘뿐인 저급 언어(Low Level Language)다.
여기서 저급 언어라는 것은 언어가 떨어진다는 뜻이 아니라 컴퓨터와 더 가까운 언어라는 뜻이다.
앞서 봤듯이 기계어가 사람이 사용하기엔 지나치게 불편한 언어다.
그래서 이를 보완하기 위해 어셈블리어가 개발되었다.
어셈블리어의 특징은 기계어와 1:1 대응된다는 것이다.
그래서 표현법이 숫자에서 문자로 변경되었을 뿐이라서 성능이 거의 변하지 않는다.
아래는 기계어에 대응되는 어셈블리어다.

```
001000 00001 00000 0000000000001010
addi $0, $1, 10
```

위의 코드가 무엇인지 모르더라도 딱 봐도 가독성이 크게 좋아보인다.
어셈블리어는 C언어 보다 속도가 훨씬 빨라서 어떤 프로그램이든 성능이 좋다.
그렇기 때문에 과거 컴퓨터의 성능이 좋지 못할 때는 어셈블리어로 코드를 작성해 성능을 끌어 올렸다.
지금까지 설명을 보면 어셈블리어만으로 모든 프로그램을 작성하면 좋아 보이지만 실상은 그렇지 않다.

앞서 기계어가 마치 특정한 언어인것 마냥 설명했지만, 기계어는 언어가 아니다.
정확히 말하자면 제조사별 CPU에 사용하는 명령어 집합이다.
그렇기 때문에 제조사가 바뀌거나 CPU가 바뀐다면 서로 다른 기계어를 사용한다.
닌텐도 게임같이 독자적인 플랫폼 게임이 컴퓨터에서 직접적으로 동작하지 않는 이유도, 서로 다른 CPU를 사용하기 때문이다.

그리고 어셈블리어는 기계어에 1:1 대응되는 언어라고 했다.
각 CPU마다 다른 기계어를 사용한다는 것은 곧 서로 다른 어셈블리어를 쓴다는 것이다.
그래서 내가 A라는 컴퓨터에서 어셈블리어로 코드를 만들었을 때, B라는 컴퓨터에서 동작할지 장담할 수 없다.
뿐만 아니라 어셈블리어는 모든 과정을 일일이 지정해줘야 한다.
현대 프로그램은 너무나 복잡하기 때문에 사소한 것까지 지정해야 하는 어셈블리어는 생산성이 너무 떨어진다.

결국 여러가지 단점 때문에 저급 언어는 파이썬, 자바 같은 고급 언어보다 덜 쓰인다.
그렇다고해서 고급 언어로 작성한 코드의 성능이 크게 떨어지는 것도 아니다.
고급 언어로 작성한 파일을 컴파일러가 알아서 변환해주기 때문이다.
현대 컴파일러 성능은 굉장히 뛰어나다.
그래서 컴파일러가 변환한 코드는 어셈블리 코더가 직접 작성한 것과 거의 유사한 성능을 보인다.
뿐만 아니라 고급 언어로 작성하면 다른 컴퓨터에서 실행이 가능해서 어셈블리어 같은 불편함은 없다.

그럼에도 불구하고 저급 언어를 익히는 것은 중요하다.
컴파일러가 일을 대신해주므로 직접 작성할 필요는 없지만, **컴파일러가 만든 코드를 읽고 이해할 수 있는 정도의 기술**은 필요하기 때문이다.
최종적으로 변환된 어셈블리 코드를 읽어서 최적화 성능을 알 수 있고, 비효율성을 개선할 수 있다.
그리고 바이러스에 대항하려면 어떻게 데이터가 공유, 유지, 접근 되는지 알아야 한다.
그러므로 이번 장에서는 어떻게 어셈블리어가 만들어지고 사용되는지 알아보겠다.

## GCC Compiler

컴파일러는 어떤 언어로 작성된 코드를 다른 언어로 바꿔주는 것을 말한다.
일반적으로 컴파일러는 고급 언어로 작성된 프로그램을 저급 언어로 번역해 실행 프로그램을 만들어준다.
이때 원본 파일을 Source Code라고 하고 생성되는 파일을 Object Code라고 한다.

우리는 C언어를 컴파일하기 위해서 GCC 컴파일러를 사용한다.
별도로 설치할 필요없이 리눅스 계열이라면 자동으로 설치되어 있다.
컴파일 과정은 다음과 같다.

helloword.c -> [Preprocessor] -> helloword.i -> [Compiler] -> helloworld.s -> [Assembler] -> helloworld.o -> [Linker] -> helloworld

-   Preprocessor(전처리기): #으로 시작하는 지시문을 처리해준다. #include 구문에는 헤더 파일을 삽입해주고, #define의 문자와 같은 문자열을 그 내용으로 치환해준다.
-   Compiler: 고급 언어 소스 코드 파일(\*.i)을 어셈블리어 파일(\*.s)로 변환한다.
-   Assembler: 어셈블리어(\*.s)를 목적 파일(.o)로 변환한다.
-   Linker: 생성된 목적 파일을 묶어서 실행 파일을 만든다.

GCC C 컴파일러는 기계어 코드를 어셈블리 코드의 형태로 출력을 만들어 인스트럭션을 만든다.[^2]
그 다음 GCC는 어셈블러와 링커를 호출하여 어셈블리 코드로부터 실행 가능한 기계어 코드를 생성한다.

## Incoding

C 프로그램을 2개의 파일 p1.c와 p2.c에 작성한다고 하자.
유닉스 커맨드 라인으로 다음과 같이 컴파일 한다.
`gcc -Og -o p p1.c p2.c`
위 명령어는 GCC C 컴파일러를 지정한다.
컴파일러는 효율을 위해 순서를 바꾸거나 계산 방법을 바꾼다.
그래서 결과물을 보면 원래의 코드와 크게 달라져서 분석하기 어렵다.
GCC는 커맨드 라인 옵션으로 -Og를 주면, 원본 C 코드 구조 대로 기계어로 바꾼다.
그래서 -Og 최적화를 적용하였다.
실제로는 최적화를 -01, -02로 높여야 프로그램의 성능이 좋아진다.

gcc명령은 소스 코드를 실행 코드로 변환하기 위해 프로그램들을 호출한다.

1. C 전처리기가 #include로 명시된 파일을 코드에 삽입해주고, #define으로 선언된 매크로를 확장해준다.
2. 컴파일러는 2개의 소스 파일의 어셈블리 버전인 p1.s와 p2.s를 생성한다.
3. 어셈블러는 어셈블리 코드를 바이너리 목적코드인 p1.o와 p2.o로 변환한다.(목적코드는 기계어 코드의 한 유형이다.)
4. 링커는 2개의 목적코드 파일을 라이브러리 함수들을 구현한 코드와 함께 합쳐서 최종 실행 파일인 p를 생성한다.(명령줄 디렉티브 -op로 명시하여)

기계수준 프로그램의 형식과 동작은 인스트럭션 집합구조(Instruction set Architecture) 즉 ISA에 의해 정의된다.
기계수준 프로그램이 사용하는 주소는 가상주소이며, 메모리가 매우 큰 바이트 배열인 것처럼 보이게 하는 메모리 모델을 제공한다.
실제로는 여러 개의 메모리 하드웨어와 운영체제 소프트웨어로 구현되어 있다.

x86-64를 위한 기계어 코드는 본래 C 코드와 상당히 다르다.

-   프로그램 카운터(일반적으로 PC라고 하며, x86-64에서는 %rip라고 한다)는 실행할 다음 인스트럭션의 메모리 주소를 가리킨다.
-   정수 레지스터 파일은 64비트 값을 저장하기 위한 16개의 이름을 붙인 위치를 갖는다. 이들 레지스터는 주소(C언어의 포인터에 해당하는)나 정수 데이터를 저장할 수 있다. 일부 레지스터는 프로그램의 중요한 상태를 추적하는데 사용할 수 있으며, 다른 레지스터들은 함수의 리텁 값뿐만 아니라 프로시저의 지역변수와 인자 같은 임시 값을 저장하는 데 사용한다.
-   조건코드 레지스터들은 가장 최근에 실행한 산술 또는 논리 인스트럭션에 관한 상태 정보를 저장한다. 이들은 if나 while문을 구현할 때 필요한 제어나 조건에 따른 데이터 흐름의 변경을 구현하기 위해 사용된다.
-   벡터 레지스터들의 집합은 하나 이상의 정수나 부동소수점 값들을 각각 저장할 수 있다.

C가 데이터 타입을 선언하고 메모리에 할달할 수 있는 모델을 제공하는 반면, 기계어 코드는 메모리를 단순한 바이트 주소지정이 가능한 큰 배열로 본다.
C에서 배열과 구조체 같은 연결된 데이터 타입들은 기계어 코드에서는 연속적인 바이트들로 표시된다.
스칼라 데이터 타입의 경우에도 어셈블리 코드는 부호형, 비부호형, 다른 타입의 포인터들, 심지어 포인터와 정수형 사이에서도 구분을 하지 않는다.

프로그램 메모리는 프로그램의 실행 기계어 코드, 운영체제를 위한 일부 정보, 프로시저 호출과 리턴을 관리하는 런타임 스택, 사용자에 의해 할당된 메모리 블록들을 포함하고 있다.
언제나 가상주소의 일부 제한된 영역만이 유효하다.

하나의 기계어 인스트럭션은 매우 기초적인 동작만을 수행한다.
예를 들어, 레이스터 들에 저장된 두 수를 더하고, 메모리와 레지스터 간에 데이터를 교환하거나, 새로운 인스트럭션 주소로 조건에 따라 분기하는 등의 동작을 한다.
컴파일러는 일련의 인스트럭션을 생성해서 산술연산식의 계산, 반복문, 프로시저 호출과 리턴 등의 프로그램 구문을 구현해야 한다.

다음과 같은 프로시저 정의를 포함하고 있는 C코드 파일을 작성한다고 하자

```
// mstore.c
long mult2(long, long);

void mulstore(long x, long y, long *dest) {
    long t = mult2(x, y);
    *dest = t;
}
```

C 컴파일러가 생성한 어셈블리 코드를 보기 위해 명령줄에서 -S 옵션을 사용할 수 있다.
`gcc -Os -S mstore.c`
이는 GCC로 하여금 컴파일러를 실행하도록 해서 mstore.s를 만들고 더이상 진행하지 않는다.(대개 그 다음에 어셈블러를 호출해서 목적코드 파일을 생성한다.)

```
multsrotre:
    pushq   %rbx
movq    %rdx, %rbx
call    mult2
movq    %rax, (%rbx)
popq    %rbx
ret
```

위 코드의 각 라인은 하나의 기계어 인스트럭션에 대응된다.
예를 들어, pushq 인스트럭션은 레지스터 %rbx가 프로그램 스택에 저장(push)되어야 한다는 것을 의미한다.
지역 변수 이름이나 데이터 타입에 관한 모든 정보는 삭제되었다.

만일 명령어 라인 옵션을 사용한다면 GCC는 코드를 컴파일하고 에셈블할 것이다.

`gcc -Og -c mstore.c`

위는 mstore.o 파일을 생성하는데, 다음과 같은 14바이트 16진수 데이터가 내장되어 있다.

53 38 89 d3 e8 00 00 00 00 48 89 03 5b c3

이것은 위에 나열된 어셈블리 인스트럭션에 대응되는 목적코드다.
결국 컴퓨터로 실행되는 프로그램은 단순히 일련의 인스트럭션을 인코딩한 일련의 바이트다.
컴퓨터는 인스트럭션들이 생성된 소스 코드에 대한 정보를 거의 갖고 있지 않다.

기계어 코드 파일의 내용을 조사하려면, 역어셈블러라고 하는 프로그램을 사용한다.
이 프로그램은 기계어 코드로부터 어셈블리어 코드와 유사한 형태를 생성한다.
리눅스 시스템에서 OBJDUPM에 -d 커맨드 라인을 사용하면 이 역할을 수행할 수 있다.

`objdump -d msotre.o`

```
0000000000000000 <multstore>
0: 53               push    %rbx
1: 48 89 d3         mov     %rdx,%rbx
4: e8 00 00 00 00   callq   9 <multstore_0x9>
9: 48 89 03         mov %rax,(%rbx)
c: 5b               pop %rbx
d: c3               retq
```

위의 각 그룹은 하나의 인스트럭션으로 오른쪽에 보여준 어셈블리어와 동일하다.

기계어 코드의 몇몇 특징과 이들의 역어셈블된 표현을 알아보자.

-   x86-64 인스트럭션의 길이는 1~15 바이트다. 인스트럭션 인코딩은 자주 사용되는 인스트럭션과 연산자가 적은 것의 길이를 짧게 하고, 그 반대의 경우 길이를 길게 인코딩한다.
-   인스트럭션은 시작 위치에서부터 바이트를 기계어 인스트럭션으로 유일하게 디코딩한다. 예를 들어 pushq %rbx 인스트럭션만 바이트 값 53으로 시작된다.
-   역어셈블러는 기계어 코드 파일의 바이트 순서로만 어셈블리 코드를 결정한다.
-   역어셈블러는 GCC가 생성한 어셈블리 코드와는 약간 다른 명명법을 인스트럭션에 사용한다. 위의 예제에서 많은 인스트럭션들이 접미어 'q'를 생략하였다. 접미어는 크기를 나타내는 것으로 대부분의 경우 생략할 수 있다. 반대로 역어셈블러는 접미어 'q'를 call과 ret 명령에 붙이는데, 마찬가지로 이도 생략할 수 있다.

실제 실행 가능 코드를 생성하기 위해서 링커는 목적코드에 실행해야 한다.
이 중 1개의 파일은 main 함수를 포함해야 한다.
main.c 파일에 다음 같은 함수가 있다고 하자.

```
#include <stdio.h>

void multstore(long, long, long *);

int main() {
    long d;
    multstore(2, 3, &d);
    printf("2 * 3 --> %ld\n", d);
    return 0;
}
long mult2(long a, long b) {
    long s = a * b;
    return s;
}
```

그리고 실행 가능 프로그램인 prog를 다음처럼 생성한다.

`gcc -Og -o prog main.c mstore.c`

이렇게하면 파일의 크기가 늘어난다.
그 이유는 우리가 제공한 2개의 프로시저 뿐만 아니라 운영체제와 상호작용하기 위한 코드, 그리고 프로그램을 시작하고 종료하기 위한 코드까지 포함하기 때문이다.
파일을 다음처럼 역어셈블해보자.

`odjump -d prog`

```
0000000000400540 <multstore>
400540: 53               push    %rbx
400541: 48 89 d3         mov     %rdx,%rbx
400544: e8 00 00 00 00   callq   9 <multstore_0x9>
400549: 48 89 03         mov %rax,(%rbx)
40054c: 5b               pop %rbx
40054d: c3               retq
40054e: 90               nop
40054f: 90               nop
```

이 코드는 mstore.c를 역어셈블해서 생성한 것과 거의 동일하다.
한 가지 차이점은 왼쪽에 나타낸 주소가 다르다.
두 번째 차이점은 링커가 callq 인스트럭션이 함수 mult2를 호출 할 때 사용해야하는 주소를 채웠다는 점이다.
링커의 한 가지 임무는 함수들을 위한 실행 코드의 위치들과 함수 호출을 일치시키는 것이다.
마지막 차이는 마지막에 추가된 2줄이 있다.
이 2줄의 인스트럭션은 리턴 인스트럭션 이후에 발행하므로 아무런 효과도 없다.
함수를 위한 코드 길이를 16바이트로 늘려서 코드의 다음 블록을 메머리 시스템 성능 면에서 더 잘배치하기 위해 삽입되었다.

GCC가 생성하는 어셈블리 코드는 사람이 읽기 어렵다.
한편으로는 우리가 걱정할 필요 없는 정보를 포함하고 있지만, 다른 한편으로는 프로그램의 동작 방법이나, 프로그램에 대한 설명을 제공하지 않는다.
아래 명령으로 mstore.s를 만든다.

`gcc -Og -S mstore.c`

이 파일의 전체 내용은 다음과 같다.

```
        .file   "010-mstore.c"
        .text
        .globl  multstore
        .type   multstore, @function
multstore:
        pushq   %rbx
        movq    %rdx, %rbx
        call    mult2
        movq    %rax, (%rbx)
        popq    %rbx
        ret
        .size   multstore, .-multstore
        .ident  "GCC: (Ubuntu 4.8.1-2ubuntu1~12.04) 4.8.1"
        .section        .note.GNU-stack,"",@progbits
```

'.'으로 시작하는 모든 라인은 어셈블러와 링커에 지시하기 위한 디렉티브다.
일반적으로 이들은 무시해도 된다.
반면 인스트럭션들이 무엇을 하고, 어떻게 소스 코드와 연관되는지에 대한 설명이 없다.

어셈블리 코드를 보다 깔끔하게 나타내기 위해 대부분의 디렉티브들을 생략하겠지만, 라인 번호와 설명하는 주석들은 포함시킬 것이다.
위 예제의 주석 있는 버전은 아래와 같다.

```
void multstore(long x, long y, long *dest)
x in %rdi, y in %rsi, dest in %rdx

multstore:
    pushq   %rbx            Save %rbx
    movq    %rdx, %rbx      Copy dest to %rbx
    call    mult2           Call mult2(x, y)
    movq    %rax, (%rbx)    Store result at *dest
    popq    %rbx            Restore %rbx
    ret                     Return
```

## Data Formats

인텔 프로세서는 16비트 구조를 사용하다가 32비트로 확장했다.
그래서 인텔은 16비트 데이터 타입을 기본으로 사용해서 "word"라고 말한다.
여기서 확장해서 32비트는 "double words", 64비트는 "quad words"라고 한다.
이를 가지고 C의 데이터 타입에 따라 x86-64 표현법을 알아보자.
int는 32비트이므로 double words가 되고, 포인터는 64비트이므로 quad words가 된다.
이와 같은 방법으로 데이터의 타입에 따라 형식이 바뀌게 된다.

인텔 데이터 형식을 알아본 이유는 어셈블리 코드인스트럭션은 피연산자의 크기를 표현하는 접미어가 있기 때문이다.
movb는 Byte 이동, movw는 Word 이동, movl는 Double word 이동, movq는 Quad word 이동이다.
이 중 "l"이 Doble word로 사용되는데 그 이유는 32비트가 "long word"로 간주되기 때문이다.
아래는 각 데이터 타입에 따른 인텔 데이터 타입이다.

| C       | Intel data type       | Assembly-code-suffix | size |
| ------- | --------------------- | -------------------- | ---- |
| char    | Byte                  | b                    | 1    |
| short   | Word                  | w                    | 2    |
| int     | Double word           | l                    | 4    |
| long    | Quad word             | q                    | 8    |
| char \* | Quad word             | q                    | 8    |
| float   | Single precision word | s                    | 4    |
| double  | Double precision      | l                    | 8    |

## Accesing Information

x86-64 CPU는 64비트 값을 저장할 수 있는 16개의 레지스터[^3]가 있다.
초창기 8086에는 %ax에서 %sp까지 16비트 레지스터가 8개 있었다.
각 레지스터마다 목적이 달랐기 때문에, 사용방법에 따라 이름을 붙였다.
그리고 레지스터가 32비트로 확장되면서 %eax에서 %esp로 이름을 붙였다.
다시 64비트인 x86-64로 확장하면서 이름을 %rax에서 %rsp로 바꿨다.
그리고 레지스터를 8개 추가하면서 이들을 %r8에서 %r15로 이름을 붙였다.
아래는 16개의 레지스터를 비트에 따라 이름을 적은 것이다.

| 63   | 31   | 15   | 7    | 0             |
| ---- | ---- | ---- | ---- | ------------- |
| %rax | %eax | %ax  | %al  | Return Value  |
| %rbx | %ebx | %bx  | %bl  | Callee saved  |
| %rcx | %ecx | %cx  | %cl  | 4th argument  |
| %rdx | %edx | %dx  | %dl  | 3rd argument  |
| %rsi | %esi | %si  | %sil | 2nd argument  |
| %rdi | %edi | %di  | %dil | 1st argument  |
| %rbp | %ebp | %bp  | %bpl | Callee saved  |
| %rsp | %esp | %sp  | %spl | Stack pointer |
| %r8  | %r8  | %r8  | %r8  | 5th argument  |
| %r9  | %r9  | %r9  | %r9  | 6th argument  |
| %r10 | %r10 | %r10 | %r10 | Caller saved  |
| %r11 | %r11 | %r11 | %r11 | Caller saved  |
| %r12 | %r12 | %r12 | %r12 | Callee saved  |
| %r13 | %r13 | %r13 | %r13 | Callee saved  |
| %r14 | %r14 | %r14 | %r14 | Callee saved  |
| %r15 | %r15 | %r15 | %r15 | Callee saved  |

표의 최우측을 보면 각 레지스터마다 다른 목적으로 사용됨을 알 수 있다.
이 중 스택 포인터 %rsp는 런타임 스택의 가장 끝 부분을 표현하기 위해 사용된다.

### Operand Specifiers

대부분의 인스트럭션은 하나 이상의 피연산자를 써서 연산을 수행할 값과 결과를 저장할 위치를 정한다.
이때 값은 상수를 사용하거나, 레지스터 또는 메모리에서 읽어들인다.
그리고 결과값은 레지스터나 메모리에 저장한다.

피연산자는 3가지 종류가 있다.
첫 번째는 **immediate는 상수값**을 말한다.
어셈브리 코드에서 $ 다음에 수가 오는 것으로 사용할 수 있다.
예를 들어서 $-577, $0x1F로 사용하면 된다.
인스트럭션에 따라 immediate 값의 범위가 달라지는데, 어셈블러는 알아서 가장 효율적인 인코딩 방법을 사용한다.

두 번째 타입은 register로 레지스터의 내용을 나타낸다.
표기법으로 ${r_a}$를 사용하며, 레지스터를 배열 R로 생각해서 $R[r_a]$로 값을 지정한다.

세 번째 타입은 memory로 메모리 주소를 사용해서 메모리 값을 사용한다.
메모리를 거대한 바이트 배열로 생각해서 $M_b[Addr]$과 같이 표시할 수 있다.
이는 메모리 주소 Addr로 부터 b 바이트를 참조한다는 의미다.
아래 표는 메모리 타입에 따른 형태와 연산값을 적은 것이다.

| Type      | Form             | Operand value                      | Name                |
| --------- | ---------------- | ---------------------------------- | ------------------- |
| Immediate | $Imm             | Imm                                | Immediate           |
| Register  | $r_a$            | $R[r_a]$                           | Register            |
| Memory    | $Imm$            | $M[Imm]$                           | Absolute            |
| Memory    | $(r_a)$          | $M[R[r_a]]$                        | Indirect            |
| Memory    | $Imm(r_b)$       | $M[Imm + R[r_b]]$                  | Base + displacement |
| Memory    | $(r_b,r_i)$      | $M[R[r_b]+R[r_i]]$                 | Indexed             |
| Memory    | $Imm(r_b,r_i)$   | $M[Imm + R[r_b] + R[r_i]]$         | Indexed             |
| Memory    | $(,r_i,s)$       | $M[R[r_i] \cdot s$                 | Scaled indexed      |
| Memory    | $Imm(,r_i,s)$    | $M[Imm + R[r_i] \cdot s$           | Scaled indexed      |
| Memory    | $(r_b,r_i,s)$    | $M[R[r_b] + R[r_i] \cdot s$        | Scaled indexed      |
| Memory    | $Imm(r_b,r_i,s)$ | $M[Imm + R[r_b] + R[r_i] \cdot s]$ | Scaled indexed      |

여기서 핵심은 상수는 $를 사용하고, 레지스터는 %rax 같은 레지스터의 값을 가리킨다.
그리고 $를 사용하지 않은 상수나, 괄호를 사용하면 메모리를 가리킨다.

> Practice Problem 3.1  
> 다음 값이 메모리 주소와 레지스터에 저장되어 있다.
> | Address | Value | Register | Value |
> | - | - | - | - |
> |0x100 | 0xFF | %rax | 0x100 |
> | 0x104 | 0xAB | %rcx | 0x1 |
> | 0x108 | 0x13 | %rdx | 0x3 |
> | 0x10c | 0x11 |
>
> 위의 값으로 아래 표를 완성하시오.  
> | Operand | Value | Comment |
> | -------------- | ----- | ------------------- |
> | %rax | 0x100 | Register |
> | 0x104 | 0xAB | Absolute address |
> | $0x108 | 0x108 | Immediate |
> | (%rax) | 0xFF | Indirect |
> | 4(%rax) | 0xAB | Base + displacement |
> | 9(%rax,%rdx) | 0x11 | Indexed |
> | 260(%rcx,%rdx) | 0x13 | Indexed |
> | 0xFC(,%rcx,4) | 0xFF | Scaled Indexed |
> | (%rax,%rdx,4) | 0x11 | Scaled indexed |

### Data Movement Instructions

가장 많이 쓰이는 인스트럭션은 데이터를 다른 위치로 복사하는 명령이다.
데이터 이동 인스트럭션 중 가장 간단한 것은 -MOV 클래스다.
-MOV는 데이터에 어떠한 변화도 주지 않고 복사한다.
-MOV 클래스는 movb, movw, movl, movq로 4개의 인스트럭션으로 구성된다.
이들의 효과는 동일하지만 실행되는 데이터의 크기만 다를 뿐이다.
이전에 살펴봤듯이 word의 크기에 따라서 b, w, l, q를 사용한다.

| Instruction | Effect      | Description             |
| ----------- | ----------- | ----------------------- |
| MOV S,D     | $S \rarr D$ | Move                    |
| movb        |             | Move byte               |
| movw        |             | Move word               |
| movl        |             | Move double word        |
| movq        |             | Move quad word          |
| movabsq I,R | $I \rarr R$ | Move absolute quad word |

MOV는 *MOV S,D*로 작성한다.
이는 S(source operand)에서 D(destination operand)로 저장값을 이동한다는 의미다.
여기서 source operand의 뜻을 해석하자면, source는 원본이란 뜻이고, operand는 피연산자라는 뜻이다.
그래서 S는 연산이 적용되는 원본 저장 값이라는 뜻이다.
비슷하게 destination operand는 목적 피연산자가 된다.

데이터를 옮기는 원본 피연산자는 상수, 레지스터 저장 값, 메모리 저장 값을 사용한다.
데이터를 옮겨 받는 목적 피연산자는 레지스터, 또는 메모리 주소를 지정한다.
이는 당연한 것이 데이터를 저장할 수 있는 곳이 레지스터나 메모리 뿐이므로 D에는 레지스터나 메모리 주소가 들어가야 한다.
반면 S는 상수값을 사용할 수 있게 해야 저장되지 않은 값도 만들 수 있게 된다.

다만 MOV가 완전히 자유로운 것은 아니다.
x86-64는 데이터 이동 인스트럭션에서 두개의 피연산자가 모두 메모리 위치에 올 수 없도록 제한한다.
그래서 하나의 메모리에서 다른 메모리 위치로 데이터를 옮기려면, 2개의 인스트럭션을 사용해서 레지스터를 한 번 거쳐서 옮겨야 한다.
대부분의 MOV 인스트럭션은 대상 레지스터나 메모리만 수정한다.
유일한 예외는 movl이 레지스터를 목적지로 쓰는 경우다.
이 경우 레지스터 상위 4바이트도 0으로 설정한다.
이는 레지스터를 위한 32비트 값을 생성하는 인스트럭션은 상위 바이트 또한 0으로 설정하도록하는 관습 때문에 생긴 것이다.

아래의 MOV 인스트럭션 예제는 5가지 가능한 조합을 보여준다.
원본 피연산자가 먼저 나오고 다음에 목적 피연산자가 나온다.

```
movl $0x4050,%eax     Immediate--Register,    4 bytes
movw %bp,%sp          Register--Register,     2 bytes
movb (%rdi,%rcx),%al  Memory--Register,       1 byte
movb $-17,(%esp)      Immediate--Memory,      1 byte
movq %rax,-12(%rbp)   Register--Memory,       8 bytes
```

작은 원본 값을 더 큰 목적지로 복사할 때 사용하기 위한 명령도 존재한다.
아래의 두 인스트럭션은 모두 레지스터나 메모리에 저장되어 있는 원본을 레지스터 목적지로 복사한다.

| Instruction | Effect                  | Description                            |
| ----------- | ----------------------- | -------------------------------------- |
| MOVZ S, R   | $ZeroExtend(S) \rarr R$ | Move with zero extension               |
| movzbw      |                         | Move zero-extended byte to word        |
| movzbl      |                         | Move zero-extended byte to double word |
| movzwl      |                         | Move zero-extended word to double word |
| movzbq      |                         | Move zero-extended byte to quad word   |
| movzwq      |                         | Move zero-extended word to quad word   |

| Instruction | Effect                          | Description                                 |
| ----------- | ------------------------------- | ------------------------------------------- |
| MOVS S, R   | $SignExtend(S) \rarr R$         | Move with sign extension                    |
| movsbw      |                                 | Move sign-extended byte to word             |
| movsbl      |                                 | Move sign-extended byte to double word      |
| movswl      |                                 | Move sign-extended word to double word      |
| movsbq      |                                 | Move sign-extended byte to quad word        |
| movswq      |                                 | Move sign-extended word to quad word        |
| movslq      |                                 | Move sign-extended double word to quad word |
| cltq        | $SignExtend(\%eax) \rarr \$rax$ | Sign-extend %eax to %rax                    |

MOVZ 클래스 인스트럭션은 목적지의 남은 바이트를 모두 0으로 채운다.
MOVS 클래스는 원본 피연산자의 가장 중요한 비트로 남은 바이트를 채운다.
이 둘은 이전장에서 다뤘던 shift와 비슷한 내용이다.
경우에 따라 0으로 채워야 하는 경우 MOVZ를 사용하고, 제일 중요한 비트로 채워야 하는 경우 MOVS를 쓴다.

두 클래스 모두 마지막 2개의 글자가 문자의 크기를 나타낸다.
첫 번째 글자가 원본의 크기고, 두 번째가 목적지의 크기를 나타낸다.

여기서 MOVZ에 movzlq가 없다.
이는 다시 말해 4바이트 원본을 8바이트로 옮길 때, 0으로 채우는 명령이 없다는 의미다.
movzlq가 존재하진 않지만, movl 인스트럭션으로 구현된다.
이는 movl로 옮기면 자동으로 상위 4바이트를 0으로 채우기 때문이다.

MOVS 클래스를 보면 cltq 인스트럭션이 있다.
이 인스트력션은 피연산자가 없다.
그 이유는 항상 레지스터 %eax를 원본으로 하고, %rax를 목적지로 하기 때문이다.
이는 movslq %eax, %rax와 동일한 효과를 내지만, 좀 더 압축된 인코딩을 한다.

> Practice Problem 3.2  
> 다음 어셈블리어를 보고 피연산자에 적절한 인스트럭션을 적으시오.  
> movl $eax, (%rsp)  
> movw (%rax), %dx  
> movb $0xFF, %bl  
> movb (%rsp,%rdx,4), %dl  
> movq (%rdx), %rax  
> movw %dx, (%rax)

> Practice Problem 3.3  
> 다음 코드는 각각 에러 메세지를 출력한다.
> 각 줄마다 어떤점이 잘못되었는지 적으시오.  
> movb $0xF, (%ebx)  
> movl %rax, (%rsp)  
> movw (%rax),4(%rsp)  
> movb %al,%sl  
> movq %rax,$0x123  
> movl %eax,%rdx  
> movb %si, 8(%rbp)
>
> 풀이)
> %ebx는 32비트 레지스터다. 그러므로 (%ebx)는 32비트 메모리 주소를 가리킨다. 그런데 movb는 8비트에 사용할 수 있으므로 틀렸다.
> movl은 double word에 사용해야 하는데 quad word에 사용했다.
> MOV의 두 피연산자가 메모리 주소가 될 수 없다.
> %sl이라는 레지스터는 없다.
> 목적 피연산자에 immediate를 사용할 수 없다.
> 목적 피연산자가 quad word인데 movl을 사용했다.
> %si는 word이므로 movw를 사용해야 한다.

```
Remark

다음은 데이터 이동 인스트럭션이 어떻게 목적지의 바이트를 변경하는지 보여준다. 이때 movb, movsbq, movzbq를 보면 차이가 존재한다. movb는 해당 바이트만 변경하고, movsbq는 제일 중요한 비트를 확장해서 채운다. 그리고 movzbq는 나머지 비트를 모두 0으로 채운다.
movabsq $0x0011223344556677, %rax   // %rax = 0011223344556677
movb $0xAA, %dl                     // %dl = AA
movb %dl,%al                        // %rax = 00112233445566AA
movsbq %dl,%rax                     // %rax = FFFFFFFFFFFFFFAA
movzbq %dl,%rax                     // %rax = 00000000000000AA
```

### Data Movement Example

아래는 데이터 이동 인스트럭션의 예제 코드다.

```
(a) C code
long exchange(long *xp, long y)
{
    long x = *xp;
    *xp = y;
    return x;
}

(b) Assembly code
    // long exchange(long *xp, long y)
    // xp in %rdi, y in %rsi
exchange:
    movq    (%rdi), %rax    // Get x at xp. Set as return value.
    movq    %rsi, (%rdi)    // Store y at xp.
    ret                    //  Return.
```

위 코드를 프로시저가 실행하면, xp와 y는 각각 레지스터 %rdi와 %rsi에 저장된다.
그리고 %rdi에 있는 xp의 값을 %rax에 저장한다.
이때 %rax에 저장하는 이유는 %rax가 리턴값을 저장하기 때문이다.
(a)코드를 보면 `x = *xp`로 x 값을 정하고 `return x`를 반환하기 때문에 xp의 값은 %rax에 저장되어야 한다.
다음으로 y 값이 %rsi에 들어 있으므로 `*xp = y`를 구현하려면, %rsi를 (%rdi)로 옮겨줘야 한다.

위 코드에서 핵심은 2가지다.
첫 번째는 C에서 *포인터*는 에섬블리어에서 단순한 주소다.
포인터를 레지스터에 복사하고, 그 레지스터를 메모리 참조에 사용해서 포인터의 값을 사용한다.
두 번째는 x같은 지역 변수는 레지스터에 저장된다는 것이다.
이는 레지스터가 메모리보다 접근하는 속도가 더 빠르기 때문이다.

> Practice Problem 3.4  
> 두 변수 sp와 dp가 아래와 같은 타입으로 선언되어 있다.
>
> src_t *sp;  
> dest_t *dp;
>
> 여기서 src_t와 dest_t는 typedef로 선언된 타입이다.  
> 우리는 데이터 이동 인스트럭션을 사용해서 아래 연산을 만들려고 한다.  
> *dp = (dest_t) *sp;  
> sp와 dp값은 각각 레지스터 %rdi와 %rsi에 저장되어 있다.  
> 이때 아래의 표를 완성하시오.
> C언어에서 크기를 바꾸고 부호를 변경하는 경우, 크키를 먼저 변경하고 부호를 변경한다.(2.2.6절 참조)
>
> | src_t         | dest_t        | Instruction         |
> | ------------- | ------------- | ------------------- |
> | long          | long          | movq (%rdi), %rax   |
> |               |               | movq %rax, (%rsi)   |
> | char          | int           | movsbl (%rdi), %eax |
> |               |               | movl %eax, (%rsi)   |
> | char          | unsigned      | movsbl (%rdi), %eax |
> |               |               | movl %eax, (%rsi)   |
> | unsigned char | long          | movzbl (%rdi), %eax |
> |               |               | movq %rax, (%rsi)   |
> | int           | char          | movl (%rdi), %eax   |
> |               |               | movb %al, (%rsi)    |
> | unsigned      | unsigned char | movl (%rdi), %eax   |
> |               |               | movb %al, (%rsi)    |
> | char          | short         | movsbw (%rdi), %ax  |
> |               |               | movw %ax, (%rsi)    |
>
> 여기서 char -> unsigned 변환은 사이즈 변환과 부호변화를 둘 다 포함하고 있다.
> 이 경우는 먼저 사이즈를 바꾼 다음 부호 변화를 해야 한다.
> 그래서 char -> int -> unsigned int로 변환해야 한다.
> 그러므로 char -> int인 movsbl이 일어난 다음, int -> unsigned인 movl이 일어나야 한다.

> Practice Problem 3.5  
> void decode1(long *xp, long *yp, long \*zp)  
> 위와 같은 코드가 아래처럼 어셈블리 코드로 컴파일 되었다.
> decode 1:  
>  movq (%rdi), %r8
> movq (%rsi), %rcx
> movq (%rdx), %rax
> movq %r8, (%rsi)  
>  movq %rcx, (%rdx)  
>  movq %rax, (%rdi)  
>  ret
> 매개변수 xp, yp, zp가 각각 %rdi, %rsi, %rdx에 들어 있을다면, 원본 코드를 작성하시오.
>
> void decode1 (long *xp, long *yp, long *zp) {  
> long x = *xp;  
> long y = *yp;  
> long z = *zp;
>
> *yp = x;  
> *zp = y;  
> \*xp = z;  
> }

### Pushing and Popping Stack Data

마지막 데이터 이동은 프로그램 스택에서 데이터를 저장하거나 추출하기 위해 사용한다.
각각 pushq와 popq로 아래 표에 정리했다.

| Instruction | Effect                                            | Description    |
| ----------- | ------------------------------------------------- | -------------- |
| pushq S     | $R[\%rsp]-8 \rarr R[\%rsp]$ $S \rarr M[R[\%rsp]]$ | Push quad word |
| popq D      | $M[R[\%rsp]] \rarr D$ $R[\%rsp]+8 \rarr R[\%rsp]$ | Pop quad word  |

x86-64에서 프로그램 스택은 메모리의 특정 영역에 저장된다.
스택은 자료구조에서 살펴봤듯이 후입선출 구조로 마지막에 추가된 데이터를 top으로 부른다.
그리고 새로운 내용을 추가하는 것이 push, top의 내용을 꺼내는 것을 pop이라고 한다.
이 같은 구조는 배열로 구현될 수 있는데, 배열의 한쪽만 추가하거나 제거한다.

레지스터의 %rsp(Stack pointer)는 스택에서 top의 주소값이 들어있다.
그러므로 스택은 스택 포인터의 값을 기준으로 데이터를 저장하거나 추출한다.
`pusq S`는 1바이트만큼 %rsp의 주소를 감소시키고, S를 해당 주소에 추가한다.
반대로 `popq D`는 top의 내용을 추출하고, 1바이트만큼 주소를 증가시킨다.

아래 표는 pushq와 popq를 실행했을 때 레지스터 값의 변화다.

|      | Initial | pushq %rax | popq %rdx |
| ---- | ------- | ---------- | --------- |
| %rax | 0x123   | 0x123      | 0x123     |
| %rdx | 0       | 0          | 0x123     |
| %rsp | 0x108   | 0x100      | 0x108     |

위를 보면 `pushq %rax`를 했을 때, %rsp의 값이 1바이트 줄어들었다.
그리고 0x123이 0x100에 저장된다.
다음으로 `popq %rdx`를 하면 %rsp의 값이 1바이트 늘어난다.
이때 중요한 것으로 *스택 포인터가 증가했더라도 메모리 0x100의 내용은 그대로 0x123*이다.
0x100의 내용은 다른 내용으로 덮어씌워지기 전에는 0x123의 내용이 그대로 남아 있다.
그렇지만 %rsp의 위치가 바뀜으로 인해 스택의 top의 값이 바뀌는 것이다.

스택은 다른 프로그램 데이터와 동일한 메모리에 저장된다.
그렇기 때문에 프로그램은 메모리 주소를 지정해서 스택 내의 정보를 가져올 수 있다.
예를 들어서 `movq 8(%rsp), %rdx`는 스택의 2번째 값을 %rdx에 넣어준다.

## Arithmetic and Logical Operations

다음은 x86-64의 정수와 논리 연산을 적은 것이다.

| Instruction | Effect               | Description              |
| ----------- | -------------------- | ------------------------ |
| leaq S,D    | $\&S \rarr D$        | Load effective address   |
| INC D       | $D+1 \rarr D$        | Increment                |
| DEC D       | $D-1 \rarr D$        | Decrement                |
| NEG D       | $-D \rarr D$         | Negate                   |
| NOT D       | $~D \rarr D$         | Complement               |
| ADD S,D     | $D+S \rarr D$        | Add                      |
| SUB S,D     | $D-S \rarr D$        | Subtract                 |
| IMUL S,D    | $D*S \rarr D$        | Multiply                 |
| XOR S,D     | $D \wedge S \rarr D$ | Exclusive-or             |
| OR S,D      | $D \| S \rarr D$     | Or                       |
| AND S,D     | $D \& S \rarr D$     | And                      |
| SAL k,D     | $D << k \rarr D$     | Left shift               |
| SHL k,D     | $D << k \rarr D$     | Left shift (same as sal) |
| SAR k,D     | $D >> k \rarr _A D$  | Arithmetic right shift   |
| SHR k,D     | $D >> k \rarr _L D$  | Logical right shift      |

위는 인스트럭션 클래스로 나열한 것이다.
피연산자의 크기에 따라서 뒤에 글자를 추가하면 된다.
예를 들어서 ADD는 addb, addw, addl, addq를 각각 바이트, 워드, 더블워드, 쿼드 워드에 사용한다.
다만 이중에 leaq는 길이에 따라 바뀌지 않는다.

### Load Effective Address

leaq(Load Effective Address)는 주소를 옮기는 인스트럭션이다.
본래 **leaq가 만들어진 이유는 배열에 사용하기 위함**이다.
왜 leaq가 배열에 쓰이기 위해 만들어졌는지는 조금 뒤에 설명하겠다.
우선 leaq를 사용하려면 `leaq &S, D` 형태로 적어야 한다.
여기서 &S를 적은 것은 해당 위치에 주소가 들어가야 하기 때문이다.
그렇기 때문에 앞의 표에서도 S의 주소를 표현하는 &S를 사용해서 주소를 전달하는 것을 표현했다.
이때 주소를 옮겨받는 D에는 레지스터를 사용해야 한다.

leaq를 사용하는 간단한 예시를 하나 보이겠다.
%rbx에 어떤 주소가 있다고 하자.
이 주소를 %rax로 옮겨주려면 `leaq (%rbx), %rax`로 적으면 된다.
그런데 이는 movq를 사용해서 `movq %rbx, %rax`로 적어도 같은 효과를 볼 수 있다.
물론 movq는 leaq와 다르게 S에 상수도 올 수 있고 D에 메모리도 사용할 수 있다.
그렇지만 이런 범위를 제외하고 보면 굳이 leaq를 사용할 이유는 없어보인다.

왜 leaq를 사용하는지 알기 위해 배열을 생각해보자.
C로 코드를 `int y = arr[i];`라고 적었다고 하자.
여기서 %rbx에 arr의 주소가 들어있고, i 값은 %rdx에 있다고 하자.
이를 어셈블리어로 `movq (%rbx, %rdx, 8), %rax`로 적어주면 %rax에 arr[i] 값이 들어간다.
이때 8을 쓴 이유는 i가 1늘어날 때마다 주소가 1바이트 늘어나기 때문이다.

다음으로 배열의 포인터를 사용해보자.
C 코드로 `int *p = &arr[i];`를 생각해보자.
여기서 우리는 주소값이 %rax에 들어가야 한다.
문제는 movq를 사용할 때 괄호를 쓰면 주소 안의 값을 추출한다는 점이다.
그래서 movq로 이 문제를 해결할 수 없고, leaq를 사용해야 한다.
`leaq (%rbx, %rdx, 8), %rax`는 %rax에 &arr[i] 값이 들어간다.

정리하자면 배열의 값을 전달하는 경우는 movq로 해결할 수 있다.
그렇지만 포인터를 사용하는 경우 movq만으로 해결할 수 없다.
그래서 leaq를 사용해서 주소를 옮겨줘야 한다.
결국 둘의 차이는 movq는 내용을 전달하고, leaq는 주소를 전달한다는 것이다.
앞서 `leaq (%rbx) %rax`를 `movq %rbx, %rax`로 사용해도 같은 효과가 나온다고 했다.
이는 결과만 같을 뿐 내용은 전혀 다른 얘기다.
leaq는 %rbx에 들어있는 주소를 전달한 것이고, movq는 %rbx의 내용을 옮겨줬기 때문이다.

leaq를 사용하는 장점은 메모리 참조를 하지 않는다는 점이다.
다시 말해 주소만을 가져올 뿐 안의 내용은 사용하지 않는다.
그래서 포인터 같이 주소만을 다루는 경우에 사용하기 적절하다.

또 다른 장점으로는 간단한 연산을 빠르게 해결할 수 있다는 점이다.
예를 들어 %rdi의 값을 4배로 해야 한다고 하자.
이는 `leaq (%rdi, %rdi, 3), %rax`로 해결할 수 있다.
왜냐하면 %rdi의 값을 주소로 생각해서 계산을 진행할 수 있기 때문이다.
또한 값을 더하는 것도 간단하다.
7을 더하려고 하는 경우 `leaq 7(%rdi), %rax`라고 적어주면 된다.
이 둘을 조합하는 것도 가능한데 `leaq 7(%rdi, %rdi, 4), %rax`는 %rdi의 값을 x라고 할 때, 5x+7을 계산하는데 쓸 수 있다.

연산에 사용하는 경우의 예로 다음의 C코드를 설명해보겠다.

```
long scale(long x, long y, long z) {
    long t = x + 4 * y + 12 * z;
    return t;
}
```

위 코드를 컴파일하면 아래의 leaq 인스트럭션으로 바뀐다.
연산 과정은 각 줄의 오른쪽에 적어놓았다.

```
scale:
  leaq    (%rdi,%rsi,4), %rax   // x + 4*y
  leaq    (%rdx,%rdx,2), %rdx   // z + 2*z = 3*z
  leaq    (%rax,%rdx,4), %rax   //(x+4*y) + 4*(3*z) = x + 4*y + 12*z
  ret
```

> Practice Problem 3.6
> %rbx에 p가 들어있고, %rdx에는 q가 들어 있다고 하자.
> 이때 아래의 테이블을 채우시오.
> | Instruction | Result |
> |-|-|
> |leaq 9(%rdx), %rax|q+9|
> |leaq (%rdx,%rbx), %rax |p+q|
> |leaq (%rdx,%rbx,3), %rax |3p+q|
> |leaq 2(%rbx,%rbx,7), %rax|8p++2|
> |leaq 0xE(,%rdx,3), %rax|3q+14|
> |leaq 6(%rbx,%rdx,7), %rax|p+7q+6|

> Practice Problem 3.7
>
> ```
> short scale3(short x, short y, short z) {
>   short t = 10y + z + y * x  ;
>   return t;
> }
> ```
>
> 위의 코드를 컴파일해서 아래와 같은 결과가 나왔을 때 빈 칸을 채우시오.
>
> ```
> short scale3(short x, short y, short z)
> x in %rdi, y in %rsi, z in %rdx
>
> scale3:
>  leaq (%rsi,%rsi,9), %rbx
>  leaq (%rbx,%rdx), %rbx
>  leaq (%rbx,%rdi,%rsi), %rbx
>  ret
> ```

요약하자면 leaq는 포인터를 다루기 위해 만들어졌다.
그래서 주소값에 연산을 해서 다른 주소값을 만들 수 있다.
이런 특성을 이용해서 간단한 연산을 하는데도 사용할 수 있다.

---

[^1]Processor는 "컴퓨터 시스템을 통제하고, 프로그램의 연산을 실행하고 처리하는 장치"를 말한다. 쉽게 말해 CPU를 말한다.
[^2]인스트럭션은 컴퓨터에게 시키는 일의 단위다.
[^3]CPU가 계산중인 값을 저장하는데 사용하는 데이터 저장 장치다. 그 중에서 범용 레이스터는 데이터와 주소를 모두 저장할 수 있다.
