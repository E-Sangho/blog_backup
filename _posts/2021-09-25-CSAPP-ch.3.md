---
layout: post
title: "CSAPP - ch.3"
date: Sat Sep 25 16:51:37 JST 2021
categories: CSAPP
tag:
toc: true
---

Processor[^1]

# 3. Machine-Level Programming

## 3.1 Why we need to learn about low level language

이번 장에서 기계어(Machine Code)와 어셈블리어(Assembly Language)를 알아보겠다.
이 둘을 알아보기 전에 왜 컴퓨터가 이진법을 사용하는지 간단하게 설명해보겠다.
컴퓨터가 이진법을 사용하는 이유는 트랜지스터로 만들어졌기 때문이다.
트랜지스터는 배선에 전기를 흐르거나 흐르지 않도록 만드는 스위치다.
매우 간단한 장치지만 이를 사용해 전기가 흐르는 상태인 1과 전기가 흐르지 않는 상태 0을 만든다.
그리고 트랜지스터를 조합하면 앞서 배운 AND, OR, XOR 등의 논리 회로를 만들 수 있다.
논리 회로를 사용하면 덧셈과 뺄셈을 구현할 수 있고, 이는 곧 곱하기와 나누기로 이어진다.
결국 트랜지스터 같이 간단한 장치로 계산을 수행할 수 있게 된다.
그리고 트랜지스터로 다양한 계산을 수행하도록 만든 것이 컴퓨터다.
그래서 컴퓨터는 이진법을 읽어서 계산하는 장치라고 말한다.

컴퓨터가 이진법만 읽을 수 있으므로, 초창기 컴퓨터는 0과 1만으로 프로그래밍을 했었다.
이를 두고 기계어(Machine Language)라고 하는데, 기계어를 소개하기 전에 노이만의 일화를 하나 소개하겠다.
노이만에게는 도널드 길리스라는 제자가 있었는데, 길리스는 기계어로 프로그램을 만드는 것에 어려움을 격었다.
그래서 기계어 코드를 좀 더 쉽게 표현하는 어셈블리어를 제작하려고 했었다.
어려운 기계어를 쉽게 표현했으니 칭찬 받을 것으로 기대했겠지만, 노이만은 이를 두고 불 같이 화를 냈다.
노이만은 컴퓨터 같은 비싼 도구로 낭비를 한다고 생각한 것이다.
수학을 좋아했던 노이만 입장에선 0과 1로만 이루어진 기계어는 매우 아름답게 보였을 것이다.
세기의 천재인 노이만이 프로그래밍하는데 충분하다고 했던, 그리고 아름답다고 여겼을 기계어가 어떻게 생겼는지 보자.
아래는 나무위키에서 긁어온 Hello World를 출력하는 기계어라고 한다.

```
b8 21 0a 00 00
a3 0c 10 00 06
b8 6f 72 6c 64
a3 08 10 00 06
b8 6f 2c 20 57
a3 04 10 00 06
b8 48 65 6c 6c
a3 00 10 00 06
b9 00 10 00 06
ba 10 00 00 00
bb 01 00 00 00
b8 04 00 00 00
cd 80
b8 01 00 00 00
cd 80
```

역시 노이만은 천재였던 만큼 범인과는 시야가 달랐던 것 같다.
보통의 프로그래머라면 기계어로 프로그램을 만들려고 시도하지 않을 것이다.
척 보기에도 가독성이 나쁘고 각 코드가 어떤 일을 하는지 알 수 없다.
그래서 나온 것이 어셈블리어다.

어셈블리어는 기계어와 단 둘뿐인 저급 언어(Low Level Language)다.
여기서 저급 언어라는 것은 언어가 떨어진다는 뜻이 아니라 컴퓨터와 더 가까운 언어라는 뜻이다.
앞서 봤듯이 기계어는 사람이 사용하기엔 지나치게 불편한 언어다.
그래서 기계어와 동일한 일을 하지만 문자로 이름을 붙인 어셈블리어를 만들었다.
어셈블리어의 특징은 기계어와 1:1 대응된다는 것이다.
그래서 표현법이 숫자에서 문자로 변경되었을 뿐이라서 성능이 거의 변하지 않는다.
아래는 기계어에 대응되는 어셈블리어다.

```
001000 00001 00000 0000000000001010
addi $0, $1, 10
```

위의 코드가 무엇인지 모르더라도 딱 봐도 가독성이 크게 좋아보인다.
과거 컴퓨터의 성능이 좋지 못할 때는 어셈블리어로 코드를 작성했다.
이는 C 같은 언어로 작성하면 따로 컴파일하는데 시간이 많이 걸리기 때문이다.
그렇지만 현대에는 대부분의 경우 고급 언어를 사용하고 어셈블리어는 사용하지 않는다.
그 이유를 알기 위해선 기계어의 특성을 알아야 한다.

앞서 기계어가 마치 특정한 언어인것 마냥 설명했지만, 기계어는 언어가 아니다.
정확히 말하자면 제조사별 CPU에 사용하는 명령어 집합이다.
그렇기 때문에 제조사가 바뀌거나 CPU가 바뀐다면 서로 다른 기계어를 사용한다.
닌텐도 게임같이 독자적인 플랫폼 게임이 컴퓨터에서 직접적으로 동작하지 않는 이유도 서로 다른 CPU를 사용하기 때문이다.

그리고 어셈블리어는 기계어에 1:1 대응되는 언어라고 했다.
각 CPU마다 다른 기계어를 사용한다는 것은 곧 서로 다른 어셈블리어를 쓴다는 것이다.
그래서 A라는 컴퓨터에서 어셈블리어로 코드를 만들었을 때, B라는 컴퓨터에서 동작할지 장담할 수 없다.
뿐만 아니라 어셈블리어는 메모리 같은 세세한 부분까지 신경써야 한다.
현대 프로그램은 너무나 복잡하기 때문에 사소한 것까지 지정해야 하는 어셈블리어는 생산성이 너무 떨어진다.

결국 여러가지 단점 때문에 저급 언어는 파이썬, 자바 같은 고급 언어보다 덜 쓰인다.
그렇다고해서 고급 언어로 작성한 코드의 성능이 크게 떨어지는 것도 아니다.
고급 언어로 작성한 파일을 컴파일러가 알아서 변환해주기 때문이다.
현대 컴파일러 성능은 굉장히 뛰어나다.
그래서 컴파일러가 변환한 코드는 어셈블리 코더가 직접 작성한 것과 거의 유사한 성능을 보인다.
뿐만 아니라 고급 언어로 작성하면 다른 컴퓨터에서 실행이 가능해서 어셈블리어 같은 불편함은 없다.

그럼에도 불구하고 저급 언어를 익히는 것은 중요하다.
컴파일러가 일을 대신해주므로 직접 작성할 필요는 없지만, **컴파일러가 만든 코드를 읽고 이해할 수 있는 정도의 기술**은 필요하기 때문이다.
어셈블리 코드를 이해할 수 있으면, 최종적으로 만들어진 코드로 최적화 성능을 알 수 있고, 비효율성을 개선할 수 있다.
그리고 바이러스에 대항하려면 어떻게 데이터가 공유, 유지, 접근 되는지 알아야한다.
이 경우에도 어셈블리어를 알아야 바이러스에 취약한 부분을 알 수 있다.
그러므로 이번 장에서는 어떻게 어셈블리어가 만들어지고 사용되는지 알아보겠다.

## 3.2 Incoding

### 3.2.1 GCC Compiler

컴파일러는 어떤 언어로 작성된 코드를 다른 언어로 바꿔주는 일을 한다.
일반적으로 컴파일러는 고급 언어로 작성된 프로그램을 저급 언어로 번역해 실행 프로그램을 만들어준다.
이때 원본 파일을 원본 코드(Source Code)라고 하고 생성되는 파일을 목적 코드(Object Code)라고 한다.

우리는 C언어를 컴파일하기 위해서 GCC 컴파일러를 사용한다.
리눅스 계열이라면 자동으로 설치되어 있으므로 별다른 설치는 필요없다.
컴파일러가 원본 파일(\*.c)를 컴파일하는 과정은 다음과 같다.

helloword.c -> [**Preprocessor**] -> helloword.i -> [**Compiler**] -> helloworld.s -> [**Assembler**] -> helloworld.o -> [**Linker**] -> helloworld

-   Preprocessor(전처리기): #으로 시작하는 지시문을 처리해준다. #include 구문에는 헤더 파일을 삽입해주고, #define의 문자와 같은 문자열을 그 내용으로 치환해준다.
-   Compiler: 고급 언어 소스 코드 파일(\*.i)을 어셈블리어 파일(\*.s)로 변환한다.
-   Assembler: 어셈블리어(\*.s)를 목적 파일(.o)로 변환한다.
-   Linker: 생성된 목적 파일을 묶어서 실행 파일을 만든다.

GCC C 컴파일러는 기계어 코드를 어셈블리 코드의 형태로 출력을 만들어 인스트럭션을 만든다.[^2]
그 다음 GCC는 어셈블러와 링커를 호출하여 어셈블리 코드로부터 실행 가능한 기계어 코드를 생성한다.

### 3.2.2 Code Examples

C 프로그램을 2개의 파일 p1.c와 p2.c에 작성한다고 하자.
유닉스 커맨드 라인으로 다음과 같이 컴파일 한다.
`gcc -Og -o p p1.c p2.c`
위 명령어는 GCC C 컴파일러를 지정한다.
컴파일러는 효율을 위해 순서를 바꾸거나 계산 방법을 바꾼다.
그래서 결과물을 보면 원래의 코드와 크게 달라져서 분석하기 어렵다.
GCC는 커맨드 라인 옵션으로 -Og를 주면, 원본 C 코드 구조 대로 기계어로 바꾼다.
그래서 -Og 최적화를 적용하였다.
실제로는 최적화를 -01, -02로 높여야 프로그램의 성능이 좋아진다.

gcc명령은 소스 코드를 실행 코드로 변환하기 위해 프로그램들을 호출한다.

1. C 전처리기가 #include로 명시된 파일을 코드에 삽입해주고, #define으로 선언된 매크로를 확장해준다.
2. 컴파일러는 2개의 소스 파일의 어셈블리 버전인 p1.s와 p2.s를 생성한다.
3. 어셈블러는 어셈블리 코드를 바이너리 목적코드인 p1.o와 p2.o로 변환한다.(목적코드는 기계어 코드의 한 유형이다.)
4. 링커는 2개의 목적코드 파일을 라이브러리 함수들을 구현한 코드와 함께 합쳐서 최종 실행 파일인 p를 생성한다.(명령줄 디렉티브 -op로 명시하여)

기계수준 프로그램의 형식과 동작은 인스트럭션 집합구조(Instruction set Architecture) 즉 ISA에 의해 정의된다.
ISA는 프로세서의 명령어인 인스트럭션의 집합이다.
간단히 말해 ISA는 프로세서의 설명서로, 명령어마다 프로세서에게 다른 일을 시킨다.
ISA는 프로그램의 동작을 설명할 때 인스트럭션이 순차적으로 실행되는 것처럼 설명한다.
하지만 실제 프로세서는 굉장히 정교해서 동시에 여러 인스트럭션을 실행한다.
그럼에도 순차적으로 실행되는 것과 동일한 결과를 내도록 설계되어 있다.

기계수준 프로그램이 사용하는 주소는 가상주소이며, 메모리가 매우 큰 바이트 배열인 것처럼 보이게 하는 메모리 모델을 제공한다.
실제로는 여러 개의 메모리 하드웨어와 운영체제 소프트웨어로 구현되어 있다.

x86-64를 위한 기계어 코드는 본래 C 코드와 상당히 다르다.

-   프로그램 카운터(일반적으로 PC라고 하며, x86-64에서는 %rip라고 한다)는 실행할 다음 인스트럭션의 메모리 주소를 가리킨다.
-   정수 레지스터 파일은 64비트 값을 저장하기 위한 16개의 이름을 붙인 위치를 갖는다. 이들 레지스터는 주소(C언어의 포인터에 해당하는)나 정수 데이터를 저장할 수 있다. 일부 레지스터는 프로그램의 중요한 상태를 추적하는데 사용할 수 있으며, 다른 레지스터들은 함수의 리텁 값뿐만 아니라 프로시저의 지역변수와 인자 같은 임시 값을 저장하는 데 사용한다.
-   조건코드 레지스터들은 가장 최근에 실행한 산술 또는 논리 인스트럭션에 관한 상태 정보를 저장한다. 이들은 if나 while문을 구현할 때 필요한 제어나 조건에 따른 데이터 흐름의 변경을 구현하기 위해 사용된다.
-   벡터 레지스터들의 집합은 하나 이상의 정수나 부동소수점 값들을 각각 저장할 수 있다.

C가 데이터 타입을 선언하고 메모리에 할달할 수 있는 모델을 제공하는 반면, 기계어 코드는 메모리를 단순한 바이트 주소지정이 가능한 큰 배열로 본다.
C에서 배열과 구조체 같은 연결된 데이터 타입들은 기계어 코드에서는 연속적인 바이트들로 표시된다.
스칼라 데이터 타입의 경우에도 어셈블리 코드는 부호형, 비부호형, 다른 타입의 포인터들, 심지어 포인터와 정수형 사이에서도 구분을 하지 않는다.

프로그램 메모리는 프로그램의 실행 기계어 코드, 운영체제를 위한 일부 정보, 프로시저 호출과 리턴을 관리하는 런타임 스택, 사용자에 의해 할당된 메모리 블록들을 포함하고 있다.
언제나 가상주소의 일부 제한된 영역만이 유효하다.

하나의 기계어 인스트럭션은 매우 기초적인 동작만을 수행한다.
예를 들어, 레이스터 들에 저장된 두 수를 더하고, 메모리와 레지스터 간에 데이터를 교환하거나, 새로운 인스트럭션 주소로 조건에 따라 분기하는 등의 동작을 한다.
컴파일러는 일련의 인스트럭션을 생성해서 산술연산식의 계산, 반복문, 프로시저 호출과 리턴 등의 프로그램 구문을 구현해야 한다.

다음과 같은 프로시저 정의를 포함하고 있는 C코드 파일을 작성한다고 하자

```
// mstore.c
long mult2(long, long);

void mulstore(long x, long y, long *dest) {
    long t = mult2(x, y);
    *dest = t;
}
```

C 컴파일러가 생성한 어셈블리 코드를 보기 위해 명령줄에서 -S 옵션을 사용할 수 있다.
`gcc -Os -S mstore.c`
이는 GCC로 하여금 컴파일러를 실행하도록 해서 mstore.s를 만들고 더이상 진행하지 않는다.(대개 그 다음에 어셈블러를 호출해서 목적코드 파일을 생성한다.)

```
multsrotre:
    pushq   %rbx
movq    %rdx, %rbx
call    mult2
movq    %rax, (%rbx)
popq    %rbx
ret
```

위 코드의 각 라인은 하나의 기계어 인스트럭션에 대응된다.
예를 들어, pushq 인스트럭션은 레지스터 %rbx가 프로그램 스택에 저장(push)되어야 한다는 것을 의미한다.
지역 변수 이름이나 데이터 타입에 관한 모든 정보는 삭제되었다.

만일 명령어 라인 옵션을 사용한다면 GCC는 코드를 컴파일하고 에셈블할 것이다.

`gcc -Og -c mstore.c`

위는 mstore.o 파일을 생성하는데, 다음과 같은 14바이트 16진수 데이터가 내장되어 있다.

53 38 89 d3 e8 00 00 00 00 48 89 03 5b c3

이것은 위에 나열된 어셈블리 인스트럭션에 대응되는 목적코드다.
결국 컴퓨터로 실행되는 프로그램은 단순히 일련의 인스트럭션을 인코딩한 일련의 바이트다.
컴퓨터는 인스트럭션들이 생성된 소스 코드에 대한 정보를 거의 갖고 있지 않다.

기계어 코드 파일의 내용을 조사하려면, 역어셈블러라고 하는 프로그램을 사용한다.
이 프로그램은 기계어 코드로부터 어셈블리어 코드와 유사한 형태를 생성한다.
리눅스 시스템에서 OBJDUPM에 -d 커맨드 라인을 사용하면 이 역할을 수행할 수 있다.

`objdump -d msotre.o`

```
0000000000000000 <multstore>
0: 53               push    %rbx
1: 48 89 d3         mov     %rdx,%rbx
4: e8 00 00 00 00   callq   9 <multstore_0x9>
9: 48 89 03         mov %rax,(%rbx)
c: 5b               pop %rbx
d: c3               retq
```

위의 각 그룹은 하나의 인스트럭션으로 오른쪽에 보여준 어셈블리어와 동일하다.

기계어 코드의 몇몇 특징과 이들의 역어셈블된 표현을 알아보자.

-   x86-64 인스트럭션의 길이는 1~15 바이트다. 인스트럭션 인코딩은 자주 사용되는 인스트럭션과 연산자가 적은 것의 길이를 짧게 하고, 그 반대의 경우 길이를 길게 인코딩한다.
-   인스트럭션은 시작 위치에서부터 바이트를 기계어 인스트럭션으로 유일하게 디코딩한다. 예를 들어 pushq %rbx 인스트럭션만 바이트 값 53으로 시작된다.
-   역어셈블러는 기계어 코드 파일의 바이트 순서로만 어셈블리 코드를 결정한다.
-   역어셈블러는 GCC가 생성한 어셈블리 코드와는 약간 다른 명명법을 인스트럭션에 사용한다. 위의 예제에서 많은 인스트럭션들이 접미어 'q'를 생략하였다. 접미어는 크기를 나타내는 것으로 대부분의 경우 생략할 수 있다. 반대로 역어셈블러는 접미어 'q'를 call과 ret 명령에 붙이는데, 마찬가지로 이도 생략할 수 있다.

실제 실행 가능 코드를 생성하기 위해서 링커는 목적코드에 실행해야 한다.
이 중 1개의 파일은 main 함수를 포함해야 한다.
main.c 파일에 다음 같은 함수가 있다고 하자.

```
#include <stdio.h>

void multstore(long, long, long *);

int main() {
    long d;
    multstore(2, 3, &d);
    printf("2 * 3 --> %ld\n", d);
    return 0;
}
long mult2(long a, long b) {
    long s = a * b;
    return s;
}
```

그리고 실행 가능 프로그램인 prog를 다음처럼 생성한다.

`gcc -Og -o prog main.c mstore.c`

이렇게하면 파일의 크기가 늘어난다.
그 이유는 우리가 제공한 2개의 프로시저 뿐만 아니라 운영체제와 상호작용하기 위한 코드, 그리고 프로그램을 시작하고 종료하기 위한 코드까지 포함하기 때문이다.
파일을 다음처럼 역어셈블해보자.

`odjump -d prog`

```
0000000000400540 <multstore>
400540: 53               push    %rbx
400541: 48 89 d3         mov     %rdx,%rbx
400544: e8 00 00 00 00   callq   9 <multstore_0x9>
400549: 48 89 03         mov %rax,(%rbx)
40054c: 5b               pop %rbx
40054d: c3               retq
40054e: 90               nop
40054f: 90               nop
```

이 코드는 mstore.c를 역어셈블해서 생성한 것과 거의 동일하다.
한 가지 차이점은 왼쪽에 나타낸 주소가 다르다.
두 번째 차이점은 링커가 callq 인스트럭션이 함수 mult2를 호출 할 때 사용해야하는 주소를 채웠다는 점이다.
링커의 한 가지 임무는 함수들을 위한 실행 코드의 위치들과 함수 호출을 일치시키는 것이다.
마지막 차이는 마지막에 추가된 2줄이 있다.
이 2줄의 인스트럭션은 리턴 인스트럭션 이후에 발행하므로 아무런 효과도 없다.
함수를 위한 코드 길이를 16바이트로 늘려서 코드의 다음 블록을 메머리 시스템 성능 면에서 더 잘배치하기 위해 삽입되었다.

GCC가 생성하는 어셈블리 코드는 사람이 읽기 어렵다.
한편으로는 우리가 걱정할 필요 없는 정보를 포함하고 있지만, 다른 한편으로는 프로그램의 동작 방법이나, 프로그램에 대한 설명을 제공하지 않는다.
아래 명령으로 mstore.s를 만든다.

`gcc -Og -S mstore.c`

이 파일의 전체 내용은 다음과 같다.

```
        .file   "010-mstore.c"
        .text
        .globl  multstore
        .type   multstore, @function
multstore:
        pushq   %rbx
        movq    %rdx, %rbx
        call    mult2
        movq    %rax, (%rbx)
        popq    %rbx
        ret
        .size   multstore, .-multstore
        .ident  "GCC: (Ubuntu 4.8.1-2ubuntu1~12.04) 4.8.1"
        .section        .note.GNU-stack,"",@progbits
```

'.'으로 시작하는 모든 라인은 어셈블러와 링커에 지시하기 위한 디렉티브다.
일반적으로 이들은 무시해도 된다.
반면 인스트럭션들이 무엇을 하고, 어떻게 소스 코드와 연관되는지에 대한 설명이 없다.

어셈블리 코드를 보다 깔끔하게 나타내기 위해 대부분의 디렉티브들을 생략하겠지만, 라인 번호와 설명하는 주석들은 포함시킬 것이다.
위 예제의 주석 있는 버전은 아래와 같다.

```
void multstore(long x, long y, long *dest)
x in %rdi, y in %rsi, dest in %rdx

multstore:
    pushq   %rbx            Save %rbx
    movq    %rdx, %rbx      Copy dest to %rbx
    call    mult2           Call mult2(x, y)
    movq    %rax, (%rbx)    Store result at *dest
    popq    %rbx            Restore %rbx
    ret                     Return
```

## Data Formats

인텔 프로세서는 16비트 구조를 사용하다가 32비트로 확장했다.
그래서 인텔은 16비트 데이터 타입을 기본으로 사용해서 "word"라고 말한다.
여기서 확장해서 32비트는 "double words", 64비트는 "quad words"라고 한다.
이를 가지고 C의 데이터 타입에 따라 x86-64 표현법을 알아보자.
int는 32비트이므로 double words가 되고, 포인터는 64비트이므로 quad words가 된다.
이와 같은 방법으로 데이터의 타입에 따라 형식이 바뀌게 된다.

인텔 데이터 형식을 알아본 이유는 어셈블리 코드인스트럭션은 피연산자의 크기를 표현하는 접미어가 있기 때문이다.
movb는 Byte 이동, movw는 Word 이동, movl는 Double word 이동, movq는 Quad word 이동이다.
이 중 "l"이 Doble word로 사용되는데 그 이유는 32비트가 "long word"로 간주되기 때문이다.
아래는 각 데이터 타입에 따른 인텔 데이터 타입이다.

| C       | Intel data type       | Assembly-code-suffix | size |
| ------- | --------------------- | -------------------- | ---- |
| char    | Byte                  | b                    | 1    |
| short   | Word                  | w                    | 2    |
| int     | Double word           | l                    | 4    |
| long    | Quad word             | q                    | 8    |
| char \* | Quad word             | q                    | 8    |
| float   | Single precision word | s                    | 4    |
| double  | Double precision      | l                    | 8    |

## Accesing Information

x86-64 CPU는 64비트 값을 저장할 수 있는 16개의 레지스터[^3]가 있다.
초창기 8086에는 %ax에서 %sp까지 16비트 레지스터가 8개 있었다.
각 레지스터마다 목적이 달랐기 때문에, 사용방법에 따라 이름을 붙였다.
그리고 레지스터가 32비트로 확장되면서 %eax에서 %esp로 이름을 붙였다.
다시 64비트인 x86-64로 확장하면서 이름을 %rax에서 %rsp로 바꿨다.
그리고 레지스터를 8개 추가하면서 이들을 %r8에서 %r15로 이름을 붙였다.
아래는 16개의 레지스터를 비트에 따라 이름을 적은 것이다.

| 63   | 31   | 15   | 7    | 0             |
| ---- | ---- | ---- | ---- | ------------- |
| %rax | %eax | %ax  | %al  | Return Value  |
| %rbx | %ebx | %bx  | %bl  | Callee saved  |
| %rcx | %ecx | %cx  | %cl  | 4th argument  |
| %rdx | %edx | %dx  | %dl  | 3rd argument  |
| %rsi | %esi | %si  | %sil | 2nd argument  |
| %rdi | %edi | %di  | %dil | 1st argument  |
| %rbp | %ebp | %bp  | %bpl | Callee saved  |
| %rsp | %esp | %sp  | %spl | Stack pointer |
| %r8  | %r8  | %r8  | %r8  | 5th argument  |
| %r9  | %r9  | %r9  | %r9  | 6th argument  |
| %r10 | %r10 | %r10 | %r10 | Caller saved  |
| %r11 | %r11 | %r11 | %r11 | Caller saved  |
| %r12 | %r12 | %r12 | %r12 | Callee saved  |
| %r13 | %r13 | %r13 | %r13 | Callee saved  |
| %r14 | %r14 | %r14 | %r14 | Callee saved  |
| %r15 | %r15 | %r15 | %r15 | Callee saved  |

표의 최우측을 보면 각 레지스터마다 다른 목적으로 사용됨을 알 수 있다.
이 중 스택 포인터 %rsp는 런타임 스택의 가장 끝 부분을 표현하기 위해 사용된다.

### Operand Specifiers

대부분의 인스트럭션은 하나 이상의 피연산자를 써서 연산을 수행할 값과 결과를 저장할 위치를 정한다.
이때 값은 상수를 사용하거나, 레지스터 또는 메모리에서 읽어들인다.
그리고 결과값은 레지스터나 메모리에 저장한다.

피연산자는 3가지 종류가 있다.
첫 번째는 **immediate는 상수값**을 말한다.
어셈브리 코드에서 $ 다음에 수가 오는 것으로 사용할 수 있다.
예를 들어서 $-577, $0x1F로 사용하면 된다.
인스트럭션에 따라 immediate 값의 범위가 달라지는데, 어셈블러는 알아서 가장 효율적인 인코딩 방법을 사용한다.

두 번째 타입은 register로 레지스터의 내용을 나타낸다.
표기법으로 ${r_a}$를 사용하며, 레지스터를 배열 R로 생각해서 $R[r_a]$로 값을 지정한다.

세 번째 타입은 memory로 메모리 주소를 사용해서 메모리 값을 사용한다.
메모리를 거대한 바이트 배열로 생각해서 $M_b[Addr]$과 같이 표시할 수 있다.
이는 메모리 주소 Addr로 부터 b 바이트를 참조한다는 의미다.
아래 표는 메모리 타입에 따른 형태와 연산값을 적은 것이다.

| Type      | Form             | Operand value                      | Name                |
| --------- | ---------------- | ---------------------------------- | ------------------- |
| Immediate | $Imm             | Imm                                | Immediate           |
| Register  | $r_a$            | $R[r_a]$                           | Register            |
| Memory    | $Imm$            | $M[Imm]$                           | Absolute            |
| Memory    | $(r_a)$          | $M[R[r_a]]$                        | Indirect            |
| Memory    | $Imm(r_b)$       | $M[Imm + R[r_b]]$                  | Base + displacement |
| Memory    | $(r_b,r_i)$      | $M[R[r_b]+R[r_i]]$                 | Indexed             |
| Memory    | $Imm(r_b,r_i)$   | $M[Imm + R[r_b] + R[r_i]]$         | Indexed             |
| Memory    | $(,r_i,s)$       | $M[R[r_i] \cdot s$                 | Scaled indexed      |
| Memory    | $Imm(,r_i,s)$    | $M[Imm + R[r_i] \cdot s$           | Scaled indexed      |
| Memory    | $(r_b,r_i,s)$    | $M[R[r_b] + R[r_i] \cdot s$        | Scaled indexed      |
| Memory    | $Imm(r_b,r_i,s)$ | $M[Imm + R[r_b] + R[r_i] \cdot s]$ | Scaled indexed      |

여기서 핵심은 상수는 $를 사용하고, 레지스터는 %rax 같은 레지스터의 값을 가리킨다.
그 외의 경우는 메모리 주소를 가리키는데, 레지스터 안의 데이터와 상수를 사용해 메모리 주소를 가리킨다.
그리고 그 메모리 주소 안의 내용을 사용한다.

> Practice Problem 3.1  
> 다음 값이 메모리 주소와 레지스터에 저장되어 있다.
> | Address | Value | Register | Value |
> | - | - | - | - |
> |0x100 | 0xFF | %rax | 0x100 |
> | 0x104 | 0xAB | %rcx | 0x1 |
> | 0x108 | 0x13 | %rdx | 0x3 |
> | 0x10c | 0x11 |
>
> 위의 값으로 아래 표를 완성하시오.  
> | Operand | Value | Comment |
> | -------------- | ----- | ------------------- |
> | %rax | 0x100 | Register |
> | 0x104 | 0xAB | Absolute address |
> | $0x108 | 0x108 | Immediate |
> | (%rax) | 0xFF | Indirect |
> | 4(%rax) | 0xAB | Base + displacement |
> | 9(%rax,%rdx) | 0x11 | Indexed |
> | 260(%rcx,%rdx) | 0x13 | Indexed |
> | 0xFC(,%rcx,4) | 0xFF | Scaled Indexed |
> | (%rax,%rdx,4) | 0x11 | Scaled indexed |

### Data Movement Instructions

가장 많이 쓰이는 인스트럭션은 데이터를 다른 위치로 복사하는 명령이다.
데이터 이동 인스트럭션 중 가장 간단한 것은 -MOV 클래스다.
-MOV는 데이터에 어떠한 변화도 주지 않고 복사한다.
-MOV 클래스는 movb, movw, movl, movq로 4개의 인스트럭션으로 구성된다.
이들의 효과는 동일하지만 실행되는 데이터의 크기만 다를 뿐이다.
이전에 살펴봤듯이 word의 크기에 따라서 b, w, l, q를 사용한다.

| Instruction | Effect      | Description             |
| ----------- | ----------- | ----------------------- |
| MOV S,D     | $S \rarr D$ | Move                    |
| movb        |             | Move byte               |
| movw        |             | Move word               |
| movl        |             | Move double word        |
| movq        |             | Move quad word          |
| movabsq I,R | $I \rarr R$ | Move absolute quad word |

MOV는 *MOV S,D*로 작성한다.
이는 S(source operand)에서 D(destination operand)로 저장값을 이동한다는 의미다.
여기서 source operand의 뜻을 해석하자면, source는 원본이란 뜻이고, operand는 피연산자라는 뜻이다.
그래서 S는 연산이 적용되는 원본 저장 값이라는 뜻이다.
비슷하게 destination operand는 목적 피연산자가 된다.

데이터를 옮기는 원본 피연산자는 상수, 레지스터 저장 값, 메모리 저장 값을 사용한다.
데이터를 옮겨 받는 목적 피연산자는 레지스터, 또는 메모리 주소를 지정한다.
이는 당연한 것이 데이터를 저장할 수 있는 곳이 레지스터나 메모리 뿐이므로 D에는 레지스터나 메모리 주소가 들어가야 한다.
반면 S는 상수값을 사용할 수 있게 해야 저장되지 않은 값도 만들 수 있게 된다.

다만 MOV가 완전히 자유로운 것은 아니다.
x86-64는 데이터 이동 인스트럭션에서 두개의 피연산자가 모두 메모리 위치에 올 수 없도록 제한한다.
그래서 하나의 메모리에서 다른 메모리 위치로 데이터를 옮기려면, 2개의 인스트럭션을 사용해서 레지스터를 한 번 거쳐서 옮겨야 한다.
대부분의 MOV 인스트럭션은 대상 레지스터나 메모리만 수정한다.
유일한 예외는 movl이 레지스터를 목적지로 쓰는 경우다.
이 경우 레지스터 상위 4바이트도 0으로 설정한다.
이는 레지스터를 위한 32비트 값을 생성하는 인스트럭션은 상위 바이트 또한 0으로 설정하도록하는 관습 때문에 생긴 것이다.

아래의 MOV 인스트럭션 예제는 5가지 가능한 조합을 보여준다.
원본 피연산자가 먼저 나오고 다음에 목적 피연산자가 나온다.

```
movl $0x4050,%eax     Immediate--Register,    4 bytes
movw %bp,%sp          Register--Register,     2 bytes
movb (%rdi,%rcx),%al  Memory--Register,       1 byte
movb $-17,(%esp)      Immediate--Memory,      1 byte
movq %rax,-12(%rbp)   Register--Memory,       8 bytes
```

작은 원본 값을 더 큰 목적지로 복사할 때 사용하기 위한 명령도 존재한다.
아래의 두 인스트럭션은 모두 레지스터나 메모리에 저장되어 있는 원본을 레지스터 목적지로 복사한다.

| Instruction | Effect                  | Description                            |
| ----------- | ----------------------- | -------------------------------------- |
| MOVZ S, R   | $ZeroExtend(S) \rarr R$ | Move with zero extension               |
| movzbw      |                         | Move zero-extended byte to word        |
| movzbl      |                         | Move zero-extended byte to double word |
| movzwl      |                         | Move zero-extended word to double word |
| movzbq      |                         | Move zero-extended byte to quad word   |
| movzwq      |                         | Move zero-extended word to quad word   |

| Instruction | Effect                          | Description                                 |
| ----------- | ------------------------------- | ------------------------------------------- |
| MOVS S, R   | $SignExtend(S) \rarr R$         | Move with sign extension                    |
| movsbw      |                                 | Move sign-extended byte to word             |
| movsbl      |                                 | Move sign-extended byte to double word      |
| movswl      |                                 | Move sign-extended word to double word      |
| movsbq      |                                 | Move sign-extended byte to quad word        |
| movswq      |                                 | Move sign-extended word to quad word        |
| movslq      |                                 | Move sign-extended double word to quad word |
| cltq        | $SignExtend(\%eax) \rarr \$rax$ | Sign-extend %eax to %rax                    |

MOVZ 클래스 인스트럭션은 목적지의 남은 바이트를 모두 0으로 채운다.
MOVS 클래스는 원본 피연산자의 가장 중요한 비트로 남은 바이트를 채운다.
이 둘은 이전장에서 다뤘던 shift와 비슷한 내용이다.
경우에 따라 0으로 채워야 하는 경우 MOVZ를 사용하고, 제일 중요한 비트로 채워야 하는 경우 MOVS를 쓴다.

두 클래스 모두 마지막 2개의 글자가 문자의 크기를 나타낸다.
첫 번째 글자가 원본의 크기고, 두 번째가 목적지의 크기를 나타낸다.

여기서 MOVZ에 movzlq가 없다.
이는 다시 말해 4바이트 원본을 8바이트로 옮길 때, 0으로 채우는 명령이 없다는 의미다.
movzlq가 존재하진 않지만, movl 인스트럭션으로 구현된다.
이는 movl로 옮기면 자동으로 상위 4바이트를 0으로 채우기 때문이다.

MOVS 클래스를 보면 cltq 인스트럭션이 있다.
이 인스트력션은 피연산자가 없다.
그 이유는 항상 레지스터 %eax를 원본으로 하고, %rax를 목적지로 하기 때문이다.
이는 movslq %eax, %rax와 동일한 효과를 내지만, 좀 더 압축된 인코딩을 한다.

> Practice Problem 3.2  
> 다음 어셈블리어를 보고 피연산자에 적절한 인스트럭션을 적으시오.  
> movl $eax, (%rsp)  
> movw (%rax), %dx  
> movb $0xFF, %bl  
> movb (%rsp,%rdx,4), %dl  
> movq (%rdx), %rax  
> movw %dx, (%rax)

> Practice Problem 3.3  
> 다음 코드는 각각 에러 메세지를 출력한다.
> 각 줄마다 어떤점이 잘못되었는지 적으시오.  
> movb $0xF, (%ebx)  
> movl %rax, (%rsp)  
> movw (%rax),4(%rsp)  
> movb %al,%sl  
> movq %rax,$0x123  
> movl %eax,%rdx  
> movb %si, 8(%rbp)
>
> 풀이)
> %ebx는 32비트 레지스터다. 그러므로 (%ebx)는 32비트 메모리 주소를 가리킨다. 그런데 movb는 8비트에 사용할 수 있으므로 틀렸다.
> movl은 double word에 사용해야 하는데 quad word에 사용했다.
> MOV의 두 피연산자가 메모리 주소가 될 수 없다.
> %sl이라는 레지스터는 없다.
> 목적 피연산자에 immediate를 사용할 수 없다.
> 목적 피연산자가 quad word인데 movl을 사용했다.
> %si는 word이므로 movw를 사용해야 한다.

```
Remark

다음은 데이터 이동 인스트럭션이 어떻게 목적지의 바이트를 변경하는지 보여준다. 이때 movb, movsbq, movzbq를 보면 차이가 존재한다. movb는 해당 바이트만 변경하고, movsbq는 제일 중요한 비트를 확장해서 채운다. 그리고 movzbq는 나머지 비트를 모두 0으로 채운다.
movabsq $0x0011223344556677, %rax   // %rax = 0011223344556677
movb $0xAA, %dl                     // %dl = AA
movb %dl,%al                        // %rax = 00112233445566AA
movsbq %dl,%rax                     // %rax = FFFFFFFFFFFFFFAA
movzbq %dl,%rax                     // %rax = 00000000000000AA
```

### Data Movement Example

아래는 데이터 이동 인스트럭션의 예제 코드다.

```
(a) C code
long exchange(long *xp, long y)
{
    long x = *xp;
    *xp = y;
    return x;
}

(b) Assembly code
    // long exchange(long *xp, long y)
    // xp in %rdi, y in %rsi
exchange:
    movq    (%rdi), %rax    // Get x at xp. Set as return value.
    movq    %rsi, (%rdi)    // Store y at xp.
    ret                    //  Return.
```

위 코드를 프로시저가 실행하면, xp와 y는 각각 레지스터 %rdi와 %rsi에 저장된다.
그리고 %rdi에 있는 xp의 값을 %rax에 저장한다.
이때 %rax에 저장하는 이유는 %rax가 리턴값을 저장하기 때문이다.
(a)코드를 보면 `x = *xp`로 x 값을 정하고 `return x`를 반환하기 때문에 xp의 값은 %rax에 저장되어야 한다.
다음으로 y 값이 %rsi에 들어 있으므로 `*xp = y`를 구현하려면, %rsi를 (%rdi)로 옮겨줘야 한다.

위 코드에서 핵심은 2가지다.
첫 번째는 C에서 *포인터*는 에섬블리어에서 단순한 주소다.
포인터를 레지스터에 복사하고, 그 레지스터를 메모리 참조에 사용해서 포인터의 값을 사용한다.
두 번째는 x같은 지역 변수는 레지스터에 저장된다는 것이다.
이는 레지스터가 메모리보다 접근하는 속도가 더 빠르기 때문이다.

> Practice Problem 3.4  
> 두 변수 sp와 dp가 아래와 같은 타입으로 선언되어 있다.
>
> src_t *sp;  
> dest_t *dp;
>
> 여기서 src_t와 dest_t는 typedef로 선언된 타입이다.  
> 우리는 데이터 이동 인스트럭션을 사용해서 아래 연산을 만들려고 한다.  
> *dp = (dest_t) *sp;  
> sp와 dp값은 각각 레지스터 %rdi와 %rsi에 저장되어 있다.  
> 이때 아래의 표를 완성하시오.
> C언어에서 크기를 바꾸고 부호를 변경하는 경우, 크키를 먼저 변경하고 부호를 변경한다.(2.2.6절 참조)
>
> | src_t         | dest_t        | Instruction         |
> | ------------- | ------------- | ------------------- |
> | long          | long          | movq (%rdi), %rax   |
> |               |               | movq %rax, (%rsi)   |
> | char          | int           | movsbl (%rdi), %eax |
> |               |               | movl %eax, (%rsi)   |
> | char          | unsigned      | movsbl (%rdi), %eax |
> |               |               | movl %eax, (%rsi)   |
> | unsigned char | long          | movzbl (%rdi), %eax |
> |               |               | movq %rax, (%rsi)   |
> | int           | char          | movl (%rdi), %eax   |
> |               |               | movb %al, (%rsi)    |
> | unsigned      | unsigned char | movl (%rdi), %eax   |
> |               |               | movb %al, (%rsi)    |
> | char          | short         | movsbw (%rdi), %ax  |
> |               |               | movw %ax, (%rsi)    |
>
> 여기서 char -> unsigned 변환은 사이즈 변환과 부호변화를 둘 다 포함하고 있다.
> 이 경우는 먼저 사이즈를 바꾼 다음 부호 변화를 해야 한다.
> 그래서 char -> int -> unsigned int로 변환해야 한다.
> 그러므로 char -> int인 movsbl이 일어난 다음, int -> unsigned인 movl이 일어나야 한다.

> Practice Problem 3.5  
> void decode1(long *xp, long *yp, long \*zp)  
> 위와 같은 코드가 아래처럼 어셈블리 코드로 컴파일 되었다.
> decode 1:  
>  movq (%rdi), %r8
> movq (%rsi), %rcx
> movq (%rdx), %rax
> movq %r8, (%rsi)  
>  movq %rcx, (%rdx)  
>  movq %rax, (%rdi)  
>  ret
> 매개변수 xp, yp, zp가 각각 %rdi, %rsi, %rdx에 들어 있을다면, 원본 코드를 작성하시오.
>
> void decode1 (long *xp, long *yp, long *zp) {  
> long x = *xp;  
> long y = *yp;  
> long z = *zp;
>
> *yp = x;  
> *zp = y;  
> \*xp = z;  
> }

### Pushing and Popping Stack Data

마지막 데이터 이동은 프로그램 스택에서 데이터를 저장하거나 추출하기 위해 사용한다.
각각 pushq와 popq로 아래 표에 정리했다.

| Instruction | Effect                                            | Description    |
| ----------- | ------------------------------------------------- | -------------- |
| pushq S     | $R[\%rsp]-8 \rarr R[\%rsp]$ $S \rarr M[R[\%rsp]]$ | Push quad word |
| popq D      | $M[R[\%rsp]] \rarr D$ $R[\%rsp]+8 \rarr R[\%rsp]$ | Pop quad word  |

x86-64에서 프로그램 스택은 메모리의 특정 영역에 저장된다.
스택은 자료구조에서 살펴봤듯이 후입선출 구조로 마지막에 추가된 데이터를 top으로 부른다.
그리고 새로운 내용을 추가하는 것이 push, top의 내용을 꺼내는 것을 pop이라고 한다.
이 같은 구조는 배열로 구현될 수 있는데, 배열의 한쪽만 추가하거나 제거한다.

레지스터의 %rsp(Stack pointer)는 스택에서 top의 주소값이 들어있다.
그러므로 스택은 스택 포인터의 값을 기준으로 데이터를 저장하거나 추출한다.
`pusq S`는 1바이트만큼 %rsp의 주소를 감소시키고, S를 해당 주소에 추가한다.
반대로 `popq D`는 top의 내용을 추출하고, 1바이트만큼 주소를 증가시킨다.

아래 표는 pushq와 popq를 실행했을 때 레지스터 값의 변화다.

|      | Initial | pushq %rax | popq %rdx |
| ---- | ------- | ---------- | --------- |
| %rax | 0x123   | 0x123      | 0x123     |
| %rdx | 0       | 0          | 0x123     |
| %rsp | 0x108   | 0x100      | 0x108     |

위를 보면 `pushq %rax`를 했을 때, %rsp의 값이 1바이트 줄어들었다.
그리고 0x123이 0x100에 저장된다.
다음으로 `popq %rdx`를 하면 %rsp의 값이 1바이트 늘어난다.
이때 중요한 것으로 *스택 포인터가 증가했더라도 메모리 0x100의 내용은 그대로 0x123*이다.
0x100의 내용은 다른 내용으로 덮어씌워지기 전에는 0x123의 내용이 그대로 남아 있다.
그렇지만 %rsp의 위치가 바뀜으로 인해 스택의 top의 값이 바뀌는 것이다.

스택은 다른 프로그램 데이터와 동일한 메모리에 저장된다.
그렇기 때문에 프로그램은 메모리 주소를 지정해서 스택 내의 정보를 가져올 수 있다.
예를 들어서 `movq 8(%rsp), %rdx`는 스택의 2번째 값을 %rdx에 넣어준다.

## Arithmetic and Logical Operations

다음은 x86-64의 정수와 논리 연산을 적은 것이다.

| Instruction | Effect               | Description              |
| ----------- | -------------------- | ------------------------ |
| leaq S,D    | $\&S \rarr D$        | Load effective address   |
| INC D       | $D+1 \rarr D$        | Increment                |
| DEC D       | $D-1 \rarr D$        | Decrement                |
| NEG D       | $-D \rarr D$         | Negate                   |
| NOT D       | $~D \rarr D$         | Complement               |
| ADD S,D     | $D+S \rarr D$        | Add                      |
| SUB S,D     | $D-S \rarr D$        | Subtract                 |
| IMUL S,D    | $D*S \rarr D$        | Multiply                 |
| XOR S,D     | $D \wedge S \rarr D$ | Exclusive-or             |
| OR S,D      | $D \| S \rarr D$     | Or                       |
| AND S,D     | $D \& S \rarr D$     | And                      |
| SAL k,D     | $D << k \rarr D$     | Left shift               |
| SHL k,D     | $D << k \rarr D$     | Left shift (same as sal) |
| SAR k,D     | $D >> k \rarr _A D$  | Arithmetic right shift   |
| SHR k,D     | $D >> k \rarr _L D$  | Logical right shift      |

위는 인스트럭션 클래스로 나열한 것이다.
피연산자의 크기에 따라서 뒤에 글자를 추가하면 된다.
예를 들어서 ADD는 addb, addw, addl, addq를 각각 바이트, 워드, 더블워드, 쿼드 워드에 사용한다.
다만 이중에 leaq는 길이에 따라 바뀌지 않는다.

### Load Effective Address

leaq(Load Effective Address)는 주소를 옮기는 인스트럭션이다.
본래 **leaq가 만들어진 이유는 배열에 사용하기 위함**이다.
왜 leaq가 배열에 쓰이기 위해 만들어졌는지는 조금 뒤에 설명하겠다.
우선 leaq를 사용하려면 `leaq S, D` 형태로 적어야 한다.
위의 표를 보면 leaq의 효과에서 &S가 있다.
이는 leaq가 S에 지정한 메모리 값이 들어 있는 메모리 주소를 불러오기 때문이다.
예를 들어서 `leaq (%rbx), %rax`를 생각해보자.
(%rbx)는 M[R[%rbx]]를 계산한다.
다시말해 %rbx 안의 메모리 주소 안의 값을 불러온다.
그런데 여기서 &를 사용했으므로 그 값의 주소를 지정한다.
결과적으론 R[%rbx]를 불러온다.
이는 %rbx에 들어있는 주소이므로 결과적으로 leaq는 %rbx 안의 값을 %rax에 전달한다.
이처럼 S에 들어가는 내용의 주소를 전달하므로 &S라고 적어 주소를 전달하는 것을 표현했다.
여기서 주소를 옮겨받는 D는 레지스터가 되어야 한다.

앞서 살펴봤듯이 %rbx 안의 주소값을 %rax로 옮기려면 `leaq (%rbx), %rax`로 적으면 된다.
그런데 이는 movq를 사용해서 `movq %rbx, %rax`로 적어도 같은 효과를 볼 수 있다.
물론 movq는 leaq와 다르게 S에 상수도 올 수 있고 D에 메모리도 사용할 수 있다.
그렇지만 이런 범위를 제외하고 보면 굳이 leaq를 사용할 이유는 없어보인다.

leaq를 사용하는 이유는 배열의 포인터에서 사용하기 때문이다.
먼저 일반적인 배열을 생각해보자.
C로 코드를 `int y = arr[i];`라고 적었다고 하자.
여기서 %rbx에 arr의 주소가 들어있고, i 값은 %rdx에 있다고 하자.
이를 어셈블리어로 `movq (%rbx, %rdx, 8), %rax`로 적어주면 %rax에 arr[i] 값이 들어간다.
이때 8을 쓴 이유는 i가 1늘어날 때마다 주소가 1바이트 늘어나기 때문이다.

다음으로 배열의 포인터를 사용해보자.
C 코드로 `int *p = &arr[i];`를 생각해보자.
여기서 우리는 주소값이 %rax에 들어가야 한다.
문제는 movq를 사용할 때 괄호를 쓰면 주소 안의 값을 추출한다는 점이다.
그래서 movq로 이 문제를 해결할 수 없고, leaq를 사용해야 한다.
`leaq (%rbx, %rdx, 8), %rax`는 %rax에 &arr[i] 값이 들어간다.

정리하자면 배열의 값을 전달하는 경우는 movq로 해결할 수 있다.
그렇지만 포인터를 사용하는 경우 movq만으로 해결할 수 없다.
그래서 leaq를 사용해서 주소를 옮겨줘야 한다.
결국 둘의 차이는 movq는 내용을 전달하고, leaq는 주소를 전달한다는 것이다.
앞서 `leaq (%rbx) %rax`를 `movq %rbx, %rax`로 사용해도 같은 효과가 나온다고 했다.
이는 결과만 같을 뿐 개념적인 내용은 전혀 다른 얘기다.
leaq는 %rbx에 들어있는 주소를 전달한 것이고, movq는 %rbx의 내용을 옮겨줬기 때문이다.

leaq를 사용하는 장점은 메모리 참조를 하지 않는다는 점이다.
다시 말해 주소만을 가져올 뿐 안의 내용은 사용하지 않는다.
그래서 포인터 같이 주소만을 다루는 경우에 사용하기 적절하다.

또 다른 장점으로는 간단한 연산을 빠르게 해결할 수 있다는 점이다.
예를 들어 %rdi의 값을 4배로 해야 한다고 하자.
이는 `leaq (%rdi, %rdi, 3), %rax`로 해결할 수 있다.
왜냐하면 %rdi의 값을 주소로 생각해서 계산을 진행할 수 있기 때문이다.
또한 값을 더하는 것도 간단하다.
7을 더하려고 하는 경우 `leaq 7(%rdi), %rax`라고 적어주면 된다.
이 둘을 조합하는 것도 가능한데 `leaq 7(%rdi, %rdi, 4), %rax`는 %rdi의 값을 x라고 할 때, 5x+7을 계산하는데 쓸 수 있다.

연산에 사용하는 경우의 예로 다음의 C코드를 설명해보겠다.

```
long scale(long x, long y, long z) {
    long t = x + 4 * y + 12 * z;
    return t;
}
```

위 코드를 컴파일하면 아래의 leaq 인스트럭션으로 바뀐다.
연산 과정은 각 줄의 오른쪽에 적어놓았다.

```
scale:
  leaq    (%rdi,%rsi,4), %rax   // x + 4*y
  leaq    (%rdx,%rdx,2), %rdx   // z + 2*z = 3*z
  leaq    (%rax,%rdx,4), %rax   //(x+4*y) + 4*(3*z) = x + 4*y + 12*z
  ret
```

> Practice Problem 3.6
> %rbx에 p가 들어있고, %rdx에는 q가 들어 있다고 하자.
> 이때 아래의 테이블을 채우시오.
> | Instruction | Result |
> |-|-|
> |leaq 9(%rdx), %rax|q+9|
> |leaq (%rdx,%rbx), %rax |p+q|
> |leaq (%rdx,%rbx,3), %rax |3p+q|
> |leaq 2(%rbx,%rbx,7), %rax|8p++2|
> |leaq 0xE(,%rdx,3), %rax|3q+14|
> |leaq 6(%rbx,%rdx,7), %rax|p+7q+6|

> Practice Problem 3.7
>
> ```
> short scale3(short x, short y, short z) {
>   short t = 10y + z + y * x  ;
>   return t;
> }
> ```
>
> 위의 코드를 컴파일해서 아래와 같은 결과가 나왔을 때 빈 칸을 채우시오.
>
> ```
> short scale3(short x, short y, short z)
> x in %rdi, y in %rsi, z in %rdx
>
> scale3:
>  leaq (%rsi,%rsi,9), %rbx
>  leaq (%rbx,%rdx), %rbx
>  leaq (%rbx,%rdi,%rsi), %rbx
>  ret
> ```

요약하자면 leaq는 포인터를 다루기 위해 만들어졌다.
그래서 주소값에 연산을 해서 다른 주소값을 만들 수 있다.
이런 특성을 이용해서 간단한 연산을 하는데도 사용할 수 있다.

### Unary and Binary Operations

INC, DEC, NEG, NOT은 단항 연산자로, 하나의 피연산자를 원본이자 목적지로 사용한다.
단항 연산자는 메모리, 레지스터 어느 곳에서도 가능하다.
예를 들어서 `incq (%rsp)`는 스택의 탑이 가리키는 메모리의 값을 증가시킨다.
이는 C에서 ++연산과 비슷하다.

그 외의 그룹은 이항 연산자로 2번째 피연산자는 원본이자 목적지로 사용된다.
이들은 C에서 `x += y`와 유사하다.
이 이항 연산자들은 교환법칙이 성립하지 않는다.
예를 들어서 `subq %rax, %rdx`는 %rdx - %rax를 %rdx에 넣는다.
이를 `subq %rdx, %rax`로 바꾸면 계산 결과가 바뀔 뿐더러, 저장되는 위치도 달라진다.
또한 %rax 위치에는 상수, 메모리, 레지스터가 모두 올 수 있는 반면, %rdx는 값을 저장해야 하므로 메모리와 레지스터만 올 수 있다.
그리고 MOV처럼 두 피연산자가 모두 메모리가 될 수 없다.

여기서 잠깐 연산자가 2개의 메모리를 피연산자로 사용하는 경우를 알아보자.
당연하게도 메모리에서 연산이 일어날 수 없다.
연산은 프로세서에서 일어난다.
그러므로 프로세서가 메모리 값을 읽어들이고, 연산을 진행한 다음, 다시 메모리로 결과를 보내줘야 한다.
만약 피연산자에 하나라도 레지스터가 들어있다면 자연스럽게 프로세서를 거치므로 이런 걱정이 없다.
하지만 레지스터를 포함하지 않는다면 연산이 불명확해지므로 이를 막은 것이다.

다만 모든 프로세서에서 메모리간의 연산 인스트럭션을 막은 것은 아니다.
프로세서와 어셈블리어를 만들때 내부적으로(implicit) 알아서 처리하도록 인스트럭션을 만든다면 충분히 해결할 수 있다.
x86-64도 모든 메모리간의 인스트럭션을 막은 것은 아니다.
명시적이진 않지만 push나 pop은 스택 메모리를 사용하므로, 메모리간의 연산이지만 막혀있지 않다.
이들은 내부적으로 %rsp를 사용해서 해결할 뿐이다.
결국 메모리간의 연산은 설계로 발생하는 제한이다.
이를 그대로 유지하는 이유는 호환성 때문이다.
조금 불편할 수는 있지만 메모리값이 프로세서를 거쳐서 연산되어야 한다는 점을 생각하면 합리적이다.
우리는 직접 에셈블리 코드를 작성하는 것이 아니라 바뀐 코드를 이해하는 것만으로 충분하므로 큰 문제는 아니다.

> Practice Problem 3.8
> 아래와 같은 값이 메모리 주소와 레지스터에 저장되어 있다.
>
> | Address | Value | Register | Value |
> | ------- | ----- | -------- | ----- |
> | 0x100   | 0xFF  | %rax     | 0x100 |
> | 0x108   | 0xAB  | %rcx     | 0x1   |
> | 0x110   | 0x13  | %rdx     | 0x3   |
> | 0x118   | 0x11  |          |       |
>
> 이때 아래의 인스트럭션의 결과가 저장되는 메모리나 레지스터의 위치와, 그 안에 들어있을 값을 적으시오.
>
> | Instruction              | Destination | Value |
> | ------------------------ | ----------- | ----- |
> | addq %rcx, (%rax)        | 0x100       | 0x100 |
> | subq %rdx, 8(%rax)       | 0x108       | 0xA8  |
> | imulq %16, (%rax,%rdx,8) | 0x118       | 0x110 |
> | incq 16(%rax)            | 0x110       | 0x14  |
> | decq %rcx                | %rcx        | 0x0   |
> | subq %rdx, %rax          | %rax        | 0xFD  |

### Shift Operations

마지막 그룹은 시프트 연산으로, 첫 번째로 시프트하려는 크기를 주고, 두 번째로 시프트하려는 값을 적는다.
이때 시프트하려는 크기는 상수를 쓰거나, 1바이트 레지스터인 %cl을 쓴다.
여기서 다른 인스트럭션과 다르게 %cl 하나만을 피연산자로 사용한다는 점이 특이하다.
또한 시프트하려는 값의 크기에 따라서 시프트 크기가 달라진다.
w비트를 시프트할 때 %cl의 하위 m비트만을 사용하는데, 이때 $w = 2^m$이 되도록 m을 선택한다.
예를 들어서 %cl이 0xFF일 때, salb는 7만큼 움직이고, salw는 15, sall은 31, salq는 63만큼 시프트한다.

시프트 연산은 산술, 논리형 연산이 존재한다.
좌측 시프트는 SAL, SHL 모두 동일한 효과로 우측을 0으로 채운다.
반면 우측 시프트는 둘의 효과가 다르다.
SHR은 좌측을 논리형으로(0) 채우고, SAR은 좌측을 부호 비트로 채운다.

> Practice Problem 3.9
> 아래의 C 함수를 어셈블리 코드로 만든다고 하자.
>
> ```
> long shift_left4_rightn(long x, long n)
> {
>     x <<= 4;
>     x >>= n;
>     return x;
> }
> ```
>
> 여기서 x와 n이 레지스터 %rdi와 %rsi에 저장되어 있다.
> 아래의 어셈블리 코드를 완성하시오.
>
> ```
>   long shift_left4_rightn(long x, long n)
>   x in %rdi, n in %rsi
>
> shift_left4_rightn:
>   movq %rdi, %rax     // Get x
>   salq $4, %rax       // x <<= 4
>   movl %esi, %ecx     // Get n (4 bytes)
>   sarq %cl, %rax      // x >>= n
> ```

마지막으로 아래의 예시는 C코드를 어셈블리 코드로 바꾼 것이다.
역시ㅓ 앞서 배운 인스트럭션으로 계산이 진행된다.

```
(a) C code
long arith(long x, long y, long z)
{
    long t1 = x ^ y;
    long t2 = z * 48;
    long t3 = t1 & 0x0F0F0F0F;
    long t4 = t2 - t3;
    return t4;
}
(b) Assembly code
    long arith(long x, long y, long z)
    x in %rdi, y in %rsi, z in %rdx
arith:
    xorq  %rsi, %rdi                // t1 = x ^ y
    leaq  (%rdx,%rdx,2), %rax       // 3*z
    salq  $4,    %rax               // t2 = 16 * (3*z) = 48*z
    andl  $252645135, %edi          // t3 = t1 & 0x0F0F0F0F
    subq  %rdi, %rax                // Return t2 - t3
    ret
```

> Practice Problem 3.10
>
> ```
> short arith3(short x, short y, short z)
> {
>     short p1 = y | z;
>     short p2 = p1 >>= 9;
>     short p3 = ~p2;
>     short p4 = p3 - y;
>     return p4;
> }
>
> short arith3(short x, short y, short z)
> x in %rdi, y in %rsi, z in %rdx
>
> arith3:
>   orq     %rsi, %rdx
>   sarq    $9, %rdx
>   notq    %rdx
>   movq    %rdx, %rax
>   subq    %rsi, %rax
>   ret
> ```
>
> 이 문제는 마지막 두 줄이 `movq %rdx %bax`, `subq %rsi, %rbx` 였다.
> 그런데 %bax라는 레지스터도 없고, 리턴값이 존재하는데도 %rax가 없었다.
> 아무래도 오류가 있는듯해서 마지막 두 줄을 고치고 답을 약간 수정했다.

> Practice Problem 3.11  
> 코드에 XOR이 없음에도, 생성된 코드에는  
> `xorq %rcx, %rcx`  
> 와 같은 어셈블리 코드가 생성되곤 한다.
> A. 위 인스트럭션의 효과를 설명하고, 위 코드가 삽입 되었을 때 장점을 서술하시오.  
> B. 위 코드를 어셈블리어로 좀 더 직접적으로 표현하시오.  
> C. 앞의 두 방법의 인코딩 시의 바이트 차이를 비교하시오.  
> Answer)  
> A. 레지스터를 초기화하는 효과가 있다.  
> B. `movq $0, %rcx`  
> C. ??????

### Special Arithmetic Operations

128비트에서 연산하는 기능을 설명하고 있는데 생략.

## 3.6 Control

지금까지는 간단한 동작만 하는 인스트럭션만 배웠었다.
앞으로는 조건문, 반복문, 스위치문 같이 조건에 따라 달라지는 구문을 알아보겠다.

### 3.6.1 Condition Codes

앞서 우리는 16개의 정수 레지스터를 알아봤었다.
CPU는 그 외에 Status Register(or Flag Register)도 존재한다.
상태 레지스터는 최근 프로세서의 연산 결과를 알려주는 Condition code(or Flag Bit)의 모임이다.
아래는 각 조건 코드의 이름과 사용법이다.

-   CF(Carry Flag): unsigned 수의 연산 결과가 비트 범위를 벗어나면 참이 된다.
-   ZF(Zero Flag): 연산 결과가 0이면 참이 된다.
-   SF(Sign Flag): 연산 결과가 음수면 참이 된다.
-   OF(Overflow Flag): signed의 연산 결과가 비트 범위를 벗어나면 참이 된다.

CF나 OF에서 범위를 벗어난다는 뜻을 알기 위해 CF를 예시로 설명해보겠다.
CF가 참이 되는 경우는 2가지다.
우선 두 수가 합해질 때 부호 비트보다 왼쪽에 더해야 하는 경우다.
예를 들어서 1111+0001=0000 같은 경우다.
이를 두고 양의 오버플로우(Positive Overflow)가 발생했다고 말한다.
또 다른 경우는 두 수의 차이를 계산할 때 부호비트 보다 왼쪽의 수를 빌리는 경우다.
예를 들어서 0000-0001=1111 같은 경우다.
이 경우는 음의 오버플로우(Negative Overflow)가 발생했다.
여기서 양의 오버플러우와 음의 오버플러우 구분이 헷갈릴 수 있는데, 범위를 최대값 위로 벗어나면 양의 오버플러우고, 최소값 아래로 벗어나면 음의 오버플러우다.
CF는 연산 결과가 비트 범위를 벗어나면 참이라고 했다.
다시 말해 CF는 오버플러우가 발생하면 1이 된다.

다음으로 CF와 OF를 확실하게 구분해야 한다.
CF는 unsigned, OF는 signed의 계산이 범위를 벗어났을 때 참이 된다는 것을 기억하자.

각 인스트럭션 마다 조건 코드에 다른 영향을 준다.
leaq는 주소를 옮기기 위해 쓰이므로 조건 코드에 영향을 주지 않는다.
그 외의 인스트럭션은 모두 조건 코드를 바꾼다.
예를 들어 XOR은 CF, OF를 0으로 세팅한다.
시프트 연산은 CF가 시프트 해서 없어지는 마지막 비트가 되고, OF는 0이 된다.
그 외의 인스트럭션도 각기 다른 방향으로 조건 코드를 바꾸는 규칙이 있다.

이처럼 대부분의 인스트럭션이 조건 코드에 영향을 준다.
그런데 우리는 조건을 사용하고 싶으므로 레지스터 값에 영향을 주지 않고 참거짓 여부만 알 필요가 있다.
다른 레지스터는 변경 시키지 않고 조건 코드만 변경하는 인스트럭션은 2개가 있다.

| Instruction     | Based on     | Description |
| --------------- | ------------ | ----------- |
| CMP $S_1, S_2$  | $S_2 - S_1$  | Compare     |
| TEST $S_1, S_2$ | $S_1 \& S_2$ | Test        |

CMP는, 레지스터의 계산을 수행하지 않는다는 점만 빼면, SUB 인스트럭션과 동일하다.
TEST 역시 AND와 조건 코드에 동일한 영향을 주지만, 레지스터의 계산은 일어나지 않는다.

### 3.6.2 Accessing the Condition Codes

조건 코드를 사용하는 방법은 3가지가 있다.
첫 번째는 조건 코드의 조합에 따라 0또는 1을 기록하는 일이다.
이를 수행하는 인스트럭션은 아래 표에 있다.

| Instruction | Synonym | Effect                               | Set condition                |
| ----------- | ------- | ------------------------------------ | ---------------------------- |
| sete D      | setz    | $ZF \rarr D$                         | Equal/zero                   |
| setne D     | setnz   | $\sim ZF \rarr D$                    | Not equal/not zero           |
| sets D      |         | $SF \rarr D$                         | Negative                     |
| setns D     |         | $\sim SF \rarr D$                    | Nonnegative                  |
| setg D      | setnle  | $\sim (SF \wedge OF) \& ~ZF \rarr D$ | Greater(signed >)            |
| setge D     | setnl   | $\sim (SF \wedge OF) \rarr D$        | Greater or equal (signed >=) |
| setl D      | setnge  | $SF \wedge OF \rarr D$               | Less (signed <)              |
| setle D     | setng   | $(SF \wedge OF) \| ZF \rarr D$       | Less or equal (signed <=)    |
| seta D      | setnbe  | $\sim CF \& \sim ZF \rarr D$         | Above (unsigned >)           |
| setae D     | setnb   | $\sim CF \rarr D$                    | Above or equal (unsigned >=) |
| setb D      | setnae  | $CF \rarr D$                         | Below (unsigned <)           |
| setbe D     | setna   | $CF \| ZF \rarr D$                   | Below or equal (unsigned <=) |

위 인스트럭션의 클래스를 SET 인스트럭션이라고 한다.
여기서 SET 인스트럭션의 뒤에 붙는 접미어는 데이터의 크기를 나타낸 것이 아니다.
예를 들어서 b는 below, l은 less를 의미하는 것이지, byte, long word를 의미하는 것이 아니다.
SET 인스트럭션은 조합에 따라 0이나 1을 1byte에 저장한다.
만약 1byte보다 큰 레지스터라면 하위 1byte에 저장한다.
이 경우 추가적으로 레지스터의 나머지 부분을 0으로 만들 필요가 있는데, 이 경우 movzbl을 사용하면 된다.

또한 Synonym 항목이 있는데, 이들은 인스트럭션의 유사어로 같은 기능을 하는 다른 이름이다.
예를 들어 setg는 setnle와 동일한 일을 한다.

아래는 C에서 long인 자료형 사이에 a < b를 계산하는 인스트럭션이다.

```
int comp(data_t a, data_t b)
    a in %rdi, b in %rsi

comp:
    cmpq %rsi, %rdi     // Compare a:b
    setl %al            // Set low-order byte of %eax to 0 or 1
    movzbl  %al, %eax   // Clear rest of %eax (and rest of %rax)
    ret
```

위 코드가 실행되는 단계를 하나씩 설명해보겠다.
우선 cmpq로 %rsi(b)와 %rsi(a)를 비교해서 조건 코드에 결과를 넣어준다.
그리고 setl로 0이나 1을 %al에 넣어준다.
여기서 %al은 %eax의 하위 1byte다.
추가로 %eax의 나머지 비트를 0으로 만들어야 하므로 movzbl을 사용했다.
여기서 MOV 클래스 인스트럭션의 특성상 %rax의 상위 4bytes도 0이 된다.
결과적으로 %rax의 최하위 비트를 제외한 모든 비트는 0이 되고, 마지막 비트만 setl의 결과에 따라 0이나 1이 된다.
그리고 ret로 %rax의 값을 반환한다.

SET 인스트럭션을 보면 조건 코드를 조합해서 조건을 구현하고 있다.
다시 말해서 조건문에 들어가는 <,>, =, !을 조건 코드로 만든다.
구체적으로 SET 인스트럭션이 어떻게 동작하기에 이런일이 가능한지 알아보자.
더 진행하기 전에 공통적으로 CMP를 사용했다고 생각하고, t = a - b라고 하겠다.

우선 "="를 구현하는 것은 sete다.
우선 a = b인 경우, t = 0이 되고 ZF는 1이 된다.
그리고 sete의 결과가 1이 된다.
이를 정리하면 sete는 a와 b가 같을 경우 1이 되고, 다를 경우 0이 된다.
그러므로 sete가 두 수가 같은지 확인하는 인스트럭션이다.
비슷한 논리로 setne는 두 수가 다름을 확인하는 인스트럭션이다.

다음으로 부등호를 알아보자.
우선 부호형에서 a < b인 경우를 생각해보자.
여기서 오버플로우가 일어나지 않았다면 OF는 0이다.
그리고 t = a - b < 0 일 때 SF가 1이 된다.
오버플로우가 일어났다면 OF는 1이다.
Positive Overflow가 일어난 경우는 t < 0이고 a > b가 된다.
반면 Negative Overflow가 일어난 경우 t > 0 이고 a < b가 된다.
그리고 a = b인 경우 오버플로우가 발생하지 않는다.
그래서 OF가 1일때 SF가 1인 경우는 a > b가 되고, SF가 0인 경우는 a < b가 된다.
결국 정리하면 a < b인 경우는 OF가 0이고 SF가 1인 경우, 그리고 OF가 1이고 SF가 0인 경우다.
그래서 setl이 SF ^ OF로 대소구분을 하는 것이다.

다음으로 비부호형인 경우를 살펴보자.
t = a - b < 0이면 음의 오버플로우가 일어난 경우다.
그러므로 CF가 1이 된다.
그러므로 a < b를 CF의 값으로만 알 수 있으므로 이를 setb에 사용한다.
여기서 등호가 필요한 경우는 ZF를 추가하는 것으로 간단하게 해결할 수 있다.

> Practice 3.13
> 다음 코드는 a와 b간의 비교 연산이다.
>
> ```
> int comp(data_t a, data_t b) {
>     return a COMP b;
> }
> ```
>
> a가 %rdi에 저장되어 있고, b가 %rsi에 저장되어 있다.
> data_t는 정수 자료형 중 하나로 정의되어 있으며, 부호형일 수도 비부호형일 수도 있다.
> 아래의 인스트럭션에서 data_t의 데이터 타입을 정하고, 어떤 COMP가 아래와 같은 코드를 만드는지 적으시오.  
> A.  
> cmpl %esi, %edi  
> setl %al  
> B.  
> cmpw %si, %di  
> setge %al  
> C.  
> cmpb %sil, %dil  
> setbe %al  
> D.  
> cmpq %rsi, %rdi  
> setne %al  
> Answer)  
> A.  
> data_t: int, COMP: <  
> B.  
> data_t: short, COMP: >=  
> C.  
> data_t: unsigned char, COMP: <=  
> D.  
> data_t: long, unsidned long, pointer, COMP: !=

> Practice 3.14
> 다음의 C 코드는 a와 0의 비교연산이다.
>
> ```
> int test(data_t a) {
>   return a TEST 0;
> }
> ```
>
> a는 %rdi에 저장되어 있다.  
> 아래의 인스트럭션에서 각각 data_t가 무슨 타입인지 결정하고, 어떤 TEST가 아래의 코드를 만들어내는지 적으시오.  
> A.  
> testq %rdi, %rdi  
> setge %al  
> B.  
> testw %di, %di  
> sete %al  
> C.  
> testb %dil, %dil  
> seta %al  
> D.  
> testl %edi, %edi  
> setle %al  
> Answer)  
> A.  
> data_t: long, TEST: >=  
> B.  
> data_t: short, unsigned short, TEST: == .
> C.  
> data_t: unsigned char, TEST: >  
> D.  
> data_t: int, TEST: <=

### 3.6.3 Jump Instructions

점프 인스트럭션은 다른 위치의 코드로 실행을 전환한다.
점프의 목적지는 어셈블리 코드에서는 label로 표시한다.
다음 어셈블리 코드를 보자.

```
    movq $0, %rax
    jmp .L1
    movq (%rax), %rdx
.Li:
    popq %rdx
```

위에서 jmp 인스트럭션은 .L1줄로 건너뛰고 프로그램을 다시 시작한다.
그래서 movq는 건너뛰고 popq를 실행한다.
그런데 목적 코드에서는 실제로 실행될려면 단순히 줄을 건너뛰는게 아니라 직접 어디록 가야할지 표시해야 한다.
그렇기 때문에 어셈블러는 모든 레이블이 붙은 인스트럭션의 주소를 정해서 점프 목적지(jump target)를 인코딩한다.

| Instruction   | Synonym | Jump condition | Description                  |
| ------------- | ------- | -------------- | ---------------------------- |
| jmp Label     |         | 1              | Direct jump                  |
| jmp \*Operand |         | 1              | Indirect jump                |
| je Label      | jz      | ZF             | Equal / zero                 |
| jne Label     | jnz     | ~ZF            | Not equal / not zero         |
| js Label      |         | SF             | Negative                     |
| jns Label     |         | ~SF            | Nonnegative                  |
| jg Label      | jnle    | ~(SF^OF)&~ZF   | Greater (signed >)           |
| jge Label     | jnl     | ~(SF ^ OF)     | Greater or equal (signed >=) |
| jl Label      | jnge    | SF^OF          | Less (signed <)              |
| jle Label     | jng     | (SF^OF)\|ZF    | Less or equal (signed <=)    |
| ja Label      | jnbe    | ~CF & ~ZF      | Above (unsigned >)           |
| jae Label     | jnb     | ~CF            | Above or equal (unsigned >=) |
| jb Label      | jnae    | CF             | Below (unsigned <)           |
| jbe Label     | jna     | CF \| ZF       | Below or equal (unsigned <=) |

jmp 인스트럭션은 2가지가 있다.
첫 번째는 Direct jump로, 어셈블리 코드에서 레이블로 정한 위치로 점프한다.
두 번째는 Indirect jump로, 레지스터나 메모리 위치를 읽어들이는 경우 사용한다.
앞서 .L1으로 점프하는 예제는 직접 점프로 레이블로 점프해야 하는 위치를 지정한다.
간접 점프는 _와 피연산자를 같이 사용한다.
여기서 피연산자에는 점프 위치가 들어있어야 한다.
예를 들어서 `jmp _%rax`는 %rax에 들어있는 목적지로 점프한다. 점프 위치가 메모리에 들어 있는 경우엔 %rax에 해당 메모리의 주소를 저장해서 `jmp \*(%rax)`로 사용한다.

여기서 설명하지 않았지만 표에 있는 점프는 조건부 점프다.
조건 코드에 들어 있는 값에 따라서 점프를 실행여부를 정한다.
어떤 조건 코드를 사용하는지는 위의 표를 참조하면 되는데, 이전의 조건 코드와 비슷한 이름 구조다.

### 3.6.4 Jump Instruction Encodings

어셈블러나 링커에서 점프 목적지를 인코딩할 때 가장 일반적인 방법은 PC relative다.
PC relative는 현재 인스트럭션의 주소와, 점프 목적지 다음 인스트럭션의 주소 차이를 인코딩해서 사용한다.
다른 방법은 "Absolute" 주소를 사용하는 방법으로, 대상을 직접적으로 명시한다.

아래는 PC relative addressing의 예다.

```
    movq    %rdi, %rax
    jmp     .L2
.L3:
    sarq
.L2:
    testq   %rax, %rax
    jg      .L3
    rep; ret
```

`jmp .L2`는 더 높은 주소로 이동하지만, `jg .L3`는 더 낮은 주소로 점프한다.
위 코드를 역어셈블한 코드는 아래와 같다.

```
0:  48 89 f8    mov    %rdi,%rax
3:  eb 03       jmp    8 <loop+0x8>
5:  48 d1 f8    sar    %rax
8:  48 85 c0    test   %rax,%rax
b:  7f f8       jg     5 <loop+0x5>
d:  f3 c3       repz retq
```

위 코드의 주석을 보면 2번째 줄의 jmp는 0x8이고, 5번째 줄에는 0x5다.
그런데 기계어 코드를 보면 0x03으로 인코딩 되었다.
이를 다음 인스트럭션의 주소인 0x05에 더하면 점프 목적지인 0x08을 구할 수 있다.
마찬가지로 2번째 점프의 목적지는 0xf8로 다음 줄의 주소인 0xd에 더하면 0x5가 된다.
이는 3번째 줄의 주소다.

위 예를 보면 알 수 있듯이 PC 상대 주소를 사용할 때 점프 다음의 인스트럭션 주소를 사용한다.
다음 코드는 위 코드를 링크 한 후에 역어셈블한 것이다.

```
4004d0: 48 89 f8      mov    %rdi,%rax
4004d3: eb 03         jmp    4004d8 <loop+0x8>
4004d5: 48 d1 f8      sar    %rax
4004d8: 48 85 c0      test   %rax,%rax
4004db: 7f f8         jg     4004d5 <loop+0x5>
4004dd: f3 c3         repz retq
```

인스트럭션이 다른 주소에 배치되었지만, 2번과 5번 줄의 목적지 값은 그대로다.
이처럼 PC 상대 방식으로 인코딩하면 메모리 주소를 옮겨도 코드를 수정할 필요가 없다.

> Practice Problem 3.15  
> A.
>
> ```
> 4003fa: 74 02     je      4003fe
> 4003fc: ff d0     callq   *%rax
> ```
>
> B.
>
> ```
> 40042f: 74 f4     je      400419
> 400431: 5d        pop     %rbp
> ```
>
> 2의 보수 표현으로 f4는 -12(c)이므로 400431-c = 400425
> C.
>
> ```
> 400543: 77 02     ja      400547
> 400545: 5d        pop     %rbp
> ```
>
> D. 아래 4005e8의 주소는 리틀 엔디안으로 작성되어 있다.(반대 순서로 읽어야 한다.)
>
> ```
> 4005e8: e9 73 ff ff ff    jmpg    400560
> 4005ed: 90                nop
> ```
>
> ffffff73의 2의 보수 표기법은 -141(8d)이므로, 4005ed-8d = 400560

### 3.6.5 Implementing Conditional Branches with Conditional Control

조건문을 C에서 기계어로 번역할 때 conditional과 unconditional 점프를 조합해서 사용한다.
아래의 (a)는 두 수의 차이를 구하는 코드다.
(a)에서 (c)로 변환되고 다시 이를 역어셈블해서 (b)로 바꾼 코드다.

```
(a) Original C code

long lt_cnt = 0;
long ge_cnt = 0;

long absdiff_se(long x, long y)
{
    long result;
    if(x<y){
        lt_cnt++;
        result = y - x;
    }
    else {
        ge_cnt++;
        result = x - y;
    }
    return result;
}

(b) Equivalent goto version

long gotodiff_se(long x, long y)
{
    long result;
    if (x >= y)
        goto x_ge_y;
    lt_cnt++;
    result= y-x;
    return result;
x_ge_y:
    ge_cnt++;
    result = x - y;
    return result;
}

(c) Generated assembly code
long absdiff_se(long x, long y)
x in %rdi, y in %rsi

absdiff_se:
    cmpq    %rsi, %rdi          Compare x:y
    jge     .L2                 If >= goto x_ge_y
    addq    $1, lt_cnt(%rip)    lt_cnt++
    movq    %rsi, %rax
    subq    %rdi, %rax          result=y-x
    ret                         Return
.L2:                            x_ge_y:
    addq    $1, ge_cnt(%rip)    ge_cnt++
    movq    %rdi, %rax
    subq    %rsi, %rax          result = x - y
    ret                         Return
```

(a)에는 if문이 있는데, 이는 (c)로 바뀔때 점프로 구현된다.
그리고 다시 이를 역어셈블하면 goto로 만들어져 있다.
(c)를 보면 jge가 `if(x >= y)` 역할을 하고 있다.
만약 조건을 만족한다면 .L2로 점프하고 아니라면 다음 줄을 실행한다.

아래는 일반적인 if문의 형태와 이를 어셈블리로 바꿨을 때의 형태다.

```
if (test-expr)
    then-statement
else
    else-statement
```

```
    t = test-expr;
    if (!t)
        goto false;
    then-statement
    goto done;
false:
    else-statement
done:
```

컴파일러는 else문과 then문을 분리해서 코드 블록을 만든다.

> Practice Problem 3.16
>
> ```
> void cond(short a, short *p)
> {
>   if (a && *p < a)
>       *p = a;
> }
> ```
>
> 위의 C코드를 어셈블리 코드로 바꾸면 아래처럼 된다.
>
> ```
> void cond(short a, short *p)
> a in %rdi, p in %rsi
>
> cond:
>   testq   %rdi, %rdi
>   je      .L1
>   cmpq    (%rsi), %rdi
>   jle     .L1
>   movq    %rdi, (%rsi)
> .L1:
>   rep; ret
> ```
>
> A.  
> 앞의 (b)처럼 goto를 사용해서 동일한 일을 하도록 코드를 작성하시오.
>
> ```
> void cond(short a, short *p) {
>   if (!a)
>       goto done;
>   if(a <= *p)
>       goto done;
>   *p = a;
> done:
>   return;
> }
> ```
>
> B.  
> C코드에는 if가 하나뿐이지만 어셈블리코드가 2개의 점프를 사용하는 이유를 설명하시오.
> Answer)  
> &&가 있으므로 양쪽의 조건이 모두 참이어야 한다.
> 그런데 점프는 조건을 만족하면 바로 그 주소로 이동한다.
> 그래서 점프를 하나만 사용하면 조건 하나만 만족해도 아래 코드가 실행된다.
> 결국 조건 2개를 사용하므로 점프를 2개 사용해야 한다.
> 그런데 점프된 곳에서 movq를 실행하면 여전히 하나의 조건만 만족해도 실행된다.
> 그러므로 점프된 곳에선 rep를 실행시킨다.

> Practice Problem 3.17
> 아래는 if문을 goto 코드로 바꾸는 또 다른 규칙이다.
>
> ```
>   t = text-expr;
>   if (t)
>       goto true;
>   else-statement
>   goto done;
> true:
>   then-statement
> done:
> ```
>
> A. 위의 새로운 규칙을 사용하여 absdiff_se를 goto 형식으로 다시 작성하시오.
>
> ```
> long gotodiff_se(long x, long y)
> {
>   long result;
>   if (x < y)
>       goto x_lt_y;
>   ge_cnt++;
>   result = x - y;
>   return result;
> x_ly_y:
>   lt_cnt++;
>   result = y - x;
>   return result;
> }
> ```
>
> B. 이 2가지 규칙 중에서 어느 다른 규칙을 우선할 이유가 있는가?
> 만약 else가 없는 경우 두 코드는 아래처럼 된다.
>
> ```
> // original rule
> t = test-expr;
> if (!t)
>   goto done;
> then-statement
> done:
> ```
>
> ```
> // new rule
> t = test-expr;
> if (t)
>   goto true;
> goto done;
> true:
>   then-statement
> done:
> ```
>
> 보다시피 새 규칙 쪽이 좀 더 복잡한 코드가 된다.
> 그러므로 if-else가 모두 있는 경우 둘의 차이는 없지만, else가 없는 경우 처음 방식이 더 좋다.

> Practice Problem 3.18
> 아래와 같은 어셈블리 코드가 있다.
>
> ```
> short test(short x, short y, short z)
> x in %rdi, y in %rsi, z in %rdx
>
> test:
>   leaq    (%rdx,%rsi), %rax
>   subq    %rdi, %rax
>   cmpq    $5, %rdx
>   jle     .L2
>   cmpq    $2, %rsi
>   jle     .L3
>   movq    %rdi, %rax
>   idivq   %rdx, %rax
>   ret
> .L3:
>   movq    %rdi, %rax
>   idivq   %rsi, %rax
>   ret
> .L2:
>   cmpq    $3, %rdx
>   jge     .L4
>   movq    %rdx, %rax
>   idivq   %rsi, %rax
> .L4:
> rep; ret
> ```
>
> 위 코드의 원본 C 코드를 아래에 작성하시오.
>
> ```
> short test(short x, short y, short z) {
>   short val = z+y-x;
>   if (z > 5) {
>       if (y > 2)
>           val = x/z;
>       else
>           val = x/y;
>   } else if (z < 3)
>       val = z/y;
>   return val;
> }
> ```

### 3.6.6 Implementing Conditional Branches with Conditional Moves

지금까지 우리는 조건문을 점프를 사용해서 구현했다.
그런데 조건문을 구현하는 다른 방식이 존재한다.
기존의 점프 방식을 생각해보자.
점프는 조건에 따라 한 가지 경로를 따라가도록 만들어졌다.
그런데 경로를 정하기 전에 다음 계산을 하지 않으므로 계산을 기다리는 시간 낭비가 생긴다.
그래서 나온 다른 방식은 모든 방식을 미리 계산하고 경우에 따라 하나만 선택하는 방식이다.
물론 이 방법은 미리 계산 가능한 수준에서만 가능하므로 제한적이다.
그렇지만 가능만 하다면 코드를 더 빠르게 동작하도록 만든다.
이런 동작이 가능하도록 하는 인스트럭션을 conditional move라고 한다.

아래는 conditional move를 사용하는 예제 코드다.

```
(a) Original C code
long absdiff(long x, long y)
{
    long result;
    if (x < y)
        result = y - x;
    else
        result = x - y;
    return result;
}

(b) Implementation using conditional assignment
long cmovdiff(long x, long y)
{
    long rval = y-x;
    long eval = x-y;
    long ntest = x >= y;
    /* Line below requires
       single instruction: */
    if (ntest) rval = eval;
    return rval;
}

(c) Generated assembly code
    long absdiff(long x, long y)
    x in %rdi, y in %rsi
absdiff:
    movq    %rsi, %rax
    subq    %rdi, %rax      rval = y-x
    movq    %rdi, %rdx
    subq    %rsi, %rdx      eval = x-y
    cmpq    %rsi, %rdi      Compare x:y
    cmovge  %rdx, %rax      If >=, rval = eval
    ret                     Return tval
```

(b)를 보면 y-x, x-y를 모두 미리 계산해서 rval, eval에 넣었다.
그리고 x,y 중 큰 수를 판단하고 맞다면 rval에 eval을 복사한다.
그리고 rval을 반환하는데, 결과적으로 두 수의 차이의 절대값을 구한다.
여기서 핵심은 y-x와 x-y를 미리 계산한 다음 cmovge에서 둘을 판별해서 사용한다는 것이다.

이전에 조건에 따라 분기를 나누는 방식을 conditional control transfer이라고 하고, 지금 방식은 conditional data transfer라고 한다.
conditional data transfer가 더 빠를 수 있는 이유를 이해하기 위해서는 프로세서의 동작 방식을 이해해야 한다.
프로세서는 파이프라인으로 성능을 높인다.
여기서 파이프라인이란 한 번에 하나의 명령을 실행하는 것이 아니라 여러 개의 명령어 실행을 시작하는 방식을 말한다.
하나의 명령은 여러 단계로 나뉘는데, 각 명령을 수행하는 부분이 다르다.
예를 들어 명령이 A, B, C로 나뉜다면 그 명령은 각각 X, Y, Z에서 실행된다.
그런데 A가 끝난다면 X는 명령이 모두 종료되기 전에는 아무 일도 하지 않는다.
이처럼 명령이 순차적으로 진행되면 중간에 아무 작업을 수행하지 않는 부분이 생긴다.
이때 다음 명령어를 시작하면 X에서도 일을 시작해서 속도를 향상시킬 수 있다.
이에 관해서는 4장과 5장에서 자세히 다룬다.

파이프라인에 인스트럭션을 채우려면 먼저 인스트럭션의 순서를 정해야 한다.
그런데 조건부 점프가 있으면 분기 조건이 계산되기 전에는 분기를 정할 수 없다.
프로세서는 점프 인스트럭션이 실행될지 추측하는 분기예측 회로가 있다.
만약 이 회로로 정확히 예측한다면 파이프라인에 인스트럭션이 미리 채워진다.
반면에 점프 예측에 실패한다면 이미 작업한 결과를 버리고 다시 파이프라인에 인스트럭션을 채워야 한다.
이러한 예측 오류는 약 15~30 클럭 사이클의 손실을 일으켜 프로그램의 성능을 저하시킨다.

일례로 앞의 absdiff 함수를 2가지 방법으로 성능을 측정해보았다.
이전의 점프를 사용한 경우를 먼저 계산해보자.
x < y는 매우 예측하기 어려워서 정확도가 50%에 불과하다.
분기 패턴을 쉽게 예측하는 경우에는 8클럭을 사용하고, 랜덤인 경우 17.5가 소모된다.
이 경우 예측을 실패했을 때 소모하는 클럭을 계산해보자.
오류 없이 코드 실행 시간을 $T_{OK}$, 오류 손실을 $T_{MP}$라고 하자.
평균 코드 실행 시간을 오류 확률 p로 나타내면 $T_{avg}(p) = (1 - p)T_{OK} + p(T_{OK}+T_{MP}) = T_{OK} + pT_{MP}$가 된다.
우리는 오류확률 p가 0.5, $T_{OK}$가 8 그리고 $T_{avg}(p)$가 17.5다.
그러므로 $T_{MP}$는 19가 된다.
결국 코드는 최단 8클럭 최장 27클럭 안에 실행된다.

반면 조건부 이동명령으로 코드를 테스트하면 8클럭이 필요하다.
이 방법은 미리 계산하기 때문에 어떤 분기로 나뉠지와 상관 없어서 성능이 더 좋게 나온다.

> Practice Problem 3.19  
> 어떤 코드가 분기 예측이 쉬울 때는 25 사이클이 필요하고, 랜덤인 경우 45 사이클이 필요하다.  
> A. 대략적인 손실은 얼마인가?  
> 40  
> B. 분기가 잘못 예측된 경우 얼마나 많은 사이클이 소모되는가?  
> 65

아래는 조건부 이동 인스트럭션이다.

| Instruction | Synonym | Move condition | Description                  |
| ----------- | ------- | -------------- | ---------------------------- |
| cmove S,R   | cmovz   | ZF             | Equal / zero                 |
| cmovne S,R  | cmovnz  | ~ZF            | Not equal / not zero         |
| cmovs S,R   |         | SF             | Negative                     |
| cmovns S,R  |         | ~SF            | Nonnegative                  |
| cmovg S,R   | cmovnle | ~(SF^OF)&~ZF   | Greater (signed >)           |
| cmovge S,R  | cmovnl  | ~(SF ^ OF)     | Greater or equal (signed >=) |
| cmovl S,R   | cmovnge | SF^OF          | Less (signed <)              |
| cmovle S,R  | cmovng  | (SF^OF) \| ZF  | Less or equal (signed <=)    |
| cmova S,R   | cmovnbe | ~CF & ~ZF      | Above (unsigned >)           |
| cmovae S,R  | cmovnb  | ~CF            | Above or equal (Unsigned >=) |
| cmovb S,R   | cmovnae | CF             | Below (unsigned <)           |
| cmovbe S,R  | cmovna  | CF \| ZF       | Below or equal (unsigned <=) |

MOVE 인스트럭션은 S에 메모리나 레지스터를 사용하고, 목적지 R에 레지스터를 적는다.
다른 인스트럭션은 길이를 지정해주지만, MOVE 인스트럭션은 레지스터의 이름으로 길이를 정한다.
어떻게 조건부 동작이 조건부 데이터 이동을 통해서 구현되는지 이해하기 위해 아래의 조건부 수식을 보자.

`v = test-expr ? then-expr : else-expr;`

이 수식으로 조건부 제어 전송으로 컴파일하면 아래처럼 된다.

```
    if (!test-expr)
        goto false;
    v = then-expr;
    goto done;
false:
    v = else-expr;
done:
```

아래는 조건부 이동에서 컴파일한 결과다.

```
v = then-expr;
ve = else-expr;
t = test-expr;
if (!t) v = ve;
```

위 코드에서 중요한 것은 결과와 상관없이 then-expr과 else-expr를 모두 실행한다는 점이다.
만약 둘 중에 하나라도 오류가 생긴다면 에러가 발생한다.

아래는 다른 예시다.

```
long cread(long *xp) {
    return (xp ? *xp : 0);
}
```

위 프로그램은 다음 어셈블리 코드에서 볼 수 있듯이, 포인터가 null이면 그 결과를 0으로 설정하기 위해 조건부 이동을 사용한다.

```
    long cread(long *xp)
    Invalid implementation of function cread
    xp in register %rdi
cread:
    movq    (%rdi), %rax    v = *xp
    testq   %rdi, %rdi      Test x
    movl    $0, %edx        Setve = 0
    cmove   %rdx, %rax      If x == 0,v = ve
    ret                     Return v
```

그렇지만 movq를 사용하는 \*xp가 테스트가 실패한 경우에도 발생한다.
그래서 null 포인터를 참조하는 에러가 발생한다.
이 경우 위의 코드는 분기 코드를 이용해서 컴파일 해야 한다.

결국 조건부 이동을 사용한다고 언제나 코드 효율을 개선할 수 있는 것이 아니다.
then-expr, else-expr에서 계산량이 많을 경우 오히려 낭비가 된다.
컴파일러는 낭비되는 계산량과, 분기 예측오류의 성능 손실을 저울질해서 방법을 정해야 한다.
하지만 이를 위한 정보가 충분하지 않다.
GCC는 add 인스트럭션처럼 매우 간단한 경우에만 조건부 이동을 사용한다.

> Practice Problem 3.20
> 아래의 C코드에서 어셈블리 코드를 만든다.
>
> ```
> #define OP ______   /* Unknown operator */
> short arith(short x) {
>     return x OP 16;
> }
> ```
>
> ```
>   short arith(short x)
>   x in %rdi
> arith:
>   leaq    15(%rdi), %rbx      temp = x+15
>   testq   %rdi, %rdi          test x
>   cmovns  %rdi, %rbx          if x >= 0, temp = x
>   sarq    $4, %rbx            result = temp >> 4(= x/16)
>   ret
> ```
>
> A. OP는 무슨 연산을 하는가? /  
> B. 어셈블리 코드에 주석을 달아서 동작을 설명하시오.

> Practice Problem 3.21
> 생략

### 3.6.7 Loops

C에는 for, while, do-while 같은 다양한 반복문이 있다.
기계어는 이와 대응되는 인스트럭션이 없다.
그 대신 조건부 테스트와 점프를 함께 사용해서 반복문을 구현한다.

#### Do-While

do-while의 기본적인 형태는 다음과 같다.

```
do
    body-statement
    while (test-expr);
```

이를 goto로 바꾸면 다음과 같다.

```
loop:
    body-statement
    t = text-expr;
    if (t)
        goto loop;
```

아래는 $n!$을 do-while로 구현한 것이다.

```
(a) C code
long fact_do(long n)
{
    long result = 1;
    do {
        result *= n;
        n = n-1;
    } while (n > 1);
    return result;
}

(b) Equivalent goto version
long fact_do_goto(long n)
{
    long result = 1;
loop:
    result *= n;
    n = n-1;
    if (n > 1)
        goto loop;
    return result;
}

(c) Corresponding assembly-language code
     long fact_do(long n)
    n in %rdi
fact_do:
    movl    $1, %eax    Set result = 1
.L2:                    loop:
    imulq   %rdi, %rax  Compute result *= n
    subq    $1, %rdi    Decrement n
    cmpq    $1, %rdi    Compare n:1
    jg      .L2         If >, goto loop
    rep; ret            Return
```

#### While

while문의 일반적인 형태는 다음과 같다.

```
while (test-expr)
    body-statement
```

while문을 기계어로 번역하는 방법은 다양하지만, 그 중 2가지 방법이 GCC에서 사용된다.
첫 번째 방법은 아래와 같다.

```
    goto test;
loop:
    body-statement
test:
    t = test-expr;
    if (t)
        goto loop;
```

위 방법을 보면 먼저 test를 한 후에 loop로 점프 여부를 정한다.
아래는 while을 사용해서 factorial 함수를 만든 것이다.

```
(a) C code
long fact_while(long n)
{
    long result = 1;
    while (n > 1) {
        result *= n;
        n = n-1;
    }
    return result;
}

(b) Equivalent goto version
long fact_while_jm_goto(long n)
{
    long result = 1;
    goto test;
loop:
    result *= n;
    n = n-1;
test:
    if (n > 1)
        goto loop;
    return result;
}

(c) Corresponding assembly-language code
  long fact_while(long n)
    n in %rdi
fact_while:
  movl    $1, %eax          Set result = 1
  jmp     .L5               Goto test
.L6:                    loop:
  imulq   %rdi, %rax        Compute result *= n
  subq    $1, %rdi          Decrement n
.L5:                    test:
  cmpq    $1, %rdi          Compare n:1
  jg      .L6               If >, goto loop
  rep; ret                  Return
```

> Practice Problem 3.24
>
> ```
> short loop_while(short a, short b)
> {
>   short result = ______;
>   while (______) {
>       result = ______;
>       a = ______;
>   }
>   return result;
> }
> ```
>
> 위의 C코드를 어셈블리어로 만들면 아래처럼 된다.
>
> ```
>   short loop_while(short a, short b)
>   a in %rdi, b in %rsi
> loop_while:
>   movl    $0, %eax
>   jmp     .L2
> .L3:
>   leaq    (,%rsi,%rdi), %rdx
>   addq    %rdx, %rax
>   subq    $1, %rdi
> .L2:
>   cmpq    %rsi, %rdi
>   jg      .L3
>   rep;    ret
> ```
>
> 위 코드의 빈 곳을 채우시오.  
> Answer)
>
> ```
> short loop_while(short a, short b)
> {
>   short result = 0;
>   while (a > b) {
>       result = result + (a * b);
>       a = a - 1;
>   }
>   return result;
> }
> ```

while문을 구현하는 2번째 방법은 아래처럼 do-while을 사용하는 것이다.

```
t = test-expr;
if (!t)
    goto done;
do
    body-statement
    while (test-expr);
done:
```

이는 아래처럼 goto 코드로 변환할 수 있다.

```
t = test-expr;
if (!t)
    goto done;
loop:
    body-statement
    t = test-expr;
    if (t)
        goto loop;
done:
```

아래는 fractional 함수를 2번째 방법으로 번역한 것이다.

```
(a) C code
long fact_while(long n)
{
    long result = 1;
    while (n > 1) {
        result *= n;
        n = n-1;
    }
    return result;
}

(b) Equivalent goto version
long fact_while_gd_goto(long n)
{
    long result = 1;
    if (n <= 1)
        goto done;
loop:
    result *= n;
    n = n-1;
    if (n != 1)
        goto loop;
done:
    return result;
}

(c) Corresponding assembly-language code
    long fact_while(long n)
    n in %rdi
fact_while:
    cmpq    $1, %rdi        Compare n:1
    jle     .L7             If <=, goto done
    movl    $1, %eax        Set result = 1
.L6:                    loop:
    imulq   %rdi, %rax      Conpute result *= n
    subq    $1, %rdi        Decrement n
    cmpq    $1, %rdi        Compare n:1
    jne     .L6             If !=, goto loop
    rep; ret                Return
.L7:                    done:
    movl    $1, %eax        Compute result = 1
    ret                     Return
```

> Practice Problem 3.26
> 아래와 같은 C 코드가 있다.
>
> ```
> long loop_while2(long a, long b)
> {
>   long result = ______;
>   while (______) {
>       result = ______;
>       b = ______;
>   }
>   return result;
> }
> ```
>
> GCC 컴파일러가 -01 옵션으로 아래와 같은 어셈블리 코드를 만든다.
>
> ```
>   a in %rdi, b in %rsi
> loop_while2:
>   testq   %rsi, %rsi
>   jle     .L8
>   movq    %rsi, %rax
> .L7:
>   imulq   %rdi, %rax
>   subq    %rdi, %rsi
>   test1   %rsi, %rsi
>   jg      .L7
>   rep; ret
> .L8:
>   movq    %rsi, %rax
>   ret
> ```
>
> 어셈블리 코드의 구조가 앞의 번역규칙과는 조금 다르다.
> 그렇지만 같은 동작을 하도록 만들 수는 있다.
> 위 코드의 빈 곳을 채우시오.  
> Answer)
>
> ```
> long loop_while2(long a, long b)
> {
>   long result = b;
>   while (b > 0) {
>       result = result * a;
>       b = b - a;
>   }
>   return result;
> }
> ```

#### For

for문의 일반적인 유형은 아래와 같다.

```
for (init-expr; test-expr; update-expr)
    body statement
```

위 코드는 대부분 아래의 while문과 동일한 동작을 한다.

```
init-expr;
while (test-expr) {
    body-statement
    update-expr;
}
```

for문으로 생성된 어셈블리 코드는 최적화 수준에 따라 while문의 2가지 번역 중 하나를 선택한다.
아래는 2가지 방법으로 만든 for문이다.

```
    init-expr;
    goto test;
loop:
    body-statement
    update-expr;
test:
    t = test-expr;
    if (t)
        goto loop;
```

```
    init-expr;
    t = test-expr;
    if (!t)
        goto done;
loop:
    body-statement
    update-expr;
    t = test-expr;
    if (t)
        goto loop;
done:
```

예를 들어서 fractional 함수를 for문으로 만드는 경우를 생각해보자.

```
long fact_for(long n)
{
    long i;
    long result = i;
    for (i = 2; i <= n, i++)
        result *= i;
    return result;
}
```

이 코드에서 for문의 각 구성요소를 아래처럼 구분할 수 있다.

```
init-expr       i = 2
text-expr       i <= n
update-expr     i++
body-statement  result *= i
```

이를 while문으로 변환하면 아래처럼 된다.

```
long fact_for_while(long n)
{
    long i = 2;
    long result = 1;
    while (i <= n) {
        result *= i;
        i++;
    }
    return result;
}
```

while을 goto버전으로 바꾸면 아래처럼 된다.

```
long fact_for_jm_goto(long n)
{
    long i = 2;
    long result = 1;
    goto test;
 loop:
    result *= i;
    i++;
test:
    if (i <= n)
        goto loop;
    return result;
}
```

그리고 어셈블리 코드 버전은 다음과 같다.

```
fact_for:
    movl    $1, %eax        Set result = 1
    movl    $2, %edx        Seti=2
    jmp     .L8             Goto test
.L9:                    loop:
    imulq   %rdx, %rax      Compute result *= i
    addq    $1, %rdx        Increment i
.L8:                    test:
    cmpq    %rdi, %rdx      Compare i:n
    jle     .L9             If <=, goto loop
    rep; ret                Return
```

결국 C에서 3개의 반복문 for, while, do-while 모두 하나 이상의 조건부 분기가 있는 코드로 번연된다는 것을 알았다.

### 3.6.8 Switch

Switch문은 정수 값에 따라 여러 개의 분기가 나뉜다.
Switch문은 점프 테이블이라는 자료구조를 사용한다.
점프 테이블은 원소 i에 switch문이 실행해야 할 동작을 구현하는 코드의 주소가 되는 배열이다.
점프 테이블의 장점은 if-else문과 달리 실행시간이 case의 수와 관계 없다는 점이다.
아래는 switch문의 예제다.

```
(a) Switch statement
void switch_eg(long x, long n, long *dest)
{
    long val = x;

    switch (n) {

    case 100:
        val *= 13;
        break;

    case 102:
        val += 10;
        /* Fall through */

    case 103:
        val += 11;
        break;

    case 104:
    case 106:
        val *= val;
        break;

    default:
        val = 0;
    }
    *dest = val;
}

(b) Translation into extended C
void switch_eg_impl(long x, long n, long *dest)
{
    /* Table of code pointers */
    static void *jt[7] = {
        &&loc_A, &&loc_def, &&loc_B,
        &&loc_C, &&loc_D, 8 &&loc_D, &&loc_def,
    };
    unsigned long index = n - 100;
    long val;

    if (index > 6)
        goto loc_def;
    /* Multiway branch */
    goto *jt[index];

loc_A: /* Case 100 */
    val = x * 13;
    goto done;
loc_B: /* Case 102 */
    x = x + 10;
    /* Fall through */
loc_C:  /* Case 103 */
    val = x + 11;
    goto done;
loc_D: /* Cases 104, 106 */
    val = x * x;
    goto done;
loc_def: /* Default case */
    val = 0;
done:
    *dest = val;
}

(c)
    void switch_eg(long x, long n, long *dest)
    x in %rdi, n in %rsi, dest in %rdx
switch_eg:
    subq    $100, %rsi              Compute index = n-100
    cmpq    $6, %rsi                Compare index:6
    ja      .L8                     If >, goto loc_def
    jmp     *.L4(,%rsi,8)           Goto *jg[index]
.L3:                            loc_A:
    leaq    (%rdi,%rdi,2), %rax     3*x
    leaq    (%rdi,%rax,4), %rdi     val = 13*x
    jmp     .L2                     Goto done
.L5                             loc_B:
    addq    $10, %rdi               x = x + 10
.L6                             loc_C:
    addq    $11, %rdi               val = x + 11
    jmp     .L2                     Goto done
.L7                             loc_D:
    imulq   %rdi, %rdi              val = x * x
    jmp     .L2                     Goto done
.L8                             loc_def:
    movl    $0, %edi                val = 0
.L2                             done:
    movq    %rdi, (%rdx)            *dest = val
    ret                             Return
```

위 예시는 switch문의 특이한 예시다.
우선 레이블이 연속적이지 않고(101, 105가 없다), 다중 레이블이 있으며(104, 106), case 안에 다른 case가 있다(102).
(b)를 보면 점프 테이블을 사용해서 case를 나눈다.
원본 C코드의 case값은 100, 102~104, 106이다.
컴파일러는 여기서 100을 빼서 0~6사이를 인덱스로 만들었다.
위를 보면 1,5 같이 존재하지 않는 경우엔 &&loc_def를 사용했다.

어셈블리 코드에서 점프 테이블은 아래처럼 만들어진다.

```
    .section    .rodata
    .align 8      Align address to multiple of 8
.L4:
    .quad .L3     Case 100: loc_A
    .quad .L8     Case 101: loc_def
    .quad .L5     Case 102: loc_B
    .quad .L6     Case 103: loc_C
    .quad .L7     Case 104: loc_D
    .quad .L8     Case 105: loc_def
    .quad .L7     Case 106: loc_D
```

이 선언은 .rodata(Read-only data) 안에 7개의 quad word가 존재하고, 각각이 레이블과 연관된 인스트럭션 주소다.

중요한 점은 점프 테이블을 사용하면 다중 분기를 효율적으로 구현할 수 있다는 것이다.
1번의 테이블 참조로 서로 다른 위치로 점프하는 것이 가능하다.

> Practice Problem 3.31
> 아래와 같은 C 함수에서
>
> ```
> void switcher(long a, long b, long c, long *dest)
> {
>   long val;
>   switch(a) {
>   case ______:           /* Case A */
>       c = ______;
>       /_ Fall through _/
>   case ______:            /* Case B */
>       val = ______;
>       break;
>   case ______:            /* Case C */
>   case ______:            /* Case D */
>       val = ______;
>       break;
>   case ______:            /* Case E */
>       val = ______;
>       break;
>   default:
>       val = ______;
>   }
>   *dest = val;
> }
> ```
>
> GCC는 아래와 같은 점프 테이블과 어셈블리 코드를 만든다.
>
> ```
> (a) Code
>   void switcher(long a, long b, long c, long *dest)
>   a in %rsi, b in %rdi, c in %rdx, d in %rcx
> switcher:
>   cmpq  $7, %rdi
>   ja      .L2
>   jmp     *.L4(,%rdi,8)
>   .section        .rodata
> .L7:
>   xorq    $15, %rsi
>   movq    %rsi, %rdx
> .L3:
>   leaq    112(%rdx), %rdi
>   jmp     .L6
> .L5:
>   leaq    (%rdx,%rsi), %rdi
>   salq    $2, %rdi
>   jmp     .L6
> .L2:
>   movq    %rsi, %rdi
> .L6:
>   movq    %rdi, (%rcx)
>   ret
>
> (b) Jump table
> .L4:
>   .quad   .L3
>   .quad   .L2
>   .quad   .L5
>   .quad   .L2
>   .quad   .L6
>   .quad   .L7
>   .quad   .L2
>   .quad   .L5
> ```
>
> 이때 위의 빈 칸을 채우시오.
>
> ```
> void switcher(long a, long b, long c, long *dest)
> {
>   long val;
>   switch(a) {
>   case ______:           /* Case A */
>       c = ______;
>       /_ Fall through _/
>   case ______:            /* Case B */
>       val = ______;
>       break;
>   case ______:            /* Case C */
>   case ______:            /* Case D */
>       val = ______;
>       break;
>   case ______:            /* Case E */
>       val = ______;
>       break;
>   default:
>       val = ______;
>   }
>   *dest = val;
> }
> ```

## 3.7 Procedures

프로시저는 지정된 인자와 리턴 값으로 특정 기능을 구현하는 코드를 말한다.
각 프로그래밍 언어에서 다양한 모습으로 구현되는데, 예를 들어 함수, 메소드, 서브루틴, 핸들러 등으로 불린다.

프로시저 P가 프로시저 Q를 호출하고, Q가 실행된 후 다시 P로 돌아간다고 하자.
이 경우 아래와 같은 일이 일어난다.

-   제어권 전달(Passing control): 프로그램 카운터(%rip)[^3]는 Q의 시작 주소로 설정하고, 리턴이 일어날 때까지 P의 인스트럭션이 Q를 따르도록 한다.
-   데이터 전달(Passing data): P는 Q에 하나 이상의 매개 변수를 전달할 수 있어야 하고, Q는 P로 하나의 값을 반환한다.
-   메모리 할당과 반납(Allocating and deallocating memory): Q는 시작할 때 지역 변수를 위해 공간을 할당하고, 반환될 때 해당 공간을 풀어준다.

### 3.7.1 The Run-Time Stack

대부분의 언어에서 프로시저 호출은, 스택의 후입선출 메모리 관리 방식을 사용한다.
이때 스택과 레지스터는 제어, 데이터 전송, 메모리 할당을 위해 필요한 정보를 저장한다.

이전에 설명한 것처럼 스택은 작은 주소 방향으로 확장되고, %rsp가 스택의 top을 가리킨다.
데이터는 스택의 pushq, popq를 사용해서 저장하거나 읽을 수 있다.

프로시저가 레지스터들이 저장할 수 있는 것보다 많은 공간을 필요하면 스택에 할당한다.
이 영역을 프로시저의 스택 프레임이라 한다.
우선 프로시저 P가 실행되면 필요한 공간이 스택에 할당된다.
그리고 Q를 호출하면 Return address를 스택에 만든다.
Return address에는 Q가 종료되었을 때 다시 코드를 시작할 위치가 들어있다.
다음으로 Q는 스택을 확장해서 자신이 실행될 공간을 할당한다.
이 공간 안에는 레지스터 값을 저장하고, 지역변수를 위한 공간 할당, Q가 호출하는 프로시저를 위한 인자가 들어간다.
대부분의 스택 프레임은 프로시저가 시작될 때 고정된 크기를 할당 받는다.

| Stack Frame Structure          |                     |
| ------------------------------ | ------------------- |
|                                | ...                 |
| Earlier Frames                 | ...                 |
|                                | ...                 |
| ------------------------------ | ------------------- |
|                                | ...                 |
|                                | Argument n          |
| Frame for calling function P   | ...                 |
|                                | Argument 7          |
|                                | Return address      |
| ------------------------------ | ------------------- |
|                                | Saved registers     |
| Frame for executing function Q | Local variables     |
|                                | Argument build area |

### 3.7.2 Control Transfer

함수 P에서 Q로 제어권을 전달하는 것은 PC(프로그램 카운터)를 Q의 시작 주소로 설정하면 된다.
그렇지만 나중에 Q가 반활할 때 P를 다시 실행할 위치를 기록해놔야 한다.
이는 call 인스트럭션으로 기록하는데, call Q로 기록한다.
call 인스트럭션은 돌아갈 주소 A를 스택에 푸시하고 PC를 Q의 시작 주소로 설정한다.
이렇게하면 A가 return address가 된다.
그리고 Q가 종료될 때 ret를 만난다.
ret 인스트럭션은 주소 A를 스택에서 pop하고 PC를 A로 정한다.
이렇게하면 Q가 종료되고 다시 P로 돌아간다.

| Instruction    | Description      |
| -------------- | ---------------- |
| call Label     | Procedure call   |
| call \*Operand | Procedure call   |
| ret            | Return from call |

역어셈블 코드에선 이들은 callq와 retq로 명명된다.
call 인스트럭션은 호출된 프로시저의 시작 주소를 목적지로 사용한다.
점프와 유사하게 목적지를 직접 레이블로 줄 수도 있고, \*를 사용해서 간접 호출도 가능하다.

아래는 multstore 함수 안에 mult2 함수를 사용하는 예시다.

```
void multstore(long x, long y, long *dest)
{
    long t = mult2(x, y);
    *dest = t;
}
```

```
0000000000400540 <multstore>:
 400540: push %rbx              # Save %rbx
 400541: mov %rdx,%rbx          # Save dest
 400544: callq 400550 <mult2>   # mult2(x,y)
 400549: mov %rax,(%rbx)        # Save at dest
 40054c: pop %rbx               # Restore %rbx
 40054d: retq                   # Return
```

```
long mult2(long a, long b)
{
    long s = a * b;
    return s;
}
```

```
0000000000400550 <mult2>:
 400550: mov %rdi,%rax          # a
 400553: imul %rsi,%rax         # a * b
 400557: retq                   # Return
```

위 코드는 multstore이 실행되다가 중간에 mult2가 실행된다.
이 부분은 제어권 전달이 일어나야 하므로 callq를 사용해서 구현되어 있다.
코드를 설명하려기 전에 프로그램 카운터(%rip)가 다음으로 실행될 코드 주소를 가리킨다는 것을 기억하자.
코드가 실행되기 전의 현재 상황을 알아보자.
우선 %rip는 0x400540으로 지정되어 있고, %rsp는 0x120이다.
%rip가 0x400540이란 것은 다음에 실행항 코드가 0x400540이란 의미다.
그러므로 `push %rbx`가 실행되고 %rip는 0x400541로 바뀌어서 다음 코드 실행을 준비한다.
이 같은 일이 반복되어서 코드가 실행되고, %rip에 0x400544가 들어간다.
이제 0x400544 줄이 실행되는데, 그 안에 `callq`가 들어 있다.
callq는 %rip를 뒤의 주소로 바꾸고, 스택의 top에 return address로 다음 줄을 저장한다.
그래서 %rip는 0x400550이 되고, 스택의 top에 0x400549가 들어가고 %rsp가 감소해서 0x118이 된다.
이때 스택에 들어간 0x400549는 return address로 나중에 코드가 돌아올 위치다.
코드가 차례로 실행되고 mult2의 마지막 줄인 retq를 실행하기 위해 %rip가 0x400557로 지정된다.
retq가 실행되었으므로 %rip가 return address가 된다.
그리고 return address를 가리키던 %rsp가 0x120으로 돌아온다.
다시 multstore로 돌아가서 0x400549부터 시작된다.

### 3.7.3 Data Transfer

프로세서가 호출될 때 제어권이 전달되고, 리턴이 일어나면 제어권이 돌아간다.
그리고 호출될 때 매개변수로 데이터 전달이 일어나고, 리턴될 때 값을 전달한다.
x86-64에서 프로시저로 데이터 전달하거나 받아오는 것은 레지스터를 통해 일어난다.
지금까지 우리는 %rdi, %rsi 같은 레지스터로 매개변수가 전달되는 것을 봤었다.
그리고 %rax의 값을 리턴 해주는 예시도 많이 봤다.
프로시저 P가 Q를 호출할 때, P의 변수들이 적당한 레지스터로 복사된다.
그리고 Q가 P로 돌아갈 때, P는 %rax의 값으로 리턴값을 사용할 수 있다.
앞으로 이 과정을 자세히 살펴보겠다.

x86-64는 최대 6개의 정수형 인자를 레지스터를 통해 사용할 수 있다.
아래는 비트의 수와 인자의 수에 따른 레지스터 사용 순서다.

| Operand Size(bits) | 1    | 2    | 3    | 4    | 5    | 6    |
| ------------------ | ---- | ---- | ---- | ---- | ---- | ---- |
| 64                 | %rdi | %rsi | %rdx | %rcx | %r8  | %r9  |
| 32                 | %edi | %esi | %edx | %ecx | %r8d | %r9d |
| 16                 | %di  | %si  | %dx  | %cx  | %r8w | %r9w |
| 8                  | %dil | %sil | %dl  | %cl  | %r8b | %r9b |

함수가 6개 이상의 정수형 인자를 사용하면, 나머지는 스택으로 전달된다.
프로시저 P가 Q를 호출할 때 n개의 인자를 사용한다고 하자.
이때 n > 6이라면 스택 프레임이 매개변수 7~n을 저장해야한다.
스택에 매개변수가 전달될 때, 데이터 사이즈는 8의 배수로 올림 처리한다.
모든 변수가 저장되면 P는 call 인스트럭션을 사용해서 제어권 전달을 할 수 있다.
여기서 Q가 다시 변수가 7개 이상인 함수를 호출한다면, 스택 프레임에서 Argument build area 영역에 넘친 변수를 저장한다.

아래는 데이터 전달이 일어나는 코드의 예시다.

```
(a) C code
void proc(long  a1, long  *a1p,
          int   a2, int   *a2p,
          short a3, short *a3p,
          char  a4, char  *a4p)
{
    *a1p += a1;
    *a2p += a2;
    *a3p += a3;
    *a4p += a4;
}
(b) Generated assembly code
    void proc(a1, a1p, a2, a2p, a3, a3p, a4, a4p)
    Arguments passed as follows:
        a1  in %rdi         (64 bits)
        a1p in %rsi         (64 bits)
        a2  in %edx         (32 bits)
        a2p in %rcx         (64 bits)
        a3  in %r8w         (16 bits)
        a3p in %r9          (64 bits)
        a4  at %rsp+8       ( 8 bits)
        a4p at %rsp+16      (64 bits)
1 proc:
2 movq  16(%rsp), %rax      Fetch a4p   (64 bits)
3 addq  %rdi, (%rsi)        *a1p += a1  (64 bits)
4 addl  %edx, (%rcx)        *a2p += a2  (32 bits)
5 addw  %r8w, (%r9)         *a3p += a3  (16 bits)
6 movl  8(%rsp), %edx       Fetch a4    ( 8 bits)
7 addb  %dl, (%rax)         *a4p += a4  ( 8 bits)
8 ret                       Return
```

위 코드에서 처음 6개의 변수는 레지스터로 전달된다.
그리고 나머지 2개는 스택으로 전달된다.
a4는 %rsp+8, a4p는 %rsp+16에 저장돼 있다.
다시 말해 스택 탑 위에 a4가 있고 그 위에 a4p가 있다.
그리고 %rsp가 가리키는 곳에 return address가 들어가 있다.

> Practice Problem 3.33
> procprob 함수는 4개의 변수 u, a, v, b를 가지고 있다.  
> 각각은 부호형이거나 포인터로 각기 크기가 다르다.  
> 코드가 아래처럼 되어 있을 때
>
> ```
> *u += a;
> *v += b;
> return sizeof(a) + sizeof(b);
> ```
>
> 위 코드는 아래처럼 컴파일 된다.
>
> ```
> procprob:
>   movslq  %edi, %rdi
>   addq    %rdi, (%rdx)
>   addb    %sil, (%rcx)
>   movl    $6, %eax
>   ret
> ```
>
> 4개의 매개변수의 순서와 자료형을 정하시오.  
> 여기서 답은 2가지가 있다.  
> Answer)  
> 우선 데이터가 들어있는 순서는 아래처럼 된다.  
> 여기서 경우의 수가 2가지 있을 수 있다.
> ||%edi|%sil|%rdx|%rcx|
> |-|-|-|-|-|
> |1|a|b|u|v|
> |2|b|a|v|u|
>
> 자료형은 위 경우의 수에 따라 나뉘는데 1의 경우만 적겠다.
> a는 4바이트이므로 int가 된다. 그리고 *u가 long이므로, u는 long *가 된다.
> 마지막에 6이 반환되는 것을 보면 b의 사이즈는 2바이트이므로 b는 short가 된다.
> 그리고 *v는 addb를 통해 1바이트라는 것을 알 수 있다.
> 그래서 v는 char *다.

### 3.7.4 Local Storage on the Stack

지금까지 프로시저 예제는 대부분 레지스터 이상의 local storage가 필요하지 않았다.
그렇지만 때로는 local data를 메모리에 저장시켜야 하는데, 아래는 그 대표적 예시다.

-   레지스터 수가 부족하다.
-   지역변수에 &가 사용되어서, 변수의 주소를 생성할 수 있어야 한다.
-   배열 또는 구조체여서 참조를 사용해야 한다.

아래의 예시를 보자.

```
(a) Code for swap_add and calling function
long swap_add(long *xp, long *yp)
{
    long x = *xp;
    long y = *yp;
    *xp = y;
    *yp = x;
    return x + y;
}

long caller()
{
    long arg1 = 534;
    long arg2 = 1057;
    long sum = swap_add(&arg1, &arg2);
    long diff = arg1 - arg2;
    return sum * diff;
}

(b) Generated assembly code for calling function
long caller()
caller:
subq    $16, %rsp           Allocate 16 bytes for stack frame
movq    $534, (%rsp)        Store 534 in arg1
movq    $1057, 8(%rsp)      Store 1057 in arg2
leaq    8(%rsp), %rsi       Compute &arg2 as second argument
movq    %rsp, %rdi          Compute &arg1 as first argument
call    swap_add            Call swap_add(&arg1, &arg2)
movq    (%rsp), %rdx        Get arg1
subq    8(%rsp), %rdx       Compute diff = arg1 - arg2
imulq   %rdx, %rax          Compute sum * diff
addq    $16, %rsp           Deallocate stack frame
ret                         Return
```

(b)를 보면 어떻게 지역 변수를 위한 공간을 만드는지 알 수 있다.
스택 포인터의 값을 16 감소시켜서 스택 프레임을 위한 공간을 만든다.
%rsp의 값이 S라고 할 때, &arg1은 S에 있고 &arg2는 S+8에 있다.
그리고 코드를 진행해나가다가 마지막에 %rsp에 값을 16을 더해서 스택 프레임을 반환한다.
위 예시를 통해 스택 프레임 할당과 반환은 %rsp의 값을 조정해서 만든다는 것을 알 수 있다.

### 3.7.5 Local Storage in Registers

레지스터는 모든 프로시저가 공유한다.
그렇지만 프로시저(caller)가 다른 프로시저(callee)를 호출할 때, 나중에 사용할 레지스터 값을 덮어씌우진 않는다.
관습적으로 레지스터 %rbx, %rbp, %r12~15는 callee-saved register로 분류된다.
프로시저 P가 Q를 호출할 때, Q는 레지스터의 값들을 보존해야 한다.
그래야 Q가 반환할 때 그 값을 다시 사용할 수 있기 때문이다.
프로시저 Q는 해당 레지스터를 변경하지 않거나, 스택에 푸시해둔다.
그리고 리턴할 때 스택의 값을 pop해서 복구해준다.
이처럼 레지스터 값을 push 하는 것은 스택 프레임의 일부인 Saved register를 생성한다.
이 덕분에 P는 callee-saved register에 안전하게 값을 저장할 수 있고, Q를 호출해도 값이 변하지 않는다.

스택 포인터(%rsp)를 제외하고 다른 레지스터는 모두 caller-saved register로 분류된다.
Q는 이 레지스터를 자유롭게 변경할 수 있으므로, P는 호출하기 전에 먼저 데이터를 저장해야 한다.

```
(a) Calling function
long P(long x, long y)
{
    long u = Q(y);
    long v = Q(x);
    return u + v;
}
(b) Generated assembly code for the calling function
    long P(long x, long y)
    x in %rdi, y in %rsi
P:
    pushq %rbp            Save %rbp
    pushq %rbx            Save %rbx
    subq  $8, %rsp        Align stack frame
    movq  %rdi, %rbp      Save x
    movq  %rsi, %rdi      Move y to first argument
    call  Q               Call Q(y)
    movq  %rax, %rbx      Save result
    movq  %rbp, %rdi      Move x to first argument
    call  Q               Call Q(x)
    addq  %rbx, %rax      Add saved Q(y) to Q(x)
    addq  $8, %rsp        Deallocate last part of stack
    popq  %rbx            Restore %rbx
    popq  %rbp            Restore %rbp
    ret
```

위 예시를 보면 Q를 2번 호출한다.
Q(y)를 계산하는 동안엔 x를 저장해야 하고, Q(x)를 계산하는 동안엔 Q(y)를 저장해야 한다.
(b)를 보면 2개의 caller-saved register를 사용한다.
%rbp는 x를 보관하고, %rbx는 Q(y) 값을 저장한다.

### 3.7.6 Recursive Procedures

프로시저가 재귀적으로 호출되는 경우에도 동일한 일이 일어난다.
각 프로시저는 스택에 독자적인 공간을 만든다.
그래서 재귀적으로 호출이 일어나도 지역 변수는 서로 영향을 주지 않는다.

```
(a) C code
long rfact(long n)
{
    long result;
    if (n <= 1)
        result = 1;
    else
        result = n * rfact(n-1);
    return result;
}

(b) Generated assembly code
    long rfact(long n)
    n in %rdi
rfact:
    pushq %rbx                  Save %rbx
    movq  %rdi, %rbx            Store n in callee-saved register
    movl  $1, %eax              Set return value = 1
    cmpq  $1, %rdi              Compare n:1
    jle   .L35                  If <=, goto done
    leaq  -1(%rdi), %rdi        Compute n-1
    call  rfact                 Call rfact(n-1)
    imulq %rbx, %rax            Multiply result by n
.L35:                       done:
    popq %rbx                   Restore %rbx
    ret                         Return
```

위 예시를 보면 %rbx의 값을 스택에 푸시한다.
그리고 변수 n을 %rbx로 옮긴다.
원래 n이 들어 있던 %rdi는 연산에 사용하고, 마지막에 다시 n이 필요할 때 %rbx에서 꺼내 사용한다.

## 3.8 Array Allocation and Access

배열과 포인터 개념을 잘 모르는 사람을 위해 있는 챕터.
원래 C에서 배열과 포인터를 사용하던 사람이라면 한 번 읽고 지나가면 좋은 챕터라서 생략.

### 3.8.1 Basic Principles

### 3.8.2 Pointer Arithmetic

### 3.8.3 Nested Arrays

### 3.8.4 Fixed-Size Arrays

### 3.8.5 Variable-Size Arrays

## 3.9 Heterogeneous Data Structures

C는 struct와 union으로 새로운 자료형을 만들 수 있다.

### 3.9.1 Structures

struct은 여러 객체들을 하나의 객체로 묶어주는 자료형을 만든다.
구조체의 모든 컴포넌트는 메모리의 연속된 영역에 저장된다.
그리고 구조체의 포인터가 곧 첫 번째 바이트 주소가 된다.
구조체는 컴포넌트를 메모리 주소가 증가하는 방향으로 만든다.
그러므로 각 영역을 사용하려면 포인터에 적절한 값을 더해서 찾는다.

### 3.9.2 Unions

공용체는 하나의 객체가 다수의 자료형에서 참조될 수 있다.
문법은 구조체와 동일하지만, 각 영역이 같은 메모리를 참조한다는 점이 다르다.

```
struct S3 {
    char c;
    int i[2];
    double v;
};

union U3 {
    char c;
    int i[2];
    double v;
}
```

여기서 메모리를 차지하는 용량을 생각해보자.
S3는 char(1byte), int(4bytes), double(8bytes)이므로 총 17bytes 만큼 필요하다.(실제로는 24bytes가 필요한데 그 이유는 잠시 후에 알아보겠다.)
U3는 8bytes만 있으면 되는데, 이는 char, int, double 모두 같은 메모리 주소를 공유하기 때문이다.
그래서 U3에서 c, i[0], v를 참조하는 것은 메모리 상에서 같은 위치를 참조하게 된다.
그래서 제일 큰 크기인 8bytes만 존재하면 된다.

공용체는 위와 같은 방법 때문에 치명적인 버그를 발생시킬 수도 있다.
그러므로 서로 같은 공간을 동시에 사용하지 않는 경우에만 사용하는 것이 좋다.
이런 경우는 메모리 총량을 절약할 수 있다.

### 3.9.3 Data Alignment

많은 컴퓨터 시스템은 기본 자료형에 쓸 수 있는 주소를 제한하고 있다.
그래서 객체의 주소가 K의 배수가 되도록 요구한다.
이런 alignment restriction은 프로세서와 메모리 시스템 간의 통신을 간단하게 만든다.
그래서 둘 사이의 인터페이스를 구성하는 하드웨어 설계를 간단하게 만든다.
예를 들어서 항상 8의 배수인 주소로 메모리의 8바이트를 읽는다고 하자.
만약 8의 배수 단위로 수가 끊어져 있다면, 각 수를 한 번에 읽을 수 있다.
그런데 두 주소에 수가 걸쳐져 있다면 메모리를 2번 읽어야 한다.
그러므로 수롤 8의 배수 단위로 끊어서 저장한다면 더 쉽게 수를 읽을 수 있게 된다.

정렬 규칙은 모든 K 크기의 데이터는 K의 배수를 주소로 사용한다.
예를 들어서 앞의 char, int, int, double을 저장하는 경우를 생각해보자.
char는 1byte이므로 그대로 저장한다.
int는 4bytes인데 그대로 저장하면 5bytes를 사용하게 된다.
그런데 우리는 4의 배수에 맞춰줘야 하므로 앞에 빈 3bytes를 추가해준다.
그래서 총 8(1+3+4)bytes를 사용하도록 만든다.
다음 int는 4bytes를 사용해서 12bytes가 된다.
마지막으로 double은 8bytes이므로 20bytes가 필요하다.
그렇지만 규칙에 따라 8의 배수가 되어야 하므로, 빈 4bytes를 추가해서 24bytes가 된다.

앞서 살펴본 어셈블리 코드를 보면 `.align 8` 같은 코드가 포함됐었다.
이는 8의 배수인 주소로 시작하도록 만드는데, 위의 정렬 규칙에 따르기 위해 삽입되는 코드다.

그러므로 구조체에서 멤버를 만드는 순서에 따라서 메모리 할당량이 달라진다.
아래의 두 구조체는 각각 12bytes, 9bytes 할당을 사용한다.

```
struct S1 {
    char c;
    int i;
    int j;
}

struct S2 {
    int i;
    int j;
    char c;
}
```

효과적으로 메모리 할당을 사용하려면 큰 것을 앞에 선언해야 한다.
작은 것을 앞에 두면 빈 공간을 채우기 위한 낭비가 생기기 때문이다.

그렇지만 위의 S2가 9bytes를 차지하는 것은 아니다.
구조체를 배열로 사용하는 경우도 고려해서 할당해야 하기 때문이다.
S2를 배열로 만든 경우를 생각해보자.
예를 들어 `S2 d[2];` 같은 경우를 보자.
만약 9바이트 할당으로 만든다면 각 원소의 정렬 요건에 맞지 않는다.
d[0] 뒤에 수가 오는 경우의 메모리 할당을 보면, 4+4+1+4 = 13bytes다.
그런데 4bytes 단위로 끊어져야 하므로 정렬 규칙에 어긋난다.
결국 S2도 뒤에 3bytes를 추가해서 12bytes로 만들어야 한다.
이로부터 나오는 규칙은 struct의 메모리 할당은 K 중 제일 큰 수의 배수가 되어야 한다.

규칙을 정리하자면 아래와 같다.

-   Kbytes 자료형의 주소는 K의 배수가 된다.
-   struct를 만들 때 크기가 큰 멤버가 앞에 와야 한다.
-   struct의 메모리 할당은 K 중 가장 큰 수의 배수가 된다.

> Practice Problem 3.44  
> 다음의 각 구조체 선언에서 각 필드의 offset, 구조체 전체의 크기, 정렬 요건을 정하시오.  
> A. struct P1 { int i; char c; int j; char d; };  
> B. struct P2 { int i; char c; char d; int j; };  
> C. struct P3 { short w[3]; char c[3]; };  
> D. struct P4 { short w[3]; char *c[3] };  
> E. struct P5 { struct P1 a[2]; struct P2 *p };  
> Answer)  
> A.
> |i|c|j|d|Total|Alignment|
> |-|-|-|-|-|-|
> |0|4|8|12|16|4|
>
> B.
> |i|c|d|j|Total|Alignment|
> |-|-|-|-|-|-|
> |0|4|5|8|12|4|
>
> C.  
> |w|c|Total|Alignment|
> |-|-|-|-|
> |0|6|10|2|
>
> D.
> |w|c|Total|Alignment|
> |-|-|-|-|
> |0|8|20|4|
>
> E.
> |a|p|Total|Alignment|
> |-|-|-|-|
> |0|32|36|4|

> Practice Problem 3.45  
> 다음의 구조체 선언에서,
>
> ```
> struct {
>   char       *a;
>   short       b;
>   double      c;
>   char        d;
>   float       e;
>   char        f;
>   long long   g;
>   void       *h;
> } foo;
> ```
>
> A. 이 구조체의 offset 바이트를 구하시오.  
> B. 이 구조체의 전체 크기를 구하시오.  
> C. 이 구조체에서 낭비되는 공간이 최소화되도록 재배치하고, offset과 전체 크기를 계산하시오.  
> Answer)  
> A.
>
> | Field  | a   | b   | c   | d   | e   | f   | g   | h   |
> | ------ | --- | --- | --- | --- | --- | --- | --- | --- |
> | Size   | 4   | 2   | 8   | 1   | 4   | 1   | 8   | 4   |
> | Offset | 0   | 4   | 8   | 16  | 20  | 24  | 32  | 40  |
>
> B. 48
> C.
>
> ```
> struct {
>   double c;
>   long long g;
>   float e;
>   char *a;
>   void *h;
>   short b;
>   char d;
>   char f;
> } foo;
> ```
>
> | Field  | c   | g   | e   | a   | h   | b   | d   | f   |
> | ------ | --- | --- | --- | --- | --- | --- | --- | --- |
> | Size   | 8   | 8   | 4   | 4   | 4   | 2   | 1   | 1   |
> | Offset | 0   | 8   | 16  | 20  | 24  | 28  | 30  | 31  |

## 3.10 Conbining Control and Data in Machine-Level Programs

### 3.10.1

### 3.10.2 Life in the Real World: Using the GDB Debugger

### 3.10.3 Out-of-Bounds Memory References and Buffer Overflow

버퍼(Buffer)는 한 곳에서 다른 곳으로 데이터를 이동할 때, 임시로 데이터를 저장하는 영역을 말한다.
앞서 스택에서 지역 변수를 저장할 공간을 만들곤 했는데 이 부분이 버퍼다.
스택의 문제점은 버퍼의 크기가 지정되어 있다는 점이다.
예를 들어서 24bytes를 배열을 위해 할당했다고 하자.
정수 배열이라면 6개까지 넣을 수 있다.
그런데 7번째 값을 적게 된다면 Return address를 침범하게 된다.
그래서 Return address가 변경되고 오류가 발생한다.
이처럼 버퍼의 범위를 벗어나서 생기는 오류를 Buffer Overflow라고 한다.
주로 이 문제가 발생하는 곳이 스택이므로 Stack Overflow라고도 불린다.

버퍼 오버플로우의 치명적인 점은 보안 문제를 일으킨다는 점이다.
먼저 리턴 주소값을 변경시켜서 탐색코드를 실행시킨다.
탐색코드는 쉘 프로그램을 실행하고 운영체제 기능을 쓸 수 있게 한다.
또한 허용되지 않은 기능을 실행시키고, 스택을 복구하거나, ret를 한 번 더 실행해서 정상적인 리턴이 발생한 것처럼 위장하기도 한다.

| RAM          |
| ------------ |
| Program code |
| Data         |
| Heap         |
| Free Store   |
| Stack        |

-   Program code: 실행할 프로그램 코드가 저장되는 공간이다. CPU는 코드 영역의 명령을 하나씩 가져가서 처리한다. 프로그램이 시작하고 종료될 때까지 메모리에 계속 남아 있다.
-   Data: 프로그램의 전역 변수와 정적 변수가 저장되는 영역이다. 프로그램이 시작하면 할당되고, 프로그램이 종료될 때 소멸된다.
-   Heap: 프로그래머가 직접 공간을 할당 해제하는 공간이다. malloc(), new 로 메모리를 할당하고, free(), delete로 메모리를 해제한다.
-   Stack: 함수 호출 시 생성되는 지역 변수와 매개 변수가 저장되는 영역이다. 함수의 호출 정보를 스택 프레임이라고 한다. push와 pop으로 데이터를 저장하고 읽을 수 있다. 함수가 종료되면 메모리가 해제된다.

---

[^1]인스트럭션은 컴퓨터에게 시키는 일의 단위다. 어셈블리어는 두 수를 더하거나, 데이터를 옮기거나, 비교하는 등의 일을 할 수 있다. 이런 일이 가능한 이유는 프로세서에 기본적으로 내장된 명령이 있기 때문인데, 이들을 인스트럭션이라고 한다.
[^2]CPU가 계산중인 값을 저장하는데 사용하는 데이터 저장 장치다. 그 중에서 범용 레이스터는 데이터와 주소를 모두 저장할 수 있다.
[^3]프로그램 카운터는 프로세서 내부의 레지스터 중 하나로, 다음에 실행할 명령어의 주소가 들어있다.

[^1]Processor는 "컴퓨터 시스템을 통제하고, 프로그램의 연산을 실행하고 처리하는 장치"를 말한다. 쉽게 말해 CPU를 말한다.
