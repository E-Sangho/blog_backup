---
layout: post
title: Fetch API
date: Sun Feb 13 23:23:30 JST 2022
categories:
tag:
toc: true
---

## AJAX

### What is AJAX?

AJAX은 Asynchronous JavaScript and XML의 약자로, JavaScript와 XML을 사용해서 비동기적으로 데이터를 교환하는 방법이다.
간단히 말해 브라우저에서 JavaScript로 데이터를 요청하면, 서버에서 XML로 데이터를 전송해주는 법이다.
다만 AJAX라는 이름은 오해의 여지가 있는 이름이다.
XML이라 명시했지만 AJAX는 XML 이외의 다른 형태의 데이터도 전송 가능하다.
그래서 대부분 JSON으로 데이터를 보내고 XML은 사용하지 않는다.
이를 보면 AJAX의 이름을 바꿔야 하겠지만, AJAX는 XML을 사용하는 기법이라기 보다는 고유명사처럼 사용된다.
JavaScript를 사용해서 데이터를 비동기적으로 통신하는 방법을 일컬어서 AJAX라고 부르는 것이다.
결국 AJAX의 핵심은 **Ascynchronous JavaScript**로, 자바스크립트로 비동기적으로 데이터를 교환하는 방법은 모두 AJAX라고 생각할 수 있다.

### How AJAX Works

AJAX 이전엔 웹브라우저가 정보를 요청하면 서버에선 해당 페이지를 전체를 전달했다.
그런데 이 방법은 굉장히 비효율적이었다.
서버는 작은 변화만 있어도 새로 HTML 파일을 생성해야하고, 브라우저는 이를 새로 랜더링 해야 했기 때문이다.
심지어 새로 만든 페이지를 돌려받기 전에는 빈 페이지를 봐야 하므로 로딩도 오래 걸렸다.
이런 문제는 웹 페이지와 데이터가 동기화 되어 있기 때문에 생긴다.
페이지의 디자인과 데이터가 하나로 묶여 있기 때문에 데이터의 변환이 일어나면 페이지 디자인도 새로 수정해야 하는 것이다.

AJAX는 이를 해결하기 위해 디자인과 데이터를 분리한다.
우선 디자인으로 형태만 만들어두는데, 나중에 데이터를 추가할 공간을 만들어 둔다.
그리고 데이터를 받아오면 이를 디자인에 추가해서 보여준다.
예를 들어서 SNS를 생각해보자.
SNS를 보면 각 계정마다 웹 페이지의 형태는 거의 동일하다.
하나 다른 점이라면 포스팅되는 내용인데, 자세히 살펴보면 모두 같은 디자인으로 이뤄져있다.
결국 디자인은 같지만 받아오는 데이터에 따라 다르게 표시된다는 것이다.

클라이언트가 서버에 페이지를 요청하면 HTML, CSS가 전달된다.
브라우저는 이 파일들로 디자인 형태를 만드는데, 그 안에는 데이터가 들어올 경우 보여줄 공간이 있다.
그 후 HTML은 JavaScript 파일을 요청해서 실행하게 된다.
JavaScript는 데이터를 요청하는 내용이 들어 있는데, 보통 버튼을 클릭하거나 페이지를 불러올 때 실행된다.
서버에서는 요청에 맞는 데이터를 반환하고, 이를 비워둔 공간에 추가한다.

이 방식의 가장 큰 장점은 웹 페이지의 일부만 수정한다는 점이다.
그 덕분에 페이지를 새로고침 하지 않아 사용자의 편이성이 증가한다.
뿐만 아니라 서버 입장에서도 일일이 새로 만드는 낭비를 하지 않는다.

### Using AJAX

AJAX를 사용하려면 몇 가지 선택지가 있다.
대표적으로 XMLHttpRequest, fetch API, Axios jQuery 등이 있다.
각기 방법은 다르지만 핵심은 요청을 보낸다는 사실과, 받은 데이터를 사용한다는 점이다.

## Asynchronous Function

프로그래밍은 일반적으로 이전의 연산이 끝나야 다음 코드가 실행된다.
그렇지만 JavaScript 코드 중에는 연산이 끝나지 않았는데도 다음 코드가 먼저 실행되는 경우가 있다.
이들을 비동기 함수라고 하며, 비동기 함수의 연산이 끝나기도 전에 다음 함수가 실행된다.
당연하게도 비동기 함수가 포함되면 프로그램의 작동 순서가 비직관적이게 된다.
위의 코드가 아래보다 먼저 작동할 것이란 예상과 다르게 뒤죽박죽으로 섞여서 사용이 어려워지기 때문이다.
그럼에도 불구하고 JavaScript에서 비동기 함수를 사용하는 이유는 JavaScript가 싱글 스레드 언어이기 때문이다.

JavaScript가 싱글 스레드라는 것은 곧 Call Stack이 하나 뿐이라는 의미다.
코드가 진행되면서 실행해야 하는 함수는 Call Stack에 쌓이는데, 만약 처리가 느린 함수가 들어오면 다음 작업이 시작되지 못하고 막혀버린다.
이 특성은 웹에서 치명적인 것이 데이터 전송과 수신이 빈번하게 일어나기 때문이다.
만약 데이터를 요청했다면 그에 대한 응답을 받기 전에는 코드가 멈추게 되는데, 매 번 이런 일이 발생한다면 지나치게 느리게 작동할 것이다.
JavaScript는 이렇게 시간이 오래 걸리는 함수를 모두 비동기 함수로 만들었다.
그래서 시간이 걸리는 함수가 포함되더라도 다음 단계의 코드를 실행시킨다.

잠시 JavaScript가 런타임 과정을 살펴보자.
JavaScript 코드가 실행될 때, Call Stack, API, Event Loop, Callback Queue를 사용한다.
코드가 진행되면서 Call Stack에 함수가 쌓이게 된다.
만약 동기함수라면 바로 처리되어서 결과가 나타나지만, 비동기 함수라면 조금 다른 경로를 거친다.
Call Stack에서 비동기 함수가 처리되어야 할 순번이 되면, Call Stack은 비동기 함수를 API로 넘겨준다.

API는 환경에 따라 다르지만, 웹이라면 Web API가 될 것이다.
API는 JavaScript 외부에 존재하는 것으로 C 같은 low-level 언어로 작성되어 있다.
그래서 JavaScript에서 할 수 없는 일도 할 수 있고 동시에 여러 일을 할 수도 있다.
또한 API는 기존 코드와 별개로 일을 처리하기 때문에 JavaScript가 싱글 스레드라는 단점을 보완해준다.

API가 비동기 함수의 처리를 끝내면 이를 다시 JavaScript에 돌려줘야 한다.
이를 위해서 Callback Queue와 Event Loop를 사용한다.
비동기 함수를 실행한 결과는 Callback Queue에 쌓인다.
그리고 Event Loop는 Call Stack이 비어 있는지 확인하고, 만약 비어 있으면 Callback Queue의 내용을 순서대로 Call Stack에 전달한다.
이렇게 해서 API로 건너갔던 함수의 결과가 다시 JavaScript 내부로 돌아오게 된다.

그런데 비동기 함수간의 순서가 중요한 경우가 있다.
순서대로 코드를 작성하더라도 비동기 함수의 특성상 작동하는 순서는 보장할 수 없다.
그렇기 때문에 Callback 함수를 사용하는데, 앞의 비동기 함수가 끝나면 실행할 함수를 Callback 함수로 전달하는 것이다.

문제는 Callback 함수도 결함이 있다는 점이다.
우선 함수 안에 함수가 반복되기 때문에 가독성이 안 좋다.
게다가 기존 코드를 수정하려면 굉장히 번거롭다.
이 때문에 Callback 함수를 사용하는 대신에 Promise를 사용한다.

## Promise

Promise는 가까운 미래에  
Promise는 비동기 작업의 완료, 실패에 관한 정보가 들어 있다.

## fetch API

결론부터 말하자면 AJAX를 사용하려면 **fetch API**를 사용하면 된다.
XMLHttpRequest 등의 다른 방식도 존재하지만 여러 단점 때문에 현재는 대부분 fetch를 사용한다.
XMLHttpRequest는 떨어지는 가독성, 이벤트 기반이라 event listener에 묶이는 등의 문제점이 존재한다.
이런 단점 때문에 사람들이 jQuery를 많이 사용했었는데, ES6에서 fetch API가 등장했다.
fetch API는 promise 기반으로 만들어졌기 때문에 사용하기 간편하고 가독성이 좋다.
게다가 기본적으로 내장되어 있어 별다른 라이브러리 없이 사용할 수 있다는 점도 큰 장점이다.

> let promise = fetch(url, [options])

-   url: 요청을 보낼 URL
-   [options]: method, header 등을 지정하는 변수

[options]에 아무 내용도 적지 않으면 GET 메소드로 요청이 이뤄지고, 해당 url로 부터 정보를 받아온다.
fetch()는 promise를 반환하는데, promise에는 요청이 성공적으로 처리되었는지를 확인할 수 있지만 아직 요청한 정보가 들어있진 않다.
네트워크 오류나 잘못된 요청일 경우 promise는 잘못된 요청이라는 응답을 보내준다.
이는 HTTP status code라고 불리는 것으로 확인할 수 있다.

fetch()가 반환한 promise는 안에 response를 포함하고 있다.
response를 사용해서 응답 내용을 사용할 수 있는데 아래와 같다.

-   response.text()
-   response.json()
-   response.formData()
-   resopnse.blob()
-   response.arrayBuffer()

그리고 반환된 내용이 프로미스이므로 .then을 사용하거나 async/await을 사용해서 다음 코드를 진행해야 한다.

[options]에 method를 설정해서 POST를 사용할 수도 있다.
그리고 headers에 추가적인 내용을 적어줄 수 있다.
