---
layout: post
title: "CS:APP Lab 0"
date: Fri Oct  1 11:10:17 JST 2021
categories: CS:APP
tag: Lab Lab0
toc: true
---
## Lab 0
CS:APP의 첫 번째 과제로 C언어를 잘 알고 있는 사람이라면 아무리 많아도 2~3시간 안에는 풀 수 있는 문제들이다. 그렇지만 C언어를 모르는 사람은 엄청나게 많은 시간이 들 수도 있다. 과제의 난이도가 어려운것이 아니라 C언어의 숙달도가 부족할 경우 이를 따로 배워야 하는 시간이 오래 걸리기 때문이다. 하지만 전혀 모르는 경우가 아니라면 아래의 설명을 보고 충분히 따라할 수 있는 수준이다.

## Overview
우선 **queue.h** 파일을 열어보면 아래와 같은 코드가 있다.
```
/* Linked list element */
typedef struct ELE {
    int value;
    struct ELE *next;
} list_ele_t;

/* Queue structure */
typedef struct {
    list_ele_t *head;  /* Linked list of elements */
} queue_t
```
이 파일을 보면 linked list로 queue를 구현했음을 알 수 있다. queue의 제일 앞 부분은 queue_t로 만들어져 있는데, 보면 알겠지만 head 밖에 없다. **이 부분에 head외의 다른 것을 더 넣어줘야 한다.** 그 외에 queue의 다른 원소들은 list_ele_t로 만들어져 있는데 vaule와 next로 이루어져 있다. 여기서 value는 queue의 값이고, next는 다음 list를 가르키는 pointer다. 이 부분은 별다른 수정은 필요 없다.

다음으로 **queue.c** 파일을 살펴보자. 이 파일에서 queue는 queue_t의 pointer다. 이 때, 2가지 경우를 추가해야 하는데 우선 **Null queue**는 pointer가 Null 값을 가르키는 것을 말한다. **empty queue**는 queue_t 구조를 제대로 가르키지만 head가 Null인 경우다. 이 두 경우를 포함해서 queue가 원소를 하나 이상 가질때도 제대로 작동하게 만들어야 한다.

## Programming Task
과제는 queue.h와 queue.c 파일을 고처 아래 기능을 작동하게 만들면 된다.

- q_new: Create a new, empty queue.
- q_free: Free all storage used by a queue.
- q_insert head: Attempt to insert a new element at the head of the queue (LIFO discipline).
- q_insert tail: Attempt to insert a new element at the tail of the queue (FIFO discipline).
- q_remove head: Attempt to remove the element at the head of the queue.
- q_size: Compute the number of elements in the queue.
- q_reverse: Reorder the list so that the queue elements are reversed in order.

그 외의 자세한 내용은 각 파일을 확인하면 된다. 아래 내용들은 위의 함수를 만들 때, 주의해야할 사항을 적어 놓은 것이다.

- q_insert, q_size는 단순하게 구현하면 O(n)의 복잡도가 된다. 이렇게 하면 과제가 요구하는 퍼포먼스 기준에 미달되기 때문에 O(1)으로, 즉 queue의 사이즈와 관계 없이 일정한 step으로 진행되게 만들어야 한다. 이는 **queue_t**에 새로운 것을 추가하고, list에 원소가 insert, remove, reverse가 될 때, 그 값을 잘 사용해야 한다.
- q_reverse를 만들 때, 추가적인 메모리 사용 없이 가능하게 만들어야 한다. 다시 말해 현재 주어진 list의 pointer만을 수정해서 작동시켜야 한다. 
- 프로그램은 1,000,000개의 원소로 이루어진 queue로 테스트를 진행한다. 그러므로 재귀함수를 사용한다면 오류가 생기게 된다.

## Test
커맨드 창에 `make`를 입력하면 파일을 컴파일해준다. 문제 없이 되었으면 queue를 다룰 수 있는 **qtest**라는 프로그램을 만든다. 사용 가능한 명령은 프로그램이 실행되는동안 `help`를 입력해서 확인할 수 있다. qtest를 실행하려면 커맨드 창에 `./qtest`라고 입력한다.

## Evaluation
평가는 14개의 테스트 케이스로 진행된다. `./driver.py`라고 입력하면 qtest를 실행해서 점수를 알려준다. 

## C cheatsheet

### typedef
C에서 struct를 사용할 때, `struct name { members };` 형태로 작성한다. 그리고 main 함수에서 `struct name variable_name`의 형태로 사용하게 된다. 여기서 struct를 계속 사용해야 하는 것이 번거롭다. typedef는 C언어에서 새로운 자료구조를 만들 때 사용한다. typedef를 쓰면 main 함수에서 매 번 struct를 사용해야하는 번거로움에서 벗어날 수 있다. 대신 typedef를 사용할 때는 alias(별칭)이 필요한데 다음과 같이 사용하면 된다.
```
typedef struct 구조체이름 {
    자료형 멤버이름;
} 구조체별칭;
```
여기서 구조체 이름과 구조체 별칭은 서로 겹쳐도 되지만 보통 구조체 이름 앞에 **_**를 붙여준다. 아래 예시를 보며 사용법을 알아보자.
```
typedef struct _Person {
    int age;
    int height;
    char[20] name;
} Person;

int main() {
    Person Jack;

    printf("age: ");
    scanf("%d", &Jack.age);
    printf("height: ");
    scanf("%d", &Jack.height);
    printf("name: ")
    scanf("%s", Jack.name);

    printf("age: %d\nheight: %d\nname: %s", Jack.age, Jack.height, Jack.name);

    return 0;
}
```
위에서 Jack이라는 사람을 선언할 때 자료형으로 Person만 써주었다. 이처럼 typedef를 사용하면 struct [구조체 이름] 형태를 벗어나 alias만으로 구조체 선언이 가능하다. 이때, 구조체 별칭만 사용하고 이름은 사용하지 않으므로 생략도 가능하다.
```
typedef struct {
    int age;
    int height;
    char[20] name;
} Person;

int main() {
    Person Jack;

    printf("age: ");
    scanf("%d", &Jack.age);
    printf("height: ");
    scanf("%d", &Jack.height);
    printf("name: ")
    scanf("%s", Jack.name);

    printf("age: %d\nheight: %d\nname: %s", Jack.age, Jack.height, Jack.name);

    return 0;
}
```

### Dynamic allocation
동적 메모리 할당은 프로그램이 실행 되는 동안 사용할 메모리 공간을 할당하는 것을 말한다. 이와 반대 되는 개념은 정적 메모리 할당인데 프로그램이 실행되기 전에 메모리 공간을 결정한다. 메모리 정적할당은 예를 들면 `char a[100];`과 같이 지정된 숫자 만큼의 메모리를 할당하는 것이다. 정적 메모리 할당의 장점은 프로그램이 실행되는 동안 해제되지 않고 운영체제가 알아서 메모리를 회수하므로 메모리 누수가 발생하지 않는다는 것이다. 대신 stack에 할당된 메모리여서 동적 할당에 비해 메모리 양이 적다. 또한 메모리 크기를 중간에 바꿀 수 없다.

다시 동적 메모리 할당으로 돌아가자. 동적 메모리 할당의 장점은 실행 시간 동안 할당하므로, 그 용량이 가변적이다. 대신 정해진 힙 영역을 넘어서는 메모리 할당은 이뤄지지 않는다. 그래서 사용 완료된 메모리는 회수하는 것이 좋은데, 프로그래머가 직접 해제해줘야 한다. 

C언어는 malloc 함수로 동적 할당하는데, 공간이 있다면 메모리 주소값을 반환하고 실패하면 NULL 값을 반환한다. malloc은 memory allocation의 약자로, **stdlib.h** 파일을 include 해줘야 사용할 수 있다.
| 함수 | 설명 |
|-----|-----|
| void * malloc ( size_t size ) | size 바이트의 메모리를 힙에서 할당하여 반환한다. |
| void free ( void * ptr ) | ptr이 가리키는 메모리를 해제한다. |
보다시피 malloc은 size_t 타입을 전달해 줘야 한다. 간단히 **sizeof**를 사용하면 원하는 값을 쉽게 전달할 수 있다. malloc 함수의 리턴형이 **(void *)** 형태기 때문에 할당할 때, 원하는 타입으로 형변환해줘야 한다. 이때, malloc으로 할당될 공간이 없으면 NULL을 반환한다. malloc으로 할당한 메모리는 free로 해제할 수 있다. free를 제대로 사용하지 않으면 메모리 누수가 발생한다.
```
arr = (int *)malloc(sizeof(int));
free(arr);
```

##