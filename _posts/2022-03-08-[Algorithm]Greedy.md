---
layout: post
title: Greedy Algorithm
date: Tue Mar  8 12:39:01 JST 2022
categories:
tag:
toc: true
---

# Greedy Algorithm

그리디는 최적해를 찾는 알고리즘이다.
그리디는 단순하고 직관적인 방법을 사용한다.
각 경우마다 최선의 선택을 반복해서 해를 찾는다.
물론 각 단계마다 최선의 선택을 한다고 해서 최적해를 찾을 수 있다는 보장은 없다.
예를 들어서 0-1 Knapsack 문제는 최선의 선택이 최적해를 도출하지 않는다.
그래서 그리디로 문제를 풀기 전에 그리디로 해결할 수 있는지 판별해야 한다.
그리디가 잘 적용되는 경우는 2가지 조건이 만족된다.

-   Greedy-choice property: 부분 최적해로 최적해를 찾을 수 있다.(앞의 선택이 이후에 영향을 주지 않아야 한다.)
-   Optimal substructure: 전체의 최적해가 부분에서도 최적해가 되어야 한다.

첫 번째 조건은 각 경우 최선의 선택을 하기 위해 존재한다.
그리디는 특성상 각 단계의 정보만으로 선택한다.
그런데 이전의 선택이 이후의 선택에 영향을 주면 최선의 선택을 찾기 어렵다.
그러므로 이전 결과가 선택에 영향을 주지 않아야 한다.
최소한 이전 선택이 현재 정보를 업데이트해서 현재 정보만으로 선택할 수 있어야 한다.
한 가지 팁을 주자면, 첫 번째 조건 때문에 그리디로 풀리지 않는 문제는 DP로 풀리는 경우가 많다.
Dp는 앞의 선택이 이후의 선택에 영향을 주기 때문이다.

두 번째 조건이 그리디 문제가 어려운 이유다.
Brute Force나 DFS 등으로 문제를 푼다면 수학적인 증명은 필요없다.
모든 경우를 살펴보기 때문이다.
하지만 그리디는 모든 경우를 탐색하지 않는다.
이 덕분에 그리디가 빠르긴 하지만, 각 선택이 합리적이라는 확신이 필요하다.
다시 말해 해당 방법이 옳다는 증명이 필요하다.
수학적인 증명이나 아이디어를 떠올리는 일은 상당히 어렵다.
그 때문에 그리디 문제를 푸는 대표적인 알고리즘을 몇 가지 알고 있어야 한다.
아래는 유명한 그리디 알고리즘이다.

1. Kruskal's Minumum Spanning Tree
2. Prim's Minimum Spanning Tree
3. Dijkstra's Shortest Path
4. Huffman Coding
