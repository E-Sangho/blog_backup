---
layout: post
title:
date: Mon Oct  4 14:48:37 JST 2021
categories: CSAPP
tag: Arithmetic
toc: true
---
## Bits
컴퓨터는 2진법을 사용하는데 이는 0과 1만으로 표현하는 체계는 굉장히 단순해서 구현이 쉬울 뿐만 아니라 오류 발생이 적어 효율적이기 때문이다. 예를 들어 3진법을 쓴다고 하면 전기 신호의 경우의 수가 늘어나고, 신호를 구분하는데 더 많은 비용이 들어 비효율적이게 된다. 2진법을 구현할 수만 있다면 어떤 수단이든 상관 없다. 흑백으로 구분하거나, 구멍의 유무로 구분할 수도 있다. 하지만 컴퓨터는 전류의 세기로 0과 1을 구분한다. 기준선보다 전류가 약하면 0이 되고 더 강하면 1이 되는 방식이다. 예를 들어 0~0.2V는 0이 되고, 0.9~1.1V는 1이 된다. 0과 1로 표현되는 것을 **Bit**라고 하며 정보를 표현하는 가장 작은 단위다. 비트는 단순하지만 이진법으로 수를 표현하는데는 전혀 무리가 없다. 하지만 비트는 한 단위로 쓰기엔 너무 작기 때문에 **Byte(= 8bits)**를 사용한다. 그래서 컴퓨터 정보들은 단위를 바이트를 쓰는데, 컴퓨터가 32bit인지 64bit인지에 따라 다른 바이트를 사용한다. 아래는 데이터 타입에 따라 사용하는 바이트를 정리한 것이다.
| C Data Type | Typical 32-bit | Typical 64-bit |
|-------------|----------------|----------------|
| char | 1 | 1 |
| short | 2 | 2 |
| int | 4 | 4 |
| long | 4 | 8 |
| float | 4 | 4 |
| double | 8 | 8 |
| pointer | 4 | 8 |
보다시피 long과 pointer가 차이가 나는 것을 알 수 있다.

### Boolean Algegra
| & | 0 | 1 |
|---|---|---|
| 0 | 0 | 0 |
| 1 | 0 | 1 |

|\| | 0 | 1 |
|---|---|---|
| 0 | 0 | 1 |
| 1 | 1 | 1 |

| ~ | 0 | 1 |
|---|---|---|
|   | 1 | 0 |

| ^ | 0 | 1 |
|---|---|---|
| 0 | 0 | 1 |
| 1 | 1 | 0 |

operation applied bitwise
e.g.)
|   |    And   |   |    or    |   |    Xor   |   |    Not   |
|---|----------|---|----------|---|----------|---|----------|
|   | 01101001 |   | 01101001 |   | 01101001 |   |          |
| & | 01010101 |\| | 01010101 | ^ | 01010101 | ~ | 01010101 |
|   | 01000001 |   | 01111101 |   | 00111100 |   | 10101010 |

### Sets
프로그래밍을 하다보면 수학의 subset 개념을 써야하는 순간이 있다. 이를 간단하게 구현할 수 있는 방법이 있다. n개의 element가 있는 set $A = \{0, 1, 2, ..., n-1\}$의 subset을 구하려고 한다. 복잡하게 생각할 것 없이 $a_j = 1$이면 j번째 element를 포함하는 경우를 표현한다고 하자. 아래 예시를 보면 좀 더 쉽게 알 수 있다.
- 01101001 = $\{0, 3, 5, 6\}$
- 01010101 = $\{0, 2, 4, 6\}$
- 00000000 = $\phi$
- 11111111 = A

Set의 operation도 쉽게 구현 가능하다.
- Intersection(&)
- Union(|)
- Symmetric difference(^)
- Complement(~)

### Bit Level Operation
앞서 배운 **&, |, ~, ^**는 int, char, long 등의 표현 방법과 상관없이 비트 단위로 이루어진다.
e.g.)
- ~0x41(0100 0001) -> 0xBE(1011 1110)
- ~0x00(0000 0000) -> 0xFF(1111 1111)
- 0x69(0110 1001) & 0x55(0101 0101) -> 0x41(0100 0001)
- 
### Logic Operation
Bit Level Operation은 비트 단위로 했지만 **Logic Operations(&&, ||, !)**는 전체 수를 기준으로 연산을 진행한다.
e.g.)
- !0x41 -> 0x00
- !0x00 -> 0x01
- !!0x41 -> 0x01

- 0x69 && 0x55 -> 0x01
- 0x69 || 0x55 -> 0x01

### Shift Operations
- Left Shift: x << y
비트를 왼쪽으로 y만큼 민 후 빈 공간을 0으로 채운다.
e.g.)
- 01100010 << 3 -> 00010000
- 01100010 << 1 -> 11000100
   
- Right Shift: x >> y
- 
- Logical Shift
오른쪽으로 y만큼 민 후 빈 공간을 0으로 채운다.
- Arithmetic Shift
오른쪽으로 y만큼 민 후 빈 공간을 가장 왼쪽의 숫자로 채운다.
e.g.)
- 101000010 Log.>> 3 -> 00010100
- 101000010 Arith.>> 3 -> 11110100

### Integers
- Unsigned Integer $B2U(X) = \sum_{i=0}^{w-1} x_{i}\cdot2^i$
- Two's Complement $B2T(X) = -x_{w-1}\cdot2^{w-1} + \sum_{i=0}^{w-2}x_{i}\cdot2^i$

### Numeric Ranges
- Unsigned Values: 0 ~ $2^w-1$
- Two's Complement Values: $-2^{w-1}$ ~ $2^{w-1}-1$

### Casting
Signed와 Unsigned간의 계산은 signed가 unsigned로 바뀌어서 진행된다. 즉, signed + unsigned 같은 연산이 있으면 signed는 같은 비트를 가지는 unsigned 값으로 바뀌고 unsigned + unsigned 연산으로 처리된다.

### Sign Extension
w-bit 만큼의 수 x가 있을 때, 비트 자리 수를 w+k-bit로 늘리려고 한다. 이 때, 값을 그대로 유지하려고 한다. unsigned라면 추가한 자리를 0으로 채우면 된다. signed의 경우 제일 앞 자리를 그대로 쓰면 된다. unsigned는 당연하지만, signed는 따로 증명해야 한다. 다만 이를 증명하기 위해선 1자리만 늘리는 경우만 봐도 충분하다. 왜냐하면 k자리를 늘리는 것은 1자리를 늘리는 것을 k번 한 것과 동일하기 때문이다.

proof)

When x is positive, it is trivial. Because sign bit is 0 and the value doesn't change at all. So we only consider about x is negative.
Let $x = -2^{w-1} + \sum_{i=0}^{w-2}a_{i}\cdot2^{i}$, where $a_i \in \{0, 1\}$.

$-2^{w-1} = -2^{w-1} + 0 = -2^{w-1} + (-2^{w-1} + 2^{w-1}) = (-2^{w-1} + -2^{w-1}) + 2^{w-1} = -2^{w} + 2^{w-1}$.

So, $x = -2^{w-1} + \sum_{i=0}^{w-2}a_{i}\cdot2^{i} = -2^{w} + 2^{w-1} + \sum_{i=0}^{w-2}a_{i}\cdot2^{i} = -2^{w} + \sum_{i=0}^{w-1}a_{i}\cdot2^{i}$

Therefore, we can expand 1-digit for x.

### Truncation
반대로 k+w-bit인 수 x를 앞의 k자리만큼 지우면 어떤 일이 발생하는지 알아보자. unsigned, signed 모두 mod연산이 일어난 것과 동일한 결과가 나타난다.