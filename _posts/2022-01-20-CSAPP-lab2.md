---
layout: post
title: "CS:APP Lab 2 Bomb Lab"
date: Thu Jan 20 11:03:10 JST 2022
categories: CSAPP
tag:
toc: true
---

## 1. Introduction

CS:APP의 유명한 과제인 Bomb lab이다.
bomb 파일을 실행하면 6개의 phase가 나온다.
각 페이즈마다 문자열을 입력할 수 있는데, 정답이면 다음 페이즈로 넘어가고, 오답이면 폭탄이 터진다.
파일을 실행해도 정답에 관한 정보를 전혀 얻을 수 없으므로, 어셈블리 코드를 분석해야 한다.
추천하는 어셈블리 코드를 분석하는 방법은 크게 3가지가 있다.

1. gdb
2. lldb
3. objdump

gdb는 책이나 강의에서 이미 소개한 것으로 강의에서도 가장 추천하는 방법이다.
그렇지만 gdb를 따로 설치해야 하고, 버전에 따라 오류가 나는 경우도 있다.
특히 맥이나 가상 머신을 사용하는 경우 종종 오류가 생기곤 한다.
그래서 맥유저는 lldb를 추천하는데, gdb와 명령어가 다를 뿐 사용법은 유사하다.

만약 처음에 Docker를 사용하는 방법을 따랐다면 Docker에서 gdb, lldb를 둘 다 사용할 수 있으므로 문제 없다.
본인은 Docker에서 gdb를 사용해서 풀었다.

## 2. Apple silicon

arm을 사용하는 맥 유저라면 과제를 푸는데 심각한 지장이 있다.
gdb를 사용해서 파일을 실행할 수 없고, Docker에서도 작동하지 않기 때문이다.
대신에 UTM이나 Parallels 같은 가상 머신을 사용해야 한다.
아니면 책의 문제를 푸는 것도 추천하는데, 각 phase가 책의 문제와 같은 내용을 공유하기 때문이다.
아래는 각 페이즈 별 주제다.

-   phase1: comparison
-   phase2: loops
-   phase3: switch
-   phase4: recursion
-   phase5: pointers and array
-   phase6: sorting linked lists

## 3. gdb

아래는 간단한 gdb 명령어다.

-   run:
-   break:
-   disas
-   x/s {메모리주소}
-   x/d {}

## 4. Solve

`gdb bomb`로 bomb 파일을 gdb로 열어준다.
그리고 `disas main`으로 main 코드의 어셈블리 코드를 출력한다.
아래는 출력 결과다.

```
   0x0000000000400da0 <+0>:     push   %rbx
   0x0000000000400da1 <+1>:     cmp    $0x1,%edi
   0x0000000000400da4 <+4>:     jne    0x400db6 <main+22>
   0x0000000000400da6 <+6>:     mov    0x20299b(%rip),%rax        # 0x603748 <stdin@@GLIBC_2.2.5>
   0x0000000000400dad <+13>:    mov    %rax,0x2029b4(%rip)        # 0x603768 <infile>
   0x0000000000400db4 <+20>:    jmp    0x400e19 <main+121>
   0x0000000000400db6 <+22>:    mov    %rsi,%rbx
   0x0000000000400db9 <+25>:    cmp    $0x2,%edi
   0x0000000000400dbc <+28>:    jne    0x400df8 <main+88>
   0x0000000000400dbe <+30>:    mov    0x8(%rsi),%rdi
   0x0000000000400dc2 <+34>:    mov    $0x4022b4,%esi
   0x0000000000400dc7 <+39>:    callq  0x400c10 <fopen@plt>
   0x0000000000400dcc <+44>:    mov    %rax,0x202995(%rip)        # 0x603768 <infile>
   0x0000000000400dd3 <+51>:    test   %rax,%rax
   0x0000000000400dd6 <+54>:    jne    0x400e19 <main+121>
   0x0000000000400dd8 <+56>:    mov    0x8(%rbx),%rcx
   0x0000000000400ddc <+60>:    mov    (%rbx),%rdx
   0x0000000000400ddf <+63>:    mov    $0x4022b6,%esi
   0x0000000000400de4 <+68>:    mov    $0x1,%edi
   0x0000000000400de9 <+73>:    callq  0x400c00 <__printf_chk@plt>
   0x0000000000400dee <+78>:    mov    $0x8,%edi
   0x0000000000400df3 <+83>:    callq  0x400c20 <exit@plt>
   0x0000000000400df8 <+88>:    mov    (%rsi),%rdx
   0x0000000000400dfb <+91>:    mov    $0x4022d3,%esi
   0x0000000000400e00 <+96>:    mov    $0x1,%edi
   0x0000000000400e05 <+101>:   mov    $0x0,%eax
   0x0000000000400e0a <+106>:   callq  0x400c00 <__printf_chk@plt>
   0x0000000000400e0f <+111>:   mov    $0x8,%edi
   0x0000000000400e14 <+116>:   callq  0x400c20 <exit@plt>
   0x0000000000400e19 <+121>:   callq  0x4013a2 <initialize_bomb>
   0x0000000000400e1e <+126>:   mov    $0x402338,%edi
   0x0000000000400e23 <+131>:   callq  0x400b10 <puts@plt>
   0x0000000000400e28 <+136>:   mov    $0x402378,%edi
   0x0000000000400e2d <+141>:   callq  0x400b10 <puts@plt>
   0x0000000000400e32 <+146>:   callq  0x40149e <read_line>
   0x0000000000400e37 <+151>:   mov    %rax,%rdi
   0x0000000000400e3a <+154>:   callq  0x400ee0 <phase_1>
   0x0000000000400e3f <+159>:   callq  0x4015c4 <phase_defused>
   0x0000000000400e44 <+164>:   mov    $0x4023a8,%edi
   0x0000000000400e49 <+169>:   callq  0x400b10 <puts@plt>
   0x0000000000400e4e <+174>:   callq  0x40149e <read_line>
   0x0000000000400e53 <+179>:   mov    %rax,%rdi
   0x0000000000400e56 <+182>:   callq  0x400efc <phase_2>
   0x0000000000400e5b <+187>:   callq  0x4015c4 <phase_defused>
   0x0000000000400e60 <+192>:   mov    $0x4022ed,%edi
   0x0000000000400e65 <+197>:   callq  0x400b10 <puts@plt>
   0x0000000000400e6a <+202>:   callq  0x40149e <read_line>
   0x0000000000400e6f <+207>:   mov    %rax,%rdi
   0x0000000000400e72 <+210>:   callq  0x400f43 <phase_3>
   0x0000000000400e77 <+215>:   callq  0x4015c4 <phase_defused>
   0x0000000000400e7c <+220>:   mov    $0x40230b,%edi
   0x0000000000400e81 <+225>:   callq  0x400b10 <puts@plt>
   0x0000000000400e86 <+230>:   callq  0x40149e <read_line>
   0x0000000000400e8b <+235>:   mov    %rax,%rdi
   0x0000000000400e8e <+238>:   callq  0x40100c <phase_4>
   0x0000000000400e93 <+243>:   callq  0x4015c4 <phase_defused>
   0x0000000000400e98 <+248>:   mov    $0x4023d8,%edi
   0x0000000000400e9d <+253>:   callq  0x400b10 <puts@plt>
   0x0000000000400ea2 <+258>:   callq  0x40149e <read_line>
   0x0000000000400ea7 <+263>:   mov    %rax,%rdi
   0x0000000000400eaa <+266>:   callq  0x401062 <phase_5>
   0x0000000000400eaf <+271>:   callq  0x4015c4 <phase_defused>
   0x0000000000400eb4 <+276>:   mov    $0x40231a,%edi
   0x0000000000400eb9 <+281>:   callq  0x400b10 <puts@plt>
   0x0000000000400ebe <+286>:   callq  0x40149e <read_line>
   0x0000000000400ec3 <+291>:   mov    %rax,%rdi
   0x0000000000400ec6 <+294>:   callq  0x4010f4 <phase_6>
   0x0000000000400ecb <+299>:   callq  0x4015c4 <phase_defused>
   0x0000000000400ed0 <+304>:   mov    $0x0,%eax
   0x0000000000400ed5 <+309>:   pop    %rbx
   0x0000000000400ed6 <+310>:   retq
```

결과를 보면 phase_1~6까지 존재하는 것을 볼 수 있다.

### phase 1

`disas phase_1`으로 phase_1을 보자.

```
(gdb) disas phase_1
Dump of assembler code for function phase_1:
   0x0000000000400ee0 <+0>:     sub    $0x8,%rsp
   0x0000000000400ee4 <+4>:     mov    $0x402400,%esi
   0x0000000000400ee9 <+9>:     callq  0x401338 <strings_not_equal>
   0x0000000000400eee <+14>:    test   %eax,%eax
   0x0000000000400ef0 <+16>:    je     0x400ef7 <phase_1+23>
   0x0000000000400ef2 <+18>:    callq  0x40143a <explode_bomb>
   0x0000000000400ef7 <+23>:    add    $0x8,%rsp
   0x0000000000400efb <+27>:    retq
```

코드를 보면 스택 포인터를 8 증가시켜서 스택에 자리를 만든다.
그리고 mov로 %esi에 0x402400을 넣어준다.
callq로 strings_not_equal을 호출한다.
`disas strings_not_equal`로 함수를 열어보면 아래처럼 나온다.

```
(gdb) disas strings_not_equal
Dump of assembler code for function strings_not_equal:
   0x0000000000401338 <+0>:     push   %r12
   0x000000000040133a <+2>:     push   %rbp
   0x000000000040133b <+3>:     push   %rbx
   0x000000000040133c <+4>:     mov    %rdi,%rbx
   0x000000000040133f <+7>:     mov    %rsi,%rbp
   0x0000000000401342 <+10>:    callq  0x40131b <string_length>
   0x0000000000401347 <+15>:    mov    %eax,%r12d
   0x000000000040134a <+18>:    mov    %rbp,%rdi
   0x000000000040134d <+21>:    callq  0x40131b <string_length>
   0x0000000000401352 <+26>:    mov    $0x1,%edx
   0x0000000000401357 <+31>:    cmp    %eax,%r12d
   0x000000000040135a <+34>:    jne    0x40139b <strings_not_equal+99>
   0x000000000040135c <+36>:    movzbl (%rbx),%eax
   0x000000000040135f <+39>:    test   %al,%al
   0x0000000000401361 <+41>:    je     0x401388 <strings_not_equal+80>
   0x0000000000401363 <+43>:    cmp    0x0(%rbp),%al
   0x0000000000401366 <+46>:    je     0x401372 <strings_not_equal+58>
   0x0000000000401368 <+48>:    jmp    0x40138f <strings_not_equal+87>
   0x000000000040136a <+50>:    cmp    0x0(%rbp),%al
   0x000000000040136d <+53>:    nopl   (%rax)
   0x0000000000401370 <+56>:    jne    0x401396 <strings_not_equal+94>
   0x0000000000401372 <+58>:    add    $0x1,%rbx
   0x0000000000401376 <+62>:    add    $0x1,%rbp
   0x000000000040137a <+66>:    movzbl (%rbx),%eax
   0x000000000040137d <+69>:    test   %al,%al
   0x000000000040137f <+71>:    jne    0x40136a <strings_not_equal+50>
   0x0000000000401381 <+73>:    mov    $0x0,%edx
   0x0000000000401386 <+78>:    jmp    0x40139b <strings_not_equal+99>
   0x0000000000401388 <+80>:    mov    $0x0,%edx
   0x000000000040138d <+85>:    jmp    0x40139b <strings_not_equal+99>
   0x000000000040138f <+87>:    mov    $0x1,%edx
   0x0000000000401394 <+92>:    jmp    0x40139b <strings_not_equal+99>
   0x0000000000401396 <+94>:    mov    $0x1,%edx
   0x000000000040139b <+99>:    mov    %edx,%eax
   0x000000000040139d <+101>:   pop    %rbx
   0x000000000040139e <+102>:   pop    %rbp
   0x000000000040139f <+103>:   pop    %r12
   0x00000000004013a1 <+105>:   retq
```

여기서 string_length의 코드는 아래와 같다.

```
(gdb) disas string_length
Dump of assembler code for function string_length:
   0x000000000040131b <+0>:     cmpb   $0x0,(%rdi)
   0x000000000040131e <+3>:     je     0x401332 <string_length+23>
   0x0000000000401320 <+5>:     mov    %rdi,%rdx
   0x0000000000401323 <+8>:     add    $0x1,%rdx
   0x0000000000401327 <+12>:    mov    %edx,%eax
   0x0000000000401329 <+14>:    sub    %edi,%eax
   0x000000000040132b <+16>:    cmpb   $0x0,(%rdx)
   0x000000000040132e <+19>:    jne    0x401323 <string_length+8>
   0x0000000000401330 <+21>:    repz retq
   0x0000000000401332 <+23>:    mov    $0x0,%eax
   0x0000000000401337 <+28>:    retq
```

이제 코드를 분석해볼텐데 중요한 것은 어디에 값을 받아서, 어떤 값을 반환하는지다.

우선 string_length는 이름 그대로 문자열의 길이를 알아낸다.
(%rdi)에 문자열이 들어 있고, %rdi의 주소를 1칸씩 옮기면서 0이 나오는 곳을 찾는다.
문자열의 제일 끝에는 0이 있으므로 0이 나온다는 것은 곧 문자열이 끝난다는 뜻이다.
그리고 그동안 구한 길이를 %eax에 반환해준다.

다음으로 strings_not_equal을 보자.
%rdi에 첫 번째 변수를 받고, %rbx에 2번째 변수를 받아서 계산을 진행한다.
어떻게 진행되는지 오른쪽에 설명을 적어놨다.

```
   0x0000000000401338 <+0>:     push   %r12                                 스택에 레지스터 값을 저장한다.
   0x000000000040133a <+2>:     push   %rbp                                 스택에 레지스터 값을 저장한다.
   0x000000000040133b <+3>:     push   %rbx                                 스택에 레지스터 값을 저장한다.
   0x000000000040133c <+4>:     mov    %rdi,%rbx                            첫 번째 변수(%rdi)를 %rbx로 옮긴다.
   0x000000000040133f <+7>:     mov    %rsi,%rbp                            두 번째 변수(%rsi)를 %rbp로 옮긴다.
   0x0000000000401342 <+10>:    callq  0x40131b <string_length>             string_length 함수를 호출한다. 첫 번째 변수((%rdi))의 길이를 구한다.
   0x0000000000401347 <+15>:    mov    %eax,%r12d                           반환된 (%rdi)의 길이를 %r12d로 옮긴다.
   0x000000000040134a <+18>:    mov    %rbp,%rdi                            두 번째 변수를 %rdi로 옮긴다.
   0x000000000040134d <+21>:    callq  0x40131b <string_length>             string_length 호출해서 두 번째 변수의 길이를 구한다.
   0x0000000000401352 <+26>:    mov    $0x1,%edx                            %edx를 1로 바꾼다.
   0x0000000000401357 <+31>:    cmp    %eax,%r12d                           첫 번째 변수와 두 번째 변수의 길이를 비교한다.
   0x000000000040135a <+34>:    jne    0x40139b <strings_not_equal+99>      다르다면 <+99>로 점프
   0x000000000040135c <+36>:    movzbl (%rbx),%eax                          길이가 같다면 첫 번째 변수의 값을 %eax로 옮긴다.
   0x000000000040135f <+39>:    test   %al,%al
   0x0000000000401361 <+41>:    je     0x401388 <strings_not_equal+80>      %al(첫 번째 첫 글자)이 0이라면 <+80>으로 점프
   0x0000000000401363 <+43>:    cmp    0x0(%rbp),%al
   0x0000000000401366 <+46>:    je     0x401372 <strings_not_equal+58>      첫 번째 변수의 첫 글자가 두 번째 변수가 같다면 <+58>로 점프
   0x0000000000401368 <+48>:    jmp    0x40138f <strings_not_equal+87>      아니라면 <+87>로 점프
   0x000000000040136a <+50>:    cmp    0x0(%rbp),%al
   0x000000000040136d <+53>:    nopl   (%rax)
   0x0000000000401370 <+56>:    jne    0x401396 <strings_not_equal+94>
   0x0000000000401372 <+58>:    add    $0x1,%rbx                            첫 번째 변수의 다음 글자를 검색하기 위해 1추가
   0x0000000000401376 <+62>:    add    $0x1,%rbp                            두 번째 변수의 다음 글자를 검색하기 위해 1추가
   0x000000000040137a <+66>:    movzbl (%rbx),%eax                          <+71>까지 앞서 했듯이 글자를 비교하기 위해 준비
   0x000000000040137d <+69>:    test   %al,%al
   0x000000000040137f <+71>:    jne    0x40136a <strings_not_equal+50>      첫 번째 변수의 이번 글자가 0이 아니면 <+50>으로 점프해서 반복
   0x0000000000401381 <+73>:    mov    $0x0,%ed복
   0x0000000000401386 <+78>:    jmp    0x40139b <strings_not_equal+99>
   0x0000000000401388 <+80>:    mov    $0x0,%edx
   0x000000000040138d <+85>:    jmp    0x40139b <strings_not_equal+99>
   0x000000000040138f <+87>:    mov    $0x1,%edx
   0x0000000000401394 <+92>:    jmp    0x40139b <strings_not_equal+99>
   0x0000000000401396 <+94>:    mov    $0x1,%edx
   0x000000000040139b <+99>:    mov    %edx,%eax
   0x000000000040139d <+101>:   pop    %rbx
   0x000000000040139e <+102>:   pop    %rbp
   0x000000000040139f <+103>:   pop    %r12
   0x00000000004013a1 <+105>:   retq                                        두 글자가 다르면 1, 같으면 0을 반환한다.
```

책의 문제를 풀어봤다면 별다른 문제 없이 해석할 수 있을 것이다.
간단히 요약해서 strings_not_equal은 첫 번째 문자(%rdi)와 두 번째 문자(%rsi)를 비교한다.
처음에는 길이를 비교하고, 다음엔 앞에서부터 글자를 하나씩 비교한다.
그리고 두 문자열이 같으면 0을, 다르면 1을 반환한다.

다시 처음으로 돌아가서 phase_1을 보자.

```
   0x0000000000400ee0 <+0>:     sub    $0x8,%rsp
   0x0000000000400ee4 <+4>:     mov    $0x402400,%esi
   0x0000000000400ee9 <+9>:     callq  0x401338 <strings_not_equal>
   0x0000000000400eee <+14>:    test   %eax,%eax
   0x0000000000400ef0 <+16>:    je     0x400ef7 <phase_1+23>
   0x0000000000400ef2 <+18>:    callq  0x40143a <explode_bomb>
   0x0000000000400ef7 <+23>:    add    $0x8,%rsp
   0x0000000000400efb <+27>:    retq
```

우선 0x402400의 내용을 %esi로 옮긴다.
그리고 strings_not_equl 함수를 실행해서, 우리가 입력한 값(%rdi)과 %rsi의 값을 비교한다.
만약 다르다면 %eax에 1이 들어 있을테고 <+16>의 점프 코드가 실행되지 않는다.
그래서 <+18>의 explode_bombdㅣ 실행되서 폭탄이 터진다.
그러므로 %eax에 0이 들어가야 한다.
%eax에 0이 들어가려면 %esi와 동일한 값을 입력해줘야 한다.
`x/s 0x402400`으로 0x402400의 값을 출력해보면 "Border relations with Canada have never been better."이 나온다.
그러므로 phase_1에선 위와 같은 문장을 입력해주면 된다.

원본 코드를 유추해보면 아래와 같다.

```
void phase_1 (string input) {
    string key = "Border relations with Canada have never been better.";
    if (strings_not_equal)(input, key) {
        explode_bomb();
    } else {
        return;
    }
}

int strings_not_equal(strint s1, string s2) {
    int s1_len = string_length(s1);
    int s2_len = string_length(s2)
    int index = 0;
    if(s1_len == s2_len) {
        while (s1[index] != '\0') {
            if (s1[index] == s2[index]) {
                ++index;
            } else {
                return 1;
            }
        }
        return 0;
    } else {
        return 1;
    }
}
```

### phase 2

disas로 phase_2의 어셈블리 코드를 보면 아래처럼 나온다.

```
(gdb) disas phase_2
Dump of assembler code for function phase_2:
   0x0000000000400efc <+0>:     push   %rbp
   0x0000000000400efd <+1>:     push   %rbx
   0x0000000000400efe <+2>:     sub    $0x28,%rsp
   0x0000000000400f02 <+6>:     mov    %rsp,%rsi
   0x0000000000400f05 <+9>:     callq  0x40145c <read_six_numbers>
   0x0000000000400f0a <+14>:    cmpl   $0x1,(%rsp)
   0x0000000000400f0e <+18>:    je     0x400f30 <phase_2+52>
   0x0000000000400f10 <+20>:    callq  0x40143a <explode_bomb>
   0x0000000000400f15 <+25>:    jmp    0x400f30 <phase_2+52>
   0x0000000000400f17 <+27>:    mov    -0x4(%rbx),%eax
   0x0000000000400f1a <+30>:    add    %eax,%eax
   0x0000000000400f1c <+32>:    cmp    %eax,(%rbx)
   0x0000000000400f1e <+34>:    je     0x400f25 <phase_2+41>
   0x0000000000400f20 <+36>:    callq  0x40143a <explode_bomb>
   0x0000000000400f25 <+41>:    add    $0x4,%rbx
   0x0000000000400f29 <+45>:    cmp    %rbp,%rbx
   0x0000000000400f2c <+48>:    jne    0x400f17 <phase_2+27>
   0x0000000000400f2e <+50>:    jmp    0x400f3c <phase_2+64>
   0x0000000000400f30 <+52>:    lea    0x4(%rsp),%rbx
   0x0000000000400f35 <+57>:    lea    0x18(%rsp),%rbp
   0x0000000000400f3a <+62>:    jmp    0x400f17 <phase_2+27>
   0x0000000000400f3c <+64>:    add    $0x28,%rsp
   0x0000000000400f40 <+68>:    pop    %rbx
   0x0000000000400f41 <+69>:    pop    %rbp
   0x0000000000400f42 <+70>:    retq
```

read_six_numbers 함수는 아래처럼 나온다.

```
(gdb) disas read_six_numbers
Dump of assembler code for function read_six_numbers:
   0x000000000040145c <+0>:     sub    $0x18,%rsp
   0x0000000000401460 <+4>:     mov    %rsi,%rdx
   0x0000000000401463 <+7>:     lea    0x4(%rsi),%rcx
   0x0000000000401467 <+11>:    lea    0x14(%rsi),%rax
   0x000000000040146b <+15>:    mov    %rax,0x8(%rsp)
   0x0000000000401470 <+20>:    lea    0x10(%rsi),%rax
   0x0000000000401474 <+24>:    mov    %rax,(%rsp)
   0x0000000000401478 <+28>:    lea    0xc(%rsi),%r9
   0x000000000040147c <+32>:    lea    0x8(%rsi),%r8
   0x0000000000401480 <+36>:    mov    $0x4025c3,%esi
   0x0000000000401485 <+41>:    mov    $0x0,%eax
   0x000000000040148a <+46>:    callq  0x400bf0 <__isoc99_sscanf@plt>
   0x000000000040148f <+51>:    cmp    $0x5,%eax
   0x0000000000401492 <+54>:    jg     0x401499 <read_six_numbers+61>
   0x0000000000401494 <+56>:    callq  0x40143a <explode_bomb>
   0x0000000000401499 <+61>:    add    $0x18,%rsp
   0x000000000040149d <+65>:    retq
```

read_six_numbers 함수를 보면 <+32>까지는 스택 프레임을 만드는 과정이다.
다시 말해서 변수 값을 받아와서 레지스터에 저장하는 과정이다.
<+36>부터 코드가 시작되는데, 0x4025c3의 값을 %esi로 옮긴다.
`x/s 0x4025c3`으로 해당 주소 안의 내용을 보면 "%d %d %d %d %d %d"가 나온다.
모양을 보면 알겠지만 이는 <+46>의 scanf에 사용하는 문자열이다.
scanf는 성공적으로 저장한 변수의 갯수를 반환한다.
그러므로 %eax에는 scanf로 받아들인 변수의 갯수가 들어간다.
<+51>, <+54>는 5 < %eax 인 경우 <+61>로 점프한다.
만약 점프가 일어나지 않으면 <+56>에서 폭탄이 터진다.

정리하자면 read_six_numbers는 scanf로 수를 읽어들인다.
이때 읽어들인 수가 6개보다 작은 경우 폭탄이 터지므로, 우리는 6개 이상의 변수를 입력해야 한다.

다음으로 phase_2를 보자.
read_six_numbers 다음에 일어나는 과정을 오른쪽에 적어줬다.

```
(gdb) disas phase_2
Dump of assembler code for function phase_2:
   0x0000000000400efc <+0>:     push   %rbp
   0x0000000000400efd <+1>:     push   %rbx
   0x0000000000400efe <+2>:     sub    $0x28,%rsp
   0x0000000000400f02 <+6>:     mov    %rsp,%rsi
   0x0000000000400f05 <+9>:     callq  0x40145c <read_six_numbers>
   0x0000000000400f0a <+14>:    cmpl   $0x1,(%rsp)                      compare (%rsp) and 1
   0x0000000000400f0e <+18>:    je     0x400f30 <phase_2+52>            if (%rsp == 1) goto <+52>
   0x0000000000400f10 <+20>:    callq  0x40143a <explode_bomb>          else explode_bomb
   0x0000000000400f15 <+25>:    jmp    0x400f30 <phase_2+52>
   0x0000000000400f17 <+27>:    mov    -0x4(%rbx),%eax                  %eax = %rbx - 0x4
   0x0000000000400f1a <+30>:    add    %eax,%eax                        %eax += %eax
   0x0000000000400f1c <+32>:    cmp    %eax,(%rbx)                      (%rbx) 와 %eax를 비교
   0x0000000000400f1e <+34>:    je     0x400f25 <phase_2+41>            같다면 <+41>로 점프
   0x0000000000400f20 <+36>:    callq  0x40143a <explode_bomb>          아니라면 폭발
   0x0000000000400f25 <+41>:    add    $0x4,%rbx                        %rbx += 0x4
   0x0000000000400f29 <+45>:    cmp    %rbp,%rbx                        %rbx와 %rbp 비교
   0x0000000000400f2c <+48>:    jne    0x400f17 <phase_2+27>            다르면 <+27>로 점프
   0x0000000000400f2e <+50>:    jmp    0x400f3c <phase_2+64>            같으면 <+64>로 점프
   0x0000000000400f30 <+52>:    lea    0x4(%rsp),%rbx                   %rbx = %rsp + 0x4
   0x0000000000400f35 <+57>:    lea    0x18(%rsp),%rbp                  %rbp = %rsp + 0x18
   0x0000000000400f3a <+62>:    jmp    0x400f17 <phase_2+27>            <+27>로 점프
   0x0000000000400f3c <+64>:    add    $0x28,%rsp                       스택 공간 반납
   0x0000000000400f40 <+68>:    pop    %rbx
   0x0000000000400f41 <+69>:    pop    %rbp
   0x0000000000400f42 <+70>:    retq
```

간단히 말해 폭탄이 터지지 않으려면 스택의 처음 값이 1이어야 한다.
그리고 반복문으로 스택의 다음값이 이전의 값의 2배가 되는지 확인한다.
마지막에 %rsp + 0x18에 도착하면 반복문이 종료된다.
그러므로 입력값이 매번 2배가 되는 `1 2 4 8 16 32`가 정답이다.

```
int phase_2 (string input) {
    int a[6];
    int n = read_six_numbers(input, a);
    if (a[0] != 1) {
        explode_bomb();
    }
    int* cur_address = &a[1];
    int* last_address = &a[5];
    do {
        int temp = cur_address[-1];
        temp += temp;
        if (temp != *cur_address) {
            explode_bomb();
        }
        ++cur_address;
    } while (cur_address != last_address)
}
```

### phase_3

```
(gdb) disas phase_3
Dump of assembler code for function phase_3:
   0x0000000000400f43 <+0>:     sub    $0x18,%rsp
   0x0000000000400f47 <+4>:     lea    0xc(%rsp),%rcx
   0x0000000000400f4c <+9>:     lea    0x8(%rsp),%rdx
   0x0000000000400f51 <+14>:    mov    $0x4025cf,%esi                   "%d %d"
   0x0000000000400f56 <+19>:    mov    $0x0,%eax
   0x0000000000400f5b <+24>:    callq  0x400bf0 <__isoc99_sscanf@plt>   int n = scanf(input, "%d %d", &x, &y)
   0x0000000000400f60 <+29>:    cmp    $0x1,%eax                        compare n and 1
   0x0000000000400f63 <+32>:    jg     0x400f6a <phase_3+39>            if(n > 1) goto <+39>
   0x0000000000400f65 <+34>:    callq  0x40143a <explode_bomb>          else bomb
   0x0000000000400f6a <+39>:    cmpl   $0x7,0x8(%rsp)                   compare %rsp + 0x8 and 7
   0x0000000000400f6f <+44>:    ja     0x400fad <phase_3+106>           if(%rsp + 0x8 > 7) goto <+106>
   0x0000000000400f71 <+46>:    mov    0x8(%rsp),%eax
   0x0000000000400f75 <+50>:    jmpq   *0x402470(,%rax,8)               choose label for switch
   0x0000000000400f7c <+57>:    mov    $0xcf,%eax
   0x0000000000400f81 <+62>:    jmp    0x400fbe <phase_3+123>           switch loop
   0x0000000000400f83 <+64>:    mov    $0x2c3,%eax
   0x0000000000400f88 <+69>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400f8a <+71>:    mov    $0x100,%eax
   0x0000000000400f8f <+76>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400f91 <+78>:    mov    $0x185,%eax
   0x0000000000400f96 <+83>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400f98 <+85>:    mov    $0xce,%eax
   0x0000000000400f9d <+90>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400f9f <+92>:    mov    $0x2aa,%eax
   0x0000000000400fa4 <+97>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400fa6 <+99>:    mov    $0x147,%eax
   0x0000000000400fab <+104>:   jmp    0x400fbe <phase_3+123>
   0x0000000000400fad <+106>:   callq  0x40143a <explode_bomb>
   0x0000000000400fb2 <+111>:   mov    $0x0,%eax
   0x0000000000400fb7 <+116>:   jmp    0x400fbe <phase_3+123>
   0x0000000000400fb9 <+118>:   mov    $0x137,%eax
   0x0000000000400fbe <+123>:   cmp    0xc(%rsp),%eax                   %eax와 (%rsp + 0xc)의 값 비교
   0x0000000000400fc2 <+127>:   je     0x400fc9 <phase_3+134>           if(%eax == (%rsp + 0xc)) goto <+134>
   0x0000000000400fc4 <+129>:   callq  0x40143a <explode_bomb>          else bomb
   0x0000000000400fc9 <+134>:   add    $0x18,%rsp
   0x0000000000400fcd <+138>:   retq
```

보다시피 비교와 점프가 굉장히 많다.
이는 switch문의 특징이므로 원본 코드에 switch가 들어있음을 유추할 수 있다.
다음으로 코드를 보면 0x4025cf를 sscanf에 사용하고 있다.
`x/s 0x4025cf`를 보면 "%d %d"가 들어 있음을 알 수 있다.
그러므로 2개의 값을 입력받는데, 입력이 2개보다 적으면 폭탄이 터진다.
<+44>를 보면 (%rsp + 0x8)의 값이 7이하가 되어야 한다.
그리고 (%rsp + 0x8)의 값을 사용해 switch문이 어디로 가야할지 정한다.
<+50>을 보면 (8 * %rax + *0x402470) 주소에 있는 곳으로 점프한다.
%rax에는 (%rsp + 0x8)이 들어있으므로, (8 * (%rsp + 0x8) + *0x400f7c)의 값으로 점프한다.
스위치문은 %eax에 특정 값을 넣어주는 내용들이다.
모두 <+123>으로 가고 있으므로 <+123>을 보자.
<+123>, <+127>을 보면 %eax에 넣어준 값과 (%rsp + 0xc)의 값이 같아야 한다.
여기서 (%rsp + 0xc)는 스택의 위치로 보아 2번째로 넣어준 값이다.

정리하면 첫 번째 변수는 점프 위치를 지정하는데 사용한다.
그리고 점프 위치에서 받아온 값이 두 번째로 넣어준 값과 일치해야 한다.
switch문의 점프 위치가 여러 개 있기 때문에 답도 하나가 아니다.
<+57>, <+64>, <+71>, <+78>, <+85>, <+92>, <+99>, <+118>로 점프할 수 있다.
그러므로 0x402470부터 8개의 값을 확인해서 어디로 점프하는지 알아보자.
`x/8gx 0x402470`으로 결과를 보면 아래처럼 된다.

```
(gdb) x/8gx 0x402470
0x402470:       0x0000000000400f7c      0x0000000000400fb9
0x402480:       0x0000000000400f83      0x0000000000400f8a
0x402490:       0x0000000000400f91      0x0000000000400f98
0x4024a0:       0x0000000000400f9f      0x0000000000400fa6
```

다시 말해서 첫 번째 입력값에 따라 아래처럼 결과가 나온다.

| input | address | jump   |
| ----- | ------- | ------ |
| 0     | 400f7c  | <+57>  |
| 1     | 400fb9  | <+118> |
| 2     | 400f83  | <+64>  |
| 3     | 400f8a  | <+71>  |
| 4     | 400f91  | <+78>  |
| 5     | 400f98  | <+85>  |
| 6     | 400f9f  | <+92>  |
| 7     | 400fa6  | <+99>  |

풀이는 이중 <+57>만 적도록 하겠다.
<+57>로 점프하려면 첫 번째 입력값이 1이 되어야 한다.
<+57>을 보면 두 번째 변수가 0xcf와 같아야 한다.
두 번째 입력값을 계산해보면 16 \_ 12 + 15 = 207이 되어야 한다.
그러므로 입력값은 "0 207"이 되어야 한다.
나머지 경우도 같은 방법으로 정하면 아래처럼 된다.

```
0 207
1 311
2 707
3 256
4 389
5 206
6 682
7 327
```

위의 값 중에 하나를 선택해 입력하면 phase_3가 종료된다.

### phase_4

phase_4의 코드는 아래와 같다.

```
(gdb) disas phase_4
Dump of assembler code for function phase_4:
   0x000000000040100c <+0>:     sub    $0x18,%rsp
   0x0000000000401010 <+4>:     lea    0xc(%rsp),%rcx                       int b;
   0x0000000000401015 <+9>:     lea    0x8(%rsp),%rdx                       int a;
   0x000000000040101a <+14>:    mov    $0x4025cf,%esi                       *0x4025cf = "%d %d"
   0x000000000040101f <+19>:    mov    $0x0,%eax
   0x0000000000401024 <+24>:    callq  0x400bf0 <__isoc99_sscanf@plt>       int n = sscanf(input, "%d %d", &a, &b)
   0x0000000000401029 <+29>:    cmp    $0x2,%eax                            if (n != 2)
   0x000000000040102c <+32>:    jne    0x401035 <phase_4+41>                    explode_bomb
   0x000000000040102e <+34>:    cmpl   $0xe,0x8(%rsp)                       if (a <= 14)
   0x0000000000401033 <+39>:    jbe    0x40103a <phase_4+46>                    goto +46
   0x0000000000401035 <+41>:    callq  0x40143a <explode_bomb>              else explode_bomb
   0x000000000040103a <+46>:    mov    $0xe,%edx
   0x000000000040103f <+51>:    mov    $0x0,%esi
   0x0000000000401044 <+56>:    mov    0x8(%rsp),%edi
   0x0000000000401048 <+60>:    callq  0x400fce <func4>
   0x000000000040104d <+65>:    test   %eax,%eax                            if (func4(a, 0, 14))
   0x000000000040104f <+67>:    jne    0x401058 <phase_4+76>                    explode_bomb
   0x0000000000401051 <+69>:    cmpl   $0x0,0xc(%rsp)                       if (b == 0)
   0x0000000000401056 <+74>:    je     0x40105d <phase_4+81>                    goto +81
   0x0000000000401058 <+76>:    callq  0x40143a <explode_bomb>              else explode_bomb
   0x000000000040105d <+81>:    add    $0x18,%rsp
   0x0000000000401061 <+85>:    retq
```

앞서 했던 것처럼 0x4025cf는 sscanf에 쓰는 문자열일 것이다.
해당 주소 안의 내용을 확인해보자.

```
(gdb) x/s 0x4025cf
0x4025cf:       "%d %d"
```

역시 두 값을 받아주기 위해 쓰인 문자열이다.
그 아래부터는 이전과 비슷한 반복이다.
첫 번째 입력받는 수가 14이하여야 하고, b가 0이어야 폭탄이 터지지 않는다.
그리고 func4를 실행한 결과가 0이 되어야 폭탄이 터지지 않는다는 것을 알 수 있다.
func4와 관련된 부분은 <+46> ~ <+60>인데, 살펴보면 %edi, %esi, %edx에 값을 넣어주고 있다.
함수를 호출할 때 쓰이는 레지스터 순서가 %rdi, %rsi, %rdx, %rcx, %r8, %r9 순서인 것을 기억해보면, 변수가 3개 쓰인 것을 알 수 있다.
첫 번째 변수 %edi에 처음 입력받은 수 a가 들어간다.
두 번째 변수는 %esi는 0이 들어가고, 세 번째 변수는 14가 들어간다.
다음으로 func4가 어떤 함수인지 살펴보자.

```
(gdb) disas func4
Dump of assembler code for function func4:
   0x0000000000400fce <+0>:     sub    $0x8,%rsp
   0x0000000000400fd2 <+4>:     mov    %edx,%eax                result = z
   0x0000000000400fd4 <+6>:     sub    %esi,%eax                result -= y
   0x0000000000400fd6 <+8>:     mov    %eax,%ecx                int d = result
   0x0000000000400fd8 <+10>:    shr    $0x1f,%ecx               d = d >> 31
   0x0000000000400fdb <+13>:    add    %ecx,%eax                result += d
   0x0000000000400fdd <+15>:    sar    %eax                     result >> 1
   0x0000000000400fdf <+17>:    lea    (%rax,%rsi,1),%ecx       d = result + y
   0x0000000000400fe2 <+20>:    cmp    %edi,%ecx                if(d <= x)
   0x0000000000400fe4 <+22>:    jle    0x400ff2 <func4+36>          goto +36
   0x0000000000400fe6 <+24>:    lea    -0x1(%rcx),%edx          z = (d - 1)
   0x0000000000400fe9 <+27>:    callq  0x400fce <func4>         int result = func4(x, y, z)
   0x0000000000400fee <+32>:    add    %eax,%eax                result += result
   0x0000000000400ff0 <+34>:    jmp    0x401007 <func4+57>      goto +57
   0x0000000000400ff2 <+36>:    mov    $0x0,%eax                result = 0
   0x0000000000400ff7 <+41>:    cmp    %edi,%ecx                if(d >= x)
   0x0000000000400ff9 <+43>:    jge    0x401007 <func4+57>          goto +57
   0x0000000000400ffb <+45>:    lea    0x1(%rcx),%esi           y = (d + 1)
   0x0000000000400ffe <+48>:    callq  0x400fce <func4>         result = func4(x, y, z)
   0x0000000000401003 <+53>:    lea    0x1(%rax,%rax,1),%eax    result = result + result + 1
   0x0000000000401007 <+57>:    add    $0x8,%rsp                return result
   0x000000000040100b <+61>:    retq
```

func4의 원본 코드는 아래와 같다.

```
int func4(int x, int y, int z) {
    int result = z - y;
    int d = result;
    d = d >> 31;
    result += d;
    result = result >> 1;
    d = result + y;
    if(d > x) {
        result = func4(x, y, d-1);
        result += result;
    } else {
        result = 0;
        if (d < x) {
            result = func4(x, d+1, z);
            result = result + result + 1
        }
    }
    return result;
}
```

원본 코드를 봐도 복잡한데 if문이 나오기 전까지 y와 z의 대소 관계에 따라 2가지 경우가 있다.
우선 $y \le z$인 경우 result가 양수이므로 d >> 31이 0이 된다.
그러므로 d = result + y = (z - y) / 2 + y = (z + y) / 2가 된다.
다음으로 $y > z$인 경우 result가 음수이므로 d >> 31이 1이 된다.
그러므로 d = (z - y + 1) / 2 + y = (z + y + 1) / 2다.

그 밑의 if문을 보면 재귀함수 형태가 된다.
재귀함수가 종료되는 순간은 d == x인 경우고, 이때 result = 0이 된다.
if문 안의 내용은 d와 x의 대소관계에 따라 안의 함수의 값을 2배 하거나, 2배로 하고 1을 더한다.
함수 형태를 보면 평균에 가까운 값을 y, z 위치에 넣어줘서 x와 같은 값이 나오도록 하고 있다는 것을 알 수 있다.
솔직히 func4가 어떤 함수인지는 잘 모르겠지만 우리는 결과만 내면 되므로 넘어가겠다.
phase_4를 기억해보면 result가 0이 되어야 폭탄이 터지지 않으므로 0이 되도록 하는 x를 찾아보자.

phase_4에서 호출할 때 func4(a, 0, 14)를 사용했다.
이 값을 그대로 사용하면 d = 7이다.
제일 쉬운 것은 a에 7을 넣어주면 된다.
그 외에 가능한 답은 아래에 적어놨다.

```
0 0
1 0
3 0
7 0
```

### phase_5

```
(gdb) disas phase_5
Dump of assembler code for function phase_5:
   0x0000000000401062 <+0>:     push   %rbx
   0x0000000000401063 <+1>:     sub    $0x20,%rsp
   0x0000000000401067 <+5>:     mov    %rdi,%rbx
   0x000000000040106a <+8>:     mov    %fs:0x28,%rax
   0x0000000000401073 <+17>:    mov    %rax,0x18(%rsp)
   0x0000000000401078 <+22>:    xor    %eax,%eax
   0x000000000040107a <+24>:    callq  0x40131b <string_length>
   0x000000000040107f <+29>:    cmp    $0x6,%eax                        if(string_length(input) == 6)
   0x0000000000401082 <+32>:    je     0x4010d2 <phase_5+112>               goto <+112>
   0x0000000000401084 <+34>:    callq  0x40143a <explode_bomb>          else bomb
   0x0000000000401089 <+39>:    jmp    0x4010d2 <phase_5+112>
   0x000000000040108b <+41>:    movzbl (%rbx,%rax,1),%ecx               %ecx = (%rax + %rbx)
   0x000000000040108f <+45>:    mov    %cl,(%rsp)                       (%rsp) = %cl
   0x0000000000401092 <+48>:    mov    (%rsp),%rdx                      %rdx = (%rsp)
   0x0000000000401096 <+52>:    and    $0xf,%edx                        %edx = %edx & 0xf
   0x0000000000401099 <+55>:    movzbl 0x4024b0(%rdx),%edx              %edx = (%rdx + 0x4024b0)
   0x00000000004010a0 <+62>:    mov    %dl,0x10(%rsp,%rax,1)            (%rsp + %rax + 0x10) = %dl
   0x00000000004010a4 <+66>:    add    $0x1,%rax                        %rax += 0x1
   0x00000000004010a8 <+70>:    cmp    $0x6,%rax                        if(%rax != 6)
   0x00000000004010ac <+74>:    jne    0x40108b <phase_5+41>                goto <+41>
   0x00000000004010ae <+76>:    movb   $0x0,0x16(%rsp)                  (%rsp+0x16) = 0x0
   0x00000000004010b3 <+81>:    mov    $0x40245e,%esi                   %esi = 0x40245e
   0x00000000004010b8 <+86>:    lea    0x10(%rsp),%rdi                  %rdi = %rsp + 0x10
   0x00000000004010bd <+91>:    callq  0x401338 <strings_not_equal>     if(strings_not_equal(%rdi, %esi))
   0x00000000004010c2 <+96>:    test   %eax,%eax
   0x00000000004010c4 <+98>:    je     0x4010d9 <phase_5+119>               goto <+119>
   0x00000000004010c6 <+100>:   callq  0x40143a <explode_bomb>          else explode_bomb
   0x00000000004010cb <+105>:   nopl   0x0(%rax,%rax,1)                 if(!(%rax+%rax))
   0x00000000004010d0 <+110>:   jmp    0x4010d9 <phase_5+119>               goto <+119>
   0x00000000004010d2 <+112>:   mov    $0x0,%eax                        %eax = 0
   0x00000000004010d7 <+117>:   jmp    0x40108b <phase_5+41>            goto <+41>
   0x00000000004010d9 <+119>:   mov    0x18(%rsp),%rax
   0x00000000004010de <+124>:   xor    %fs:0x28,%rax
   0x00000000004010e7 <+133>:   je     0x4010ee <phase_5+140>
   0x00000000004010e9 <+135>:   callq  0x400b30 <__stack_chk_fail@plt>
   0x00000000004010ee <+140>:   add    $0x20,%rsp
   0x00000000004010f2 <+144>:   pop    %rbx
   0x00000000004010f3 <+145>:   retq
```
