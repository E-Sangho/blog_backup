---
layout: post
title: "CS:APP Lab 2 Bomb Lab"
date: Thu Jan 20 11:03:10 JST 2022
categories: CSAPP
tag:
toc: true
---

## 1. Introduction

CS:APP의 유명한 과제인 Bomb lab이다.
bomb 파일을 실행하면 6개의 phase가 나온다.
각 페이즈마다 문자열을 입력할 수 있는데, 정답이면 다음 페이즈로 넘어가고, 오답이면 폭탄이 터진다.
파일을 실행해도 정답에 관한 정보를 전혀 얻을 수 없으므로, 어셈블리 코드를 분석해야 한다.
추천하는 어셈블리 코드를 분석하는 방법은 크게 3가지가 있다.

1. gdb
2. lldb
3. objdump

gdb는 책이나 강의에서 이미 소개한 것으로 강의에서도 가장 추천하는 방법이다.
그렇지만 gdb를 따로 설치해야 하고, 버전에 따라 오류가 나는 경우도 있다.
특히 맥이나 가상 머신을 사용하는 경우 종종 오류가 생기곤 한다.
그래서 맥유저는 lldb를 추천하는데, gdb와 명령어가 다를 뿐 사용법은 유사하다.

만약 처음에 Docker를 사용하는 방법을 따랐다면 Docker에서 gdb를 사용할 수 있으므로 문제 없다.
본인은 Docker에서 gdb를 사용해서 풀었다.

## 2. Apple silicon

arm을 사용하는 맥 유저라면 과제를 푸는데 심각한 지장이 있다.
gdb를 사용해서 파일을 실행할 수 없고, Docker에서도 작동하지 않기 때문이다.
대신에 UTM이나 Parallels 같은 가상 머신을 사용해야 한다.
아니면 책의 문제를 푸는 것도 추천하는데, 각 phase가 책의 문제와 같은 내용을 공유하기 때문이다.
아래는 각 페이즈 별 주제다.

-   phase1: comparison
-   phase2: loops
-   phase3: switch
-   phase4: recursion
-   phase5: pointers and array
-   phase6: sorting linked lists

## 3. gdb

아래는 간단한 gdb 명령어로 이 정도만 알아도 충분히 풀 수 있다.

-   r: 프로그램을 실행시킨다. 실행시키기 전에 반드시 아래의 break를 설정해줘야 폭탄이 터지지 않는다.
-   b {함수이름}: 함수가 실행되기 전에 동작을 멈춘다. b explode_bomb를 꼭 설정해야 폭탄이 터지지 않는다.
-   disas {함수이름}: 함수를 디스어셈블한 결과를 보여준다.
-   ni: 다음 줄을 실행하는데, 함수 안으로 진입하진 않는다.
-   si: 다음 줄을 실행하는데, 함수 안으로 진입한다.

메모리 출력

-   x/[범위][출력형식][범위단위] {메모리주소}: 해당 메모리 값을 출력한다. 추가 옵션에 따라 다양한 형식으로 출력할 수 있다.

-   범위: 해당 옵션으로 몇 번 출력할지 정한다.
-   출력형식: d(10진수), u(부호없는 10진수), x(16진수), s(문자열)
-   범위단위: b(1byte), h(2byte), w(4byte), g(8byte)

e.g.) `x/16gx 0x402450`

## 4. Solve

`gdb bomb`로 bomb 파일을 gdb로 열어준다.
그리고 `disas main`으로 main 코드의 어셈블리 코드를 출력한다.
아래는 출력 결과다.

```
   0x0000000000400da0 <+0>:     push   %rbx
   0x0000000000400da1 <+1>:     cmp    $0x1,%edi
   0x0000000000400da4 <+4>:     jne    0x400db6 <main+22>
   0x0000000000400da6 <+6>:     mov    0x20299b(%rip),%rax        # 0x603748 <stdin@@GLIBC_2.2.5>
   0x0000000000400dad <+13>:    mov    %rax,0x2029b4(%rip)        # 0x603768 <infile>
   0x0000000000400db4 <+20>:    jmp    0x400e19 <main+121>
   0x0000000000400db6 <+22>:    mov    %rsi,%rbx
   0x0000000000400db9 <+25>:    cmp    $0x2,%edi
   0x0000000000400dbc <+28>:    jne    0x400df8 <main+88>
   0x0000000000400dbe <+30>:    mov    0x8(%rsi),%rdi
   0x0000000000400dc2 <+34>:    mov    $0x4022b4,%esi
   0x0000000000400dc7 <+39>:    callq  0x400c10 <fopen@plt>
   0x0000000000400dcc <+44>:    mov    %rax,0x202995(%rip)        # 0x603768 <infile>
   0x0000000000400dd3 <+51>:    test   %rax,%rax
   0x0000000000400dd6 <+54>:    jne    0x400e19 <main+121>
   0x0000000000400dd8 <+56>:    mov    0x8(%rbx),%rcx
   0x0000000000400ddc <+60>:    mov    (%rbx),%rdx
   0x0000000000400ddf <+63>:    mov    $0x4022b6,%esi
   0x0000000000400de4 <+68>:    mov    $0x1,%edi
   0x0000000000400de9 <+73>:    callq  0x400c00 <__printf_chk@plt>
   0x0000000000400dee <+78>:    mov    $0x8,%edi
   0x0000000000400df3 <+83>:    callq  0x400c20 <exit@plt>
   0x0000000000400df8 <+88>:    mov    (%rsi),%rdx
   0x0000000000400dfb <+91>:    mov    $0x4022d3,%esi
   0x0000000000400e00 <+96>:    mov    $0x1,%edi
   0x0000000000400e05 <+101>:   mov    $0x0,%eax
   0x0000000000400e0a <+106>:   callq  0x400c00 <__printf_chk@plt>
   0x0000000000400e0f <+111>:   mov    $0x8,%edi
   0x0000000000400e14 <+116>:   callq  0x400c20 <exit@plt>
   0x0000000000400e19 <+121>:   callq  0x4013a2 <initialize_bomb>
   0x0000000000400e1e <+126>:   mov    $0x402338,%edi
   0x0000000000400e23 <+131>:   callq  0x400b10 <puts@plt>
   0x0000000000400e28 <+136>:   mov    $0x402378,%edi
   0x0000000000400e2d <+141>:   callq  0x400b10 <puts@plt>
   0x0000000000400e32 <+146>:   callq  0x40149e <read_line>
   0x0000000000400e37 <+151>:   mov    %rax,%rdi
   0x0000000000400e3a <+154>:   callq  0x400ee0 <phase_1>
   0x0000000000400e3f <+159>:   callq  0x4015c4 <phase_defused>
   0x0000000000400e44 <+164>:   mov    $0x4023a8,%edi
   0x0000000000400e49 <+169>:   callq  0x400b10 <puts@plt>
   0x0000000000400e4e <+174>:   callq  0x40149e <read_line>
   0x0000000000400e53 <+179>:   mov    %rax,%rdi
   0x0000000000400e56 <+182>:   callq  0x400efc <phase_2>
   0x0000000000400e5b <+187>:   callq  0x4015c4 <phase_defused>
   0x0000000000400e60 <+192>:   mov    $0x4022ed,%edi
   0x0000000000400e65 <+197>:   callq  0x400b10 <puts@plt>
   0x0000000000400e6a <+202>:   callq  0x40149e <read_line>
   0x0000000000400e6f <+207>:   mov    %rax,%rdi
   0x0000000000400e72 <+210>:   callq  0x400f43 <phase_3>
   0x0000000000400e77 <+215>:   callq  0x4015c4 <phase_defused>
   0x0000000000400e7c <+220>:   mov    $0x40230b,%edi
   0x0000000000400e81 <+225>:   callq  0x400b10 <puts@plt>
   0x0000000000400e86 <+230>:   callq  0x40149e <read_line>
   0x0000000000400e8b <+235>:   mov    %rax,%rdi
   0x0000000000400e8e <+238>:   callq  0x40100c <phase_4>
   0x0000000000400e93 <+243>:   callq  0x4015c4 <phase_defused>
   0x0000000000400e98 <+248>:   mov    $0x4023d8,%edi
   0x0000000000400e9d <+253>:   callq  0x400b10 <puts@plt>
   0x0000000000400ea2 <+258>:   callq  0x40149e <read_line>
   0x0000000000400ea7 <+263>:   mov    %rax,%rdi
   0x0000000000400eaa <+266>:   callq  0x401062 <phase_5>
   0x0000000000400eaf <+271>:   callq  0x4015c4 <phase_defused>
   0x0000000000400eb4 <+276>:   mov    $0x40231a,%edi
   0x0000000000400eb9 <+281>:   callq  0x400b10 <puts@plt>
   0x0000000000400ebe <+286>:   callq  0x40149e <read_line>
   0x0000000000400ec3 <+291>:   mov    %rax,%rdi
   0x0000000000400ec6 <+294>:   callq  0x4010f4 <phase_6>
   0x0000000000400ecb <+299>:   callq  0x4015c4 <phase_defused>
   0x0000000000400ed0 <+304>:   mov    $0x0,%eax
   0x0000000000400ed5 <+309>:   pop    %rbx
   0x0000000000400ed6 <+310>:   retq
```

결과를 보면 phase_1~6까지 존재하는 것을 볼 수 있다.

### phase 1

`disas phase_1`으로 phase_1을 보자.

```
(gdb) disas phase_1
Dump of assembler code for function phase_1:
   0x0000000000400ee0 <+0>:     sub    $0x8,%rsp
   0x0000000000400ee4 <+4>:     mov    $0x402400,%esi
   0x0000000000400ee9 <+9>:     callq  0x401338 <strings_not_equal>
   0x0000000000400eee <+14>:    test   %eax,%eax
   0x0000000000400ef0 <+16>:    je     0x400ef7 <phase_1+23>
   0x0000000000400ef2 <+18>:    callq  0x40143a <explode_bomb>
   0x0000000000400ef7 <+23>:    add    $0x8,%rsp
   0x0000000000400efb <+27>:    retq
```

코드를 보면 스택 포인터를 8 증가시켜서 스택에 자리를 만든다.
그리고 mov로 %esi에 0x402400을 넣어준다.
callq로 strings_not_equal을 호출한다.
`disas strings_not_equal`로 함수를 열어보면 아래처럼 나온다.

```
(gdb) disas strings_not_equal
Dump of assembler code for function strings_not_equal:
   0x0000000000401338 <+0>:     push   %r12
   0x000000000040133a <+2>:     push   %rbp
   0x000000000040133b <+3>:     push   %rbx
   0x000000000040133c <+4>:     mov    %rdi,%rbx
   0x000000000040133f <+7>:     mov    %rsi,%rbp
   0x0000000000401342 <+10>:    callq  0x40131b <string_length>
   0x0000000000401347 <+15>:    mov    %eax,%r12d
   0x000000000040134a <+18>:    mov    %rbp,%rdi
   0x000000000040134d <+21>:    callq  0x40131b <string_length>
   0x0000000000401352 <+26>:    mov    $0x1,%edx
   0x0000000000401357 <+31>:    cmp    %eax,%r12d
   0x000000000040135a <+34>:    jne    0x40139b <strings_not_equal+99>
   0x000000000040135c <+36>:    movzbl (%rbx),%eax
   0x000000000040135f <+39>:    test   %al,%al
   0x0000000000401361 <+41>:    je     0x401388 <strings_not_equal+80>
   0x0000000000401363 <+43>:    cmp    0x0(%rbp),%al
   0x0000000000401366 <+46>:    je     0x401372 <strings_not_equal+58>
   0x0000000000401368 <+48>:    jmp    0x40138f <strings_not_equal+87>
   0x000000000040136a <+50>:    cmp    0x0(%rbp),%al
   0x000000000040136d <+53>:    nopl   (%rax)
   0x0000000000401370 <+56>:    jne    0x401396 <strings_not_equal+94>
   0x0000000000401372 <+58>:    add    $0x1,%rbx
   0x0000000000401376 <+62>:    add    $0x1,%rbp
   0x000000000040137a <+66>:    movzbl (%rbx),%eax
   0x000000000040137d <+69>:    test   %al,%al
   0x000000000040137f <+71>:    jne    0x40136a <strings_not_equal+50>
   0x0000000000401381 <+73>:    mov    $0x0,%edx
   0x0000000000401386 <+78>:    jmp    0x40139b <strings_not_equal+99>
   0x0000000000401388 <+80>:    mov    $0x0,%edx
   0x000000000040138d <+85>:    jmp    0x40139b <strings_not_equal+99>
   0x000000000040138f <+87>:    mov    $0x1,%edx
   0x0000000000401394 <+92>:    jmp    0x40139b <strings_not_equal+99>
   0x0000000000401396 <+94>:    mov    $0x1,%edx
   0x000000000040139b <+99>:    mov    %edx,%eax
   0x000000000040139d <+101>:   pop    %rbx
   0x000000000040139e <+102>:   pop    %rbp
   0x000000000040139f <+103>:   pop    %r12
   0x00000000004013a1 <+105>:   retq
```

여기서 string_length의 코드는 아래와 같다.

```
(gdb) disas string_length
Dump of assembler code for function string_length:
   0x000000000040131b <+0>:     cmpb   $0x0,(%rdi)
   0x000000000040131e <+3>:     je     0x401332 <string_length+23>
   0x0000000000401320 <+5>:     mov    %rdi,%rdx
   0x0000000000401323 <+8>:     add    $0x1,%rdx
   0x0000000000401327 <+12>:    mov    %edx,%eax
   0x0000000000401329 <+14>:    sub    %edi,%eax
   0x000000000040132b <+16>:    cmpb   $0x0,(%rdx)
   0x000000000040132e <+19>:    jne    0x401323 <string_length+8>
   0x0000000000401330 <+21>:    repz retq
   0x0000000000401332 <+23>:    mov    $0x0,%eax
   0x0000000000401337 <+28>:    retq
```

이제 코드를 분석해볼텐데 중요한 것은 어디에 값을 받아서, 어떤 값을 반환하는지다.

우선 string_length는 이름 그대로 문자열의 길이를 알아낸다.
(%rdi)에 문자열이 들어 있고, %rdi의 주소를 1칸씩 옮기면서 0이 나오는 곳을 찾는다.
문자열의 제일 끝에는 0이 있으므로 0이 나온다는 것은 곧 문자열이 끝난다는 뜻이다.
그리고 그동안 구한 길이를 %eax에 반환해준다.

다음으로 strings_not_equal을 보자.
%rdi에 첫 번째 변수를 받고, %rbx에 2번째 변수를 받아서 계산을 진행한다.
어떻게 진행되는지 오른쪽에 설명을 적어놨다.

```
   0x0000000000401338 <+0>:     push   %r12                                 스택에 레지스터 값을 저장한다.
   0x000000000040133a <+2>:     push   %rbp                                 스택에 레지스터 값을 저장한다.
   0x000000000040133b <+3>:     push   %rbx                                 스택에 레지스터 값을 저장한다.
   0x000000000040133c <+4>:     mov    %rdi,%rbx                            첫 번째 변수(%rdi)를 %rbx로 옮긴다.
   0x000000000040133f <+7>:     mov    %rsi,%rbp                            두 번째 변수(%rsi)를 %rbp로 옮긴다.
   0x0000000000401342 <+10>:    callq  0x40131b <string_length>             string_length 함수를 호출한다. 첫 번째 변수((%rdi))의 길이를 구한다.
   0x0000000000401347 <+15>:    mov    %eax,%r12d                           반환된 (%rdi)의 길이를 %r12d로 옮긴다.
   0x000000000040134a <+18>:    mov    %rbp,%rdi                            두 번째 변수를 %rdi로 옮긴다.
   0x000000000040134d <+21>:    callq  0x40131b <string_length>             string_length 호출해서 두 번째 변수의 길이를 구한다.
   0x0000000000401352 <+26>:    mov    $0x1,%edx                            %edx를 1로 바꾼다.
   0x0000000000401357 <+31>:    cmp    %eax,%r12d                           첫 번째 변수와 두 번째 변수의 길이를 비교한다.
   0x000000000040135a <+34>:    jne    0x40139b <strings_not_equal+99>      다르다면 <+99>로 점프
   0x000000000040135c <+36>:    movzbl (%rbx),%eax                          길이가 같다면 첫 번째 변수의 값을 %eax로 옮긴다.
   0x000000000040135f <+39>:    test   %al,%al
   0x0000000000401361 <+41>:    je     0x401388 <strings_not_equal+80>      %al(첫 번째 첫 글자)이 0이라면 <+80>으로 점프
   0x0000000000401363 <+43>:    cmp    0x0(%rbp),%al
   0x0000000000401366 <+46>:    je     0x401372 <strings_not_equal+58>      첫 번째 변수의 첫 글자가 두 번째 변수가 같다면 <+58>로 점프
   0x0000000000401368 <+48>:    jmp    0x40138f <strings_not_equal+87>      아니라면 <+87>로 점프
   0x000000000040136a <+50>:    cmp    0x0(%rbp),%al
   0x000000000040136d <+53>:    nopl   (%rax)
   0x0000000000401370 <+56>:    jne    0x401396 <strings_not_equal+94>
   0x0000000000401372 <+58>:    add    $0x1,%rbx                            첫 번째 변수의 다음 글자를 검색하기 위해 1추가
   0x0000000000401376 <+62>:    add    $0x1,%rbp                            두 번째 변수의 다음 글자를 검색하기 위해 1추가
   0x000000000040137a <+66>:    movzbl (%rbx),%eax                          <+71>까지 앞서 했듯이 글자를 비교하기 위해 준비
   0x000000000040137d <+69>:    test   %al,%al
   0x000000000040137f <+71>:    jne    0x40136a <strings_not_equal+50>      첫 번째 변수의 이번 글자가 0이 아니면 <+50>으로 점프해서 반복
   0x0000000000401381 <+73>:    mov    $0x0,%ed복
   0x0000000000401386 <+78>:    jmp    0x40139b <strings_not_equal+99>
   0x0000000000401388 <+80>:    mov    $0x0,%edx
   0x000000000040138d <+85>:    jmp    0x40139b <strings_not_equal+99>
   0x000000000040138f <+87>:    mov    $0x1,%edx
   0x0000000000401394 <+92>:    jmp    0x40139b <strings_not_equal+99>
   0x0000000000401396 <+94>:    mov    $0x1,%edx
   0x000000000040139b <+99>:    mov    %edx,%eax
   0x000000000040139d <+101>:   pop    %rbx
   0x000000000040139e <+102>:   pop    %rbp
   0x000000000040139f <+103>:   pop    %r12
   0x00000000004013a1 <+105>:   retq                                        두 글자가 다르면 1, 같으면 0을 반환한다.
```

책의 문제를 풀어봤다면 별다른 문제 없이 해석할 수 있을 것이다.
간단히 요약해서 strings_not_equal은 첫 번째 문자(%rdi)와 두 번째 문자(%rsi)를 비교한다.
처음에는 길이를 비교하고, 다음엔 앞에서부터 글자를 하나씩 비교한다.
그리고 두 문자열이 같으면 0을, 다르면 1을 반환한다.

다시 처음으로 돌아가서 phase_1을 보자.

```
   0x0000000000400ee0 <+0>:     sub    $0x8,%rsp
   0x0000000000400ee4 <+4>:     mov    $0x402400,%esi
   0x0000000000400ee9 <+9>:     callq  0x401338 <strings_not_equal>
   0x0000000000400eee <+14>:    test   %eax,%eax
   0x0000000000400ef0 <+16>:    je     0x400ef7 <phase_1+23>
   0x0000000000400ef2 <+18>:    callq  0x40143a <explode_bomb>
   0x0000000000400ef7 <+23>:    add    $0x8,%rsp
   0x0000000000400efb <+27>:    retq
```

우선 0x402400의 내용을 %esi로 옮긴다.
그리고 strings_not_equl 함수를 실행해서, 우리가 입력한 값(%rdi)과 %rsi의 값을 비교한다.
만약 다르다면 %eax에 1이 들어 있을테고 <+16>의 점프 코드가 실행되지 않는다.
그래서 <+18>의 explode_bombdㅣ 실행되서 폭탄이 터진다.
그러므로 %eax에 0이 들어가야 한다.
%eax에 0이 들어가려면 %esi와 동일한 값을 입력해줘야 한다.
`x/s 0x402400`으로 0x402400의 값을 출력해보면 "Border relations with Canada have never been better."이 나온다.
그러므로 phase_1에선 위와 같은 문장을 입력해주면 된다.

원본 코드를 유추해보면 아래와 같다.

```
void phase_1 (string input) {
    string key = "Border relations with Canada have never been better.";
    if (strings_not_equal)(input, key) {
        explode_bomb();
    } else {
        return;
    }
}

int strings_not_equal(strint s1, string s2) {
    int s1_len = string_length(s1);
    int s2_len = string_length(s2)
    int index = 0;
    if(s1_len == s2_len) {
        while (s1[index] != '\0') {
            if (s1[index] == s2[index]) {
                ++index;
            } else {
                return 1;
            }
        }
        return 0;
    } else {
        return 1;
    }
}
```

### phase 2

disas로 phase_2의 어셈블리 코드를 보면 아래처럼 나온다.

```
(gdb) disas phase_2
Dump of assembler code for function phase_2:
   0x0000000000400efc <+0>:     push   %rbp
   0x0000000000400efd <+1>:     push   %rbx
   0x0000000000400efe <+2>:     sub    $0x28,%rsp
   0x0000000000400f02 <+6>:     mov    %rsp,%rsi
   0x0000000000400f05 <+9>:     callq  0x40145c <read_six_numbers>
   0x0000000000400f0a <+14>:    cmpl   $0x1,(%rsp)
   0x0000000000400f0e <+18>:    je     0x400f30 <phase_2+52>
   0x0000000000400f10 <+20>:    callq  0x40143a <explode_bomb>
   0x0000000000400f15 <+25>:    jmp    0x400f30 <phase_2+52>
   0x0000000000400f17 <+27>:    mov    -0x4(%rbx),%eax
   0x0000000000400f1a <+30>:    add    %eax,%eax
   0x0000000000400f1c <+32>:    cmp    %eax,(%rbx)
   0x0000000000400f1e <+34>:    je     0x400f25 <phase_2+41>
   0x0000000000400f20 <+36>:    callq  0x40143a <explode_bomb>
   0x0000000000400f25 <+41>:    add    $0x4,%rbx
   0x0000000000400f29 <+45>:    cmp    %rbp,%rbx
   0x0000000000400f2c <+48>:    jne    0x400f17 <phase_2+27>
   0x0000000000400f2e <+50>:    jmp    0x400f3c <phase_2+64>
   0x0000000000400f30 <+52>:    lea    0x4(%rsp),%rbx
   0x0000000000400f35 <+57>:    lea    0x18(%rsp),%rbp
   0x0000000000400f3a <+62>:    jmp    0x400f17 <phase_2+27>
   0x0000000000400f3c <+64>:    add    $0x28,%rsp
   0x0000000000400f40 <+68>:    pop    %rbx
   0x0000000000400f41 <+69>:    pop    %rbp
   0x0000000000400f42 <+70>:    retq
```

read_six_numbers 함수는 아래처럼 나온다.

```
(gdb) disas read_six_numbers
Dump of assembler code for function read_six_numbers:
   0x000000000040145c <+0>:     sub    $0x18,%rsp
   0x0000000000401460 <+4>:     mov    %rsi,%rdx
   0x0000000000401463 <+7>:     lea    0x4(%rsi),%rcx
   0x0000000000401467 <+11>:    lea    0x14(%rsi),%rax
   0x000000000040146b <+15>:    mov    %rax,0x8(%rsp)
   0x0000000000401470 <+20>:    lea    0x10(%rsi),%rax
   0x0000000000401474 <+24>:    mov    %rax,(%rsp)
   0x0000000000401478 <+28>:    lea    0xc(%rsi),%r9
   0x000000000040147c <+32>:    lea    0x8(%rsi),%r8
   0x0000000000401480 <+36>:    mov    $0x4025c3,%esi
   0x0000000000401485 <+41>:    mov    $0x0,%eax
   0x000000000040148a <+46>:    callq  0x400bf0 <__isoc99_sscanf@plt>
   0x000000000040148f <+51>:    cmp    $0x5,%eax
   0x0000000000401492 <+54>:    jg     0x401499 <read_six_numbers+61>
   0x0000000000401494 <+56>:    callq  0x40143a <explode_bomb>
   0x0000000000401499 <+61>:    add    $0x18,%rsp
   0x000000000040149d <+65>:    retq
```

read_six_numbers 함수를 보면 <+32>까지는 스택 프레임을 만드는 과정이다.
다시 말해서 변수 값을 받아와서 레지스터에 저장하는 과정이다.
<+36>부터 코드가 시작되는데, 0x4025c3의 값을 %esi로 옮긴다.
`x/s 0x4025c3`으로 해당 주소 안의 내용을 보면 "%d %d %d %d %d %d"가 나온다.
모양을 보면 알겠지만 이는 <+46>의 sscanf에 사용하는 문자열이다.
sscanf는 성공적으로 저장한 변수의 갯수를 반환한다.
그러므로 %eax에는 sscanf로 받아들인 변수의 갯수가 들어간다.
<+51>, <+54>는 5 < %eax 인 경우 <+61>로 점프한다.
만약 점프가 일어나지 않으면 <+56>에서 폭탄이 터진다.

정리하자면 read_six_numbers는 scanf로 수를 읽어들인다.
이때 읽어들인 수가 6개보다 작은 경우 폭탄이 터지므로, 우리는 6개 이상의 변수를 입력해야 한다.

다음으로 phase_2를 보자.
read_six_numbers 다음에 일어나는 과정을 오른쪽에 적어줬다.

```
(gdb) disas phase_2
Dump of assembler code for function phase_2:
   0x0000000000400efc <+0>:     push   %rbp
   0x0000000000400efd <+1>:     push   %rbx
   0x0000000000400efe <+2>:     sub    $0x28,%rsp
   0x0000000000400f02 <+6>:     mov    %rsp,%rsi
   0x0000000000400f05 <+9>:     callq  0x40145c <read_six_numbers>
   0x0000000000400f0a <+14>:    cmpl   $0x1,(%rsp)                      compare (%rsp) and 1
   0x0000000000400f0e <+18>:    je     0x400f30 <phase_2+52>            if (%rsp == 1) goto <+52>
   0x0000000000400f10 <+20>:    callq  0x40143a <explode_bomb>          else explode_bomb
   0x0000000000400f15 <+25>:    jmp    0x400f30 <phase_2+52>
   0x0000000000400f17 <+27>:    mov    -0x4(%rbx),%eax                  %eax = %rbx - 0x4
   0x0000000000400f1a <+30>:    add    %eax,%eax                        %eax += %eax
   0x0000000000400f1c <+32>:    cmp    %eax,(%rbx)                      (%rbx) 와 %eax를 비교
   0x0000000000400f1e <+34>:    je     0x400f25 <phase_2+41>            같다면 <+41>로 점프
   0x0000000000400f20 <+36>:    callq  0x40143a <explode_bomb>          아니라면 폭발
   0x0000000000400f25 <+41>:    add    $0x4,%rbx                        %rbx += 0x4
   0x0000000000400f29 <+45>:    cmp    %rbp,%rbx                        %rbx와 %rbp 비교
   0x0000000000400f2c <+48>:    jne    0x400f17 <phase_2+27>            다르면 <+27>로 점프
   0x0000000000400f2e <+50>:    jmp    0x400f3c <phase_2+64>            같으면 <+64>로 점프
   0x0000000000400f30 <+52>:    lea    0x4(%rsp),%rbx                   %rbx = %rsp + 0x4
   0x0000000000400f35 <+57>:    lea    0x18(%rsp),%rbp                  %rbp = %rsp + 0x18
   0x0000000000400f3a <+62>:    jmp    0x400f17 <phase_2+27>            <+27>로 점프
   0x0000000000400f3c <+64>:    add    $0x28,%rsp                       스택 공간 반납
   0x0000000000400f40 <+68>:    pop    %rbx
   0x0000000000400f41 <+69>:    pop    %rbp
   0x0000000000400f42 <+70>:    retq
```

간단히 말해 폭탄이 터지지 않으려면 스택의 처음 값이 1이어야 한다.
그리고 반복문으로 스택의 다음값이 이전의 값의 2배가 되는지 확인한다.
마지막에 %rsp + 0x18에 도착하면 반복문이 종료된다.
그러므로 입력값이 매번 2배가 되는 `1 2 4 8 16 32`가 정답이다.

```
int phase_2 (string input) {
    int a[6];
    int n = read_six_numbers(input, a);
    if (a[0] != 1) {
        explode_bomb();
    }
    int* cur_address = &a[1];
    int* last_address = &a[5];
    do {
        int temp = cur_address[-1];
        temp += temp;
        if (temp != *cur_address) {
            explode_bomb();
        }
        ++cur_address;
    } while (cur_address != last_address)
}
```

### phase_3

```
(gdb) disas phase_3
Dump of assembler code for function phase_3:
   0x0000000000400f43 <+0>:     sub    $0x18,%rsp
   0x0000000000400f47 <+4>:     lea    0xc(%rsp),%rcx
   0x0000000000400f4c <+9>:     lea    0x8(%rsp),%rdx
   0x0000000000400f51 <+14>:    mov    $0x4025cf,%esi                   "%d %d"
   0x0000000000400f56 <+19>:    mov    $0x0,%eax
   0x0000000000400f5b <+24>:    callq  0x400bf0 <__isoc99_sscanf@plt>   int n = scanf(input, "%d %d", &x, &y)
   0x0000000000400f60 <+29>:    cmp    $0x1,%eax                        compare n and 1
   0x0000000000400f63 <+32>:    jg     0x400f6a <phase_3+39>            if(n > 1) goto <+39>
   0x0000000000400f65 <+34>:    callq  0x40143a <explode_bomb>          else bomb
   0x0000000000400f6a <+39>:    cmpl   $0x7,0x8(%rsp)                   compare %rsp + 0x8 and 7
   0x0000000000400f6f <+44>:    ja     0x400fad <phase_3+106>           if(%rsp + 0x8 > 7) goto <+106>
   0x0000000000400f71 <+46>:    mov    0x8(%rsp),%eax
   0x0000000000400f75 <+50>:    jmpq   *0x402470(,%rax,8)               choose label for switch
   0x0000000000400f7c <+57>:    mov    $0xcf,%eax
   0x0000000000400f81 <+62>:    jmp    0x400fbe <phase_3+123>           switch loop
   0x0000000000400f83 <+64>:    mov    $0x2c3,%eax
   0x0000000000400f88 <+69>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400f8a <+71>:    mov    $0x100,%eax
   0x0000000000400f8f <+76>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400f91 <+78>:    mov    $0x185,%eax
   0x0000000000400f96 <+83>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400f98 <+85>:    mov    $0xce,%eax
   0x0000000000400f9d <+90>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400f9f <+92>:    mov    $0x2aa,%eax
   0x0000000000400fa4 <+97>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400fa6 <+99>:    mov    $0x147,%eax
   0x0000000000400fab <+104>:   jmp    0x400fbe <phase_3+123>
   0x0000000000400fad <+106>:   callq  0x40143a <explode_bomb>
   0x0000000000400fb2 <+111>:   mov    $0x0,%eax
   0x0000000000400fb7 <+116>:   jmp    0x400fbe <phase_3+123>
   0x0000000000400fb9 <+118>:   mov    $0x137,%eax
   0x0000000000400fbe <+123>:   cmp    0xc(%rsp),%eax                   %eax와 (%rsp + 0xc)의 값 비교
   0x0000000000400fc2 <+127>:   je     0x400fc9 <phase_3+134>           if(%eax == (%rsp + 0xc)) goto <+134>
   0x0000000000400fc4 <+129>:   callq  0x40143a <explode_bomb>          else bomb
   0x0000000000400fc9 <+134>:   add    $0x18,%rsp
   0x0000000000400fcd <+138>:   retq
```

보다시피 비교와 점프가 굉장히 많다.
이는 switch문의 특징이므로 원본 코드에 switch가 들어있음을 유추할 수 있다.
다음으로 코드를 보면 0x4025cf를 sscanf에 사용하고 있다.
`x/s 0x4025cf`를 보면 "%d %d"가 들어 있음을 알 수 있다.
그러므로 2개의 값을 입력받는데, 입력이 2개보다 적으면 폭탄이 터진다.
<+44>를 보면 (%rsp + 0x8)의 값이 7이하가 되어야 한다.
그리고 (%rsp + 0x8)의 값을 사용해 switch문이 어디로 가야할지 정한다.
<+50>을 보면 (8 * %rax + *0x402470) 주소에 있는 곳으로 점프한다.
%rax에는 (%rsp + 0x8)이 들어있으므로, (8 * (%rsp + 0x8) + *0x400f7c)의 값으로 점프한다.
스위치문은 %eax에 특정 값을 넣어주는 내용들이다.
모두 <+123>으로 가고 있으므로 <+123>을 보자.
<+123>, <+127>을 보면 %eax에 넣어준 값과 (%rsp + 0xc)의 값이 같아야 한다.
여기서 (%rsp + 0xc)는 스택의 위치로 보아 2번째로 넣어준 값이다.

정리하면 첫 번째 변수는 점프 위치를 지정하는데 사용한다.
그리고 점프 위치에서 받아온 값이 두 번째로 넣어준 값과 일치해야 한다.
switch문의 점프 위치가 여러 개 있기 때문에 답도 하나가 아니다.
<+57>, <+64>, <+71>, <+78>, <+85>, <+92>, <+99>, <+118>로 점프할 수 있다.
그러므로 0x402470부터 8개의 값을 확인해서 어디로 점프하는지 알아보자.
`x/8gx 0x402470`으로 결과를 보면 아래처럼 된다.

```
(gdb) x/8gx 0x402470
0x402470:       0x0000000000400f7c      0x0000000000400fb9
0x402480:       0x0000000000400f83      0x0000000000400f8a
0x402490:       0x0000000000400f91      0x0000000000400f98
0x4024a0:       0x0000000000400f9f      0x0000000000400fa6
```

다시 말해서 첫 번째 입력값에 따라 아래처럼 결과가 나온다.

| input | address | jump   |
| ----- | ------- | ------ |
| 0     | 400f7c  | <+57>  |
| 1     | 400fb9  | <+118> |
| 2     | 400f83  | <+64>  |
| 3     | 400f8a  | <+71>  |
| 4     | 400f91  | <+78>  |
| 5     | 400f98  | <+85>  |
| 6     | 400f9f  | <+92>  |
| 7     | 400fa6  | <+99>  |

풀이는 이중 <+57>만 적도록 하겠다.
<+57>로 점프하려면 첫 번째 입력값이 1이 되어야 한다.
<+57>을 보면 두 번째 변수가 0xcf와 같아야 한다.
두 번째 입력값을 계산해보면 16 \_ 12 + 15 = 207이 되어야 한다.
그러므로 입력값은 "0 207"이 되어야 한다.
나머지 경우도 같은 방법으로 정하면 아래처럼 된다.

```
0 207
1 311
2 707
3 256
4 389
5 206
6 682
7 327
```

위의 값 중에 하나를 선택해 입력하면 phase_3가 종료된다.

### phase_4

phase_4의 코드는 아래와 같다.

```
(gdb) disas phase_4
Dump of assembler code for function phase_4:
   0x000000000040100c <+0>:     sub    $0x18,%rsp
   0x0000000000401010 <+4>:     lea    0xc(%rsp),%rcx                       int b;
   0x0000000000401015 <+9>:     lea    0x8(%rsp),%rdx                       int a;
   0x000000000040101a <+14>:    mov    $0x4025cf,%esi                       *0x4025cf = "%d %d"
   0x000000000040101f <+19>:    mov    $0x0,%eax
   0x0000000000401024 <+24>:    callq  0x400bf0 <__isoc99_sscanf@plt>       int n = sscanf(input, "%d %d", &a, &b)
   0x0000000000401029 <+29>:    cmp    $0x2,%eax                            if (n != 2)
   0x000000000040102c <+32>:    jne    0x401035 <phase_4+41>                    explode_bomb
   0x000000000040102e <+34>:    cmpl   $0xe,0x8(%rsp)                       if (a <= 14)
   0x0000000000401033 <+39>:    jbe    0x40103a <phase_4+46>                    goto +46
   0x0000000000401035 <+41>:    callq  0x40143a <explode_bomb>              else explode_bomb
   0x000000000040103a <+46>:    mov    $0xe,%edx
   0x000000000040103f <+51>:    mov    $0x0,%esi
   0x0000000000401044 <+56>:    mov    0x8(%rsp),%edi
   0x0000000000401048 <+60>:    callq  0x400fce <func4>
   0x000000000040104d <+65>:    test   %eax,%eax                            if (func4(a, 0, 14))
   0x000000000040104f <+67>:    jne    0x401058 <phase_4+76>                    explode_bomb
   0x0000000000401051 <+69>:    cmpl   $0x0,0xc(%rsp)                       if (b == 0)
   0x0000000000401056 <+74>:    je     0x40105d <phase_4+81>                    goto +81
   0x0000000000401058 <+76>:    callq  0x40143a <explode_bomb>              else explode_bomb
   0x000000000040105d <+81>:    add    $0x18,%rsp
   0x0000000000401061 <+85>:    retq
```

앞서 했던 것처럼 0x4025cf는 sscanf에 쓰는 문자열일 것이다.
해당 주소 안의 내용을 확인해보자.

```
(gdb) x/s 0x4025cf
0x4025cf:       "%d %d"
```

역시 두 값을 받아주기 위해 쓰인 문자열이다.
그 아래부터는 이전과 비슷한 반복이다.
첫 번째 입력받는 수가 14이하여야 하고, b가 0이어야 폭탄이 터지지 않는다.
그리고 func4를 실행한 결과가 0이 되어야 폭탄이 터지지 않는다는 것을 알 수 있다.
func4와 관련된 부분은 <+46> ~ <+60>인데, 살펴보면 %edi, %esi, %edx에 값을 넣어주고 있다.
함수를 호출할 때 쓰이는 레지스터 순서가 %rdi, %rsi, %rdx, %rcx, %r8, %r9 순서인 것을 기억해보면, 변수가 3개 쓰인 것을 알 수 있다.
첫 번째 변수 %edi에 처음 입력받은 수 a가 들어간다.
두 번째 변수는 %esi는 0이 들어가고, 세 번째 변수는 14가 들어간다.
다음으로 func4가 어떤 함수인지 살펴보자.

```
(gdb) disas func4
Dump of assembler code for function func4:
   0x0000000000400fce <+0>:     sub    $0x8,%rsp
   0x0000000000400fd2 <+4>:     mov    %edx,%eax                result = z
   0x0000000000400fd4 <+6>:     sub    %esi,%eax                result -= y
   0x0000000000400fd6 <+8>:     mov    %eax,%ecx                int d = result
   0x0000000000400fd8 <+10>:    shr    $0x1f,%ecx               d = d >> 31
   0x0000000000400fdb <+13>:    add    %ecx,%eax                result += d
   0x0000000000400fdd <+15>:    sar    %eax                     result >> 1
   0x0000000000400fdf <+17>:    lea    (%rax,%rsi,1),%ecx       d = result + y
   0x0000000000400fe2 <+20>:    cmp    %edi,%ecx                if(d <= x)
   0x0000000000400fe4 <+22>:    jle    0x400ff2 <func4+36>          goto +36
   0x0000000000400fe6 <+24>:    lea    -0x1(%rcx),%edx          z = (d - 1)
   0x0000000000400fe9 <+27>:    callq  0x400fce <func4>         int result = func4(x, y, z)
   0x0000000000400fee <+32>:    add    %eax,%eax                result += result
   0x0000000000400ff0 <+34>:    jmp    0x401007 <func4+57>      goto +57
   0x0000000000400ff2 <+36>:    mov    $0x0,%eax                result = 0
   0x0000000000400ff7 <+41>:    cmp    %edi,%ecx                if(d >= x)
   0x0000000000400ff9 <+43>:    jge    0x401007 <func4+57>          goto +57
   0x0000000000400ffb <+45>:    lea    0x1(%rcx),%esi           y = (d + 1)
   0x0000000000400ffe <+48>:    callq  0x400fce <func4>         result = func4(x, y, z)
   0x0000000000401003 <+53>:    lea    0x1(%rax,%rax,1),%eax    result = result + result + 1
   0x0000000000401007 <+57>:    add    $0x8,%rsp                return result
   0x000000000040100b <+61>:    retq
```

func4의 원본 코드는 아래와 같다.

```
int func4(int x, int y, int z) {
    int result = z - y;
    int d = result;
    d = d >> 31;
    result += d;
    result = result >> 1;
    d = result + y;
    if(d > x) {
        result = func4(x, y, d-1);
        result += result;
    } else {
        result = 0;
        if (d < x) {
            result = func4(x, d+1, z);
            result = result + result + 1
        }
    }
    return result;
}
```

원본 코드를 봐도 복잡한데 if문이 나오기 전까지 y와 z의 대소 관계에 따라 2가지 경우가 있다.
우선 $y \le z$인 경우 result가 양수이므로 d >> 31이 0이 된다.
그러므로 d = result + y = (z - y) / 2 + y = (z + y) / 2가 된다.
다음으로 $y > z$인 경우 result가 음수이므로 d >> 31이 1이 된다.
그러므로 d = (z - y + 1) / 2 + y = (z + y + 1) / 2다.

그 밑의 if문을 보면 재귀함수 형태가 된다.
재귀함수가 종료되는 순간은 d == x인 경우고, 이때 result = 0이 된다.
if문 안의 내용은 d와 x의 대소관계에 따라 안의 함수의 값을 2배 하거나, 2배로 하고 1을 더한다.
함수 형태를 보면 평균에 가까운 값을 y, z 위치에 넣어줘서 x와 같은 값이 나오도록 하고 있다는 것을 알 수 있다.
솔직히 func4가 어떤 함수인지는 잘 모르겠지만 우리는 결과만 내면 되므로 넘어가겠다.
phase_4를 기억해보면 result가 0이 되어야 폭탄이 터지지 않으므로 0이 되도록 하는 x를 찾아보자.

phase_4에서 호출할 때 func4(a, 0, 14)를 사용했다.
이 값을 그대로 사용하면 d = 7이다.
제일 쉬운 것은 a에 7을 넣어주면 된다.
그 외에 가능한 답은 아래에 적어놨다.

```
0 0
1 0
3 0
7 0
```

### phase_5

```
(gdb) disas phase_5
Dump of assembler code for function phase_5:
   0x0000000000401062 <+0>:     push   %rbx
   0x0000000000401063 <+1>:     sub    $0x20,%rsp
   0x0000000000401067 <+5>:     mov    %rdi,%rbx                        %rbx = %rdi = input
   0x000000000040106a <+8>:     mov    %fs:0x28,%rax
   0x0000000000401073 <+17>:    mov    %rax,0x18(%rsp)
   0x0000000000401078 <+22>:    xor    %eax,%eax
   0x000000000040107a <+24>:    callq  0x40131b <string_length>
   0x000000000040107f <+29>:    cmp    $0x6,%eax                        if(string_length(input) == 6)
   0x0000000000401082 <+32>:    je     0x4010d2 <phase_5+112>               goto <+112>
   0x0000000000401084 <+34>:    callq  0x40143a <explode_bomb>          else bomb
   0x0000000000401089 <+39>:    jmp    0x4010d2 <phase_5+112>
   0x000000000040108b <+41>:    movzbl (%rbx,%rax,1),%ecx               %ecx = (%rax + %rbx)
   0x000000000040108f <+45>:    mov    %cl,(%rsp)                       (%rsp) = %cl
   0x0000000000401092 <+48>:    mov    (%rsp),%rdx                      %rdx = (%rsp)
   0x0000000000401096 <+52>:    and    $0xf,%edx                        %edx = %edx & 0xf
   0x0000000000401099 <+55>:    movzbl 0x4024b0(%rdx),%edx              %edx = (%rdx + 0x4024b0)
   0x00000000004010a0 <+62>:    mov    %dl,0x10(%rsp,%rax,1)            (%rsp + %rax + 0x10) = %dl
   0x00000000004010a4 <+66>:    add    $0x1,%rax                        %rax += 0x1
   0x00000000004010a8 <+70>:    cmp    $0x6,%rax                        if(%rax != 6)
   0x00000000004010ac <+74>:    jne    0x40108b <phase_5+41>                goto <+41>
   0x00000000004010ae <+76>:    movb   $0x0,0x16(%rsp)                  (%rsp+0x16) = 0x0
   0x00000000004010b3 <+81>:    mov    $0x40245e,%esi                   %esi = 0x40245e
   0x00000000004010b8 <+86>:    lea    0x10(%rsp),%rdi                  %rdi = %rsp + 0x10
   0x00000000004010bd <+91>:    callq  0x401338 <strings_not_equal>     if(strings_not_equal(%rdi, %esi))
   0x00000000004010c2 <+96>:    test   %eax,%eax
   0x00000000004010c4 <+98>:    je     0x4010d9 <phase_5+119>               goto <+119>
   0x00000000004010c6 <+100>:   callq  0x40143a <explode_bomb>          else explode_bomb
   0x00000000004010cb <+105>:   nopl   0x0(%rax,%rax,1)                 if(!(%rax+%rax))
   0x00000000004010d0 <+110>:   jmp    0x4010d9 <phase_5+119>               goto <+119>
   0x00000000004010d2 <+112>:   mov    $0x0,%eax                        %eax = 0
   0x00000000004010d7 <+117>:   jmp    0x40108b <phase_5+41>            goto <+41>
   0x00000000004010d9 <+119>:   mov    0x18(%rsp),%rax
   0x00000000004010de <+124>:   xor    %fs:0x28,%rax
   0x00000000004010e7 <+133>:   je     0x4010ee <phase_5+140>
   0x00000000004010e9 <+135>:   callq  0x400b30 <__stack_chk_fail@plt>
   0x00000000004010ee <+140>:   add    $0x20,%rsp
   0x00000000004010f2 <+144>:   pop    %rbx
   0x00000000004010f3 <+145>:   retq
```

이 문제는 for문을 디에셈블한 코드다.
우선 <+34>까지는 문자열이 6개인지 체크하는 과정으로, 이전에도 나온 것이므로 설명은 생략한다.
문자열이 6개가 맞다면 %eax = 0으로 초기화하고 <+41>로 점프한다.
<+41> ~ <+74>까지 반복문으로, 앞서 %eax를 초기화 했다는 점과 <+66>에서 %rax를 1씩 증가시켜준다는 점에서 %rax가 반복자임을 알 수 있다.
반복문은 %rax가 6이 될때까지 반복하므로 6번 순환한다.

반복문을 벗어나면 strings_not_equal을 사용해서 %rdi와 %esi의 문자를 비교한다.
이때 두 문자가 같은 경우에만 폭탄이 터지지 않는다.
여기서 %esi에는 0x40245e의 문자열이 복사되어 있다.
`x/s 0x40245e`로 보면 "flyers"가 들어있다.
그러므로 우리의 목적은 반복문이 %rdi에 "flyers"를 넣도록 만드는 일이다.

이제 반복문을 자세히 분석해보자.
우선 우리가 입력한 input은 %rbx에 저장되어 있다.
그리고 %rax가 0으로 초기화 되어 있고, 각 단계마다 1씩 증가한다.
<+41>을 보면 (%rax + %rbx)를 계산하고 있다.
이는 곧 문자열의 각 글자를 추출하는 것으로, input[%rax]를 의미한다.
그 아래로는 계산이 이뤄지고 있는데, 일단은 넘어가고 <+62>를 보자.
<+62>를 보면 (%rsp + %rax + 0x10)에 %dl을 넣어준다.
위를 조금 고치면 (%rsp + 0x10 + %rax)인데, 이를 보아 %rsp + 0x10 위치에 문자열을 넣고 있음을 알 수 있다.
<+76>을 보면 문자열 6개 입력이 끝난 뒤에 0을 넣어주고 있다.
그리고 <+86>에서 해당 문자열을 %rdi로 옮겨서 strings_not_equal에 사용한다.
결국 반복문에서 저장하는 문자열이 strings_not_equal의 변수가 된다.

이제 중요한 것은 저장되는값 %dl이다.
전달되는 값을 대입해서 어떤 값이 들어가는지 알아보자.
%dl = %edx & 0xff = (%rdx + 0x4024b0) & 0xff = ((%edx & 0xf) + 0x4024b0)) & 0xff = ((%cl & 0xf) + 0x4024b0) & 0xff = (((%rax + %rbx) & 0xf) + 0x4024b0) & 0xff
이 식들을 의미를 알아보자.
우선 (%rax + %rbx)는 우리가 입력한 input에서 한 글자씩 보는 것을 의미한다.
그리고 & 0xf는 이를 16으로 나눈 나머지를 구한다.
그러므로 (%rax + %rbx) & 0xf는 문자열에서 한 글자씩 가져와서 16으로 나눈 나머지가 된다.
다음으로 나머지를 0x4024b0에 더해주고 있다.
이는 곧 0x4024b0에서 나머지 만큼 떨어진 위치의 글자를 가져온다.
결국 %dl은 input의 각 글자를 16으로 나눈 나머지를 계산한다.
그리고 0x4024b0에서 나머지만큼 떨어진 위치에서 글자를 가져오고 있다.
0x4024b0에서 가져올 수 있는 글자의 범위는 곧 나머지의 범위(0~15)로 정해진다.
해당 위치에서 16글자만 보면 아래처럼 된다.

```
(gdb) x/16bd 0x4024b0
0x4024b0 <array.3449>:  109     97      100     117     105     101     114     115
0x4024b8 <array.3449+8>:        110     102     111     116     118     98      121     108
```

이들은 각각 maduiersnfotvbyl다.
이 중에서 "flyers"를 만들어야 하므로, 102 108 121 101 114 115가 되도록 해야 한다.
이들은 각각 0x4024b0로 부터 9, 15, 14, 5, 6, 7 번째 숫자다.
그러므로 (%rax + %rbx) & 0xf가 각각 9, 15, 14, 5, 6, 7이 되어야 한다.
이는 곧 우리가 입력한 input의 각 문자를 16으로 나눈 나머지가 위와 같이 나와야 한다는 의미다.
결국 우리가 입력한 문자열을 각각 16으로 나눈 나머지가 9, 15, 14, 5, 6, 7이 되어야 한다.
그러므로 입력해야 할 문자는 위의 수에 16의 배수를 더한 수가 된다.
아스키 코드 상 A~Z는 65~90, a~z는 97~122이므로 이 범위 안에서 구해주는 것이 제일 깔끔하다.
4배를 적용한 경우 입력값은 "IONEFG"가 되고, 6배를 적용하면 "ionefg"가 된다.

### phase_6

```
(gdb) disas phase_6
Dump of assembler code for function phase_6:
   0x00000000004010f4 <+0>:     push   %r14
   0x00000000004010f6 <+2>:     push   %r13
   0x00000000004010f8 <+4>:     push   %r12
   0x00000000004010fa <+6>:     push   %rbp
   0x00000000004010fb <+7>:     push   %rbx
   0x00000000004010fc <+8>:     sub    $0x50,%rsp
   0x0000000000401100 <+12>:    mov    %rsp,%r13
   0x0000000000401103 <+15>:    mov    %rsp,%rsi
   0x0000000000401106 <+18>:    callq  0x40145c <read_six_numbers>
   0x000000000040110b <+23>:    mov    %rsp,%r14                    %r14 = %rsp
   0x000000000040110e <+26>:    mov    $0x0,%r12d                   %r12d = 0
   0x0000000000401114 <+32>:    mov    %r13,%rbp                    %rbp = %r13
   0x0000000000401117 <+35>:    mov    0x0(%r13),%eax               %eax = %r13
   0x000000000040111b <+39>:    sub    $0x1,%eax                    %eax -= 1
   0x000000000040111e <+42>:    cmp    $0x5,%eax                    if(%eax <= 5)
   0x0000000000401121 <+45>:    jbe    0x401128 <phase_6+52>            goto <+52>
   0x0000000000401123 <+47>:    callq  0x40143a <explode_bomb>      else explode_bomb
   0x0000000000401128 <+52>:    add    $0x1,%r12d                   %r12d += 1
   0x000000000040112c <+56>:    cmp    $0x6,%r12d                   if(%r12d == 6)
   0x0000000000401130 <+60>:    je     0x401153 <phase_6+95>            goto <+95>
   0x0000000000401132 <+62>:    mov    %r12d,%ebx                   %ebx = %r12d
   0x0000000000401135 <+65>:    movslq %ebx,%rax                    %rax = %ebx
   0x0000000000401138 <+68>:    mov    (%rsp,%rax,4),%eax           %eax = (%rsp + %rax * 4)
   0x000000000040113b <+71>:    cmp    %eax,0x0(%rbp)               if((%rbp) != %eax)
   0x000000000040113e <+74>:    jne    0x401145 <phase_6+81>            goto <+81>
   0x0000000000401140 <+76>:    callq  0x40143a <explode_bomb>      else explode_bomb
   0x0000000000401145 <+81>:    add    $0x1,%ebx                    %ebx += 1
   0x0000000000401148 <+84>:    cmp    $0x5,%ebx                    if(%ebx <= 5)
   0x000000000040114b <+87>:    jle    0x401135 <phase_6+65>            goto <+65>
   0x000000000040114d <+89>:    add    $0x4,%r13                    %r13 += 4
   0x0000000000401151 <+93>:    jmp    0x401114 <phase_6+32>        goto <+32>
   0x0000000000401153 <+95>:    lea    0x18(%rsp),%rsi              %rsi = (%rsp + 0x18)
   0x0000000000401158 <+100>:   mov    %r14,%rax                    %rax = %r14
   0x000000000040115b <+103>:   mov    $0x7,%ecx                    %ecx = 7
   0x0000000000401160 <+108>:   mov    %ecx,%edx                    %edx = %ecx
   0x0000000000401162 <+110>:   sub    (%rax),%edx                  %edx -= (%rax)
   0x0000000000401164 <+112>:   mov    %edx,(%rax)                  (%rax) = %edx
   0x0000000000401166 <+114>:   add    $0x4,%rax                    %rax += 4
   0x000000000040116a <+118>:   cmp    %rsi,%rax                    if(%rax != %rsi)
   0x000000000040116d <+121>:   jne    0x401160 <phase_6+108>           goto <+108>
   0x000000000040116f <+123>:   mov    $0x0,%esi                    %esi = 0
   0x0000000000401174 <+128>:   jmp    0x401197 <phase_6+163>       goto <+163>
   0x0000000000401176 <+130>:   mov    0x8(%rdx),%rdx               %rdx = (%rdx + 0x8)
   0x000000000040117a <+134>:   add    $0x1,%eax                    %eax += 1
   0x000000000040117d <+137>:   cmp    %ecx,%eax                    if(%eax != %ecx)
   0x000000000040117f <+139>:   jne    0x401176 <phase_6+130>           goto <+130>
   0x0000000000401181 <+141>:   jmp    0x401188 <phase_6+148>       goto <+148>
   0x0000000000401183 <+143>:   mov    $0x6032d0,%edx               %edx = 0x6032d0
   0x0000000000401188 <+148>:   mov    %rdx,0x20(%rsp,%rsi,2)       (%rsp + %rsi * 2 + 0x20) = %rdx
   0x000000000040118d <+153>:   add    $0x4,%rsi                    %rsi += 4
   0x0000000000401191 <+157>:   cmp    $0x18,%rsi                   if(%rsi == 24)
   0x0000000000401195 <+161>:   je     0x4011ab <phase_6+183>           goto <+183>
   0x0000000000401197 <+163>:   mov    (%rsp,%rsi,1),%ecx           %ecx = (%rsp + %rsi)
   0x000000000040119a <+166>:   cmp    $0x1,%ecx                    if(%ecx <= 1)
   0x000000000040119d <+169>:   jle    0x401183 <phase_6+143>           goto <+143>
   0x000000000040119f <+171>:   mov    $0x1,%eax                    %eax = 1
   0x00000000004011a4 <+176>:   mov    $0x6032d0,%edx               %edx = 0x6032d0
   0x00000000004011a9 <+181>:   jmp    0x401176 <phase_6+130>       goto <+130>
   0x00000000004011ab <+183>:   mov    0x20(%rsp),%rbx              %rbx = (%rsp + 0x20)
   0x00000000004011b0 <+188>:   lea    0x28(%rsp),%rax              %rax = (%rsp + 0x28)
   0x00000000004011b5 <+193>:   lea    0x50(%rsp),%rsi              %rsi = (%rsp + 0x50)
   0x00000000004011ba <+198>:   mov    %rbx,%rcx                    %rcx = %rbx
   0x00000000004011bd <+201>:   mov    (%rax),%rdx                  %rdx = (%rax)
   0x00000000004011c0 <+204>:   mov    %rdx,0x8(%rcx)               (%rcx + 0x8) = %rdx
   0x00000000004011c4 <+208>:   add    $0x8,%rax                    %rax += 8
   0x00000000004011c8 <+212>:   cmp    %rsi,%rax                    if(%rax == %rsi)
   0x00000000004011cb <+215>:   je     0x4011d2 <phase_6+222>           goto <+222>
   0x00000000004011cd <+217>:   mov    %rdx,%rcx                    %rcx = %rdx
   0x00000000004011d0 <+220>:   jmp    0x4011bd <phase_6+201>       goto <+201>
   0x00000000004011d2 <+222>:   movq   $0x0,0x8(%rdx)               (%rdx + 0x8) = 0
   0x00000000004011da <+230>:   mov    $0x5,%ebp                    %ebp = 5
   0x00000000004011df <+235>:   mov    0x8(%rbx),%rax               %rax = (%rbx + 0x8)
   0x00000000004011e3 <+239>:   mov    (%rax),%eax                  %eax = (%rax)
   0x00000000004011e5 <+241>:   cmp    %eax,(%rbx)                  if((%rbx) >= %eax)
   0x00000000004011e7 <+243>:   jge    0x4011ee <phase_6+250>           goto <+250>
   0x00000000004011e9 <+245>:   callq  0x40143a <explode_bomb>      else explode_bomb
   0x00000000004011ee <+250>:   mov    0x8(%rbx),%rbx               %rbx = (%rbx + 0x8)
   0x00000000004011f2 <+254>:   sub    $0x1,%ebp                    %ebp -= 1
   0x00000000004011f5 <+257>:   jne    0x4011df <phase_6+235>       goto <+235>
   0x00000000004011f7 <+259>:   add    $0x50,%rsp
   0x00000000004011fb <+263>:   pop    %rbx
   0x00000000004011fc <+264>:   pop    %rbp
   0x00000000004011fd <+265>:   pop    %r12
   0x00000000004011ff <+267>:   pop    %r13
   0x0000000000401201 <+269>:   pop    %r14
   0x0000000000401203 <+271>:   retq
```

보다시피 phase_6는 굉장히 길다.
그렇기 때문에 연관있는 부분을 잘라서 설명하겠다.

```
   0x00000000004010f4 <+0>:     push   %r14
   0x00000000004010f6 <+2>:     push   %r13
   0x00000000004010f8 <+4>:     push   %r12
   0x00000000004010fa <+6>:     push   %rbp
   0x00000000004010fb <+7>:     push   %rbx
   0x00000000004010fc <+8>:     sub    $0x50,%rsp
   0x0000000000401100 <+12>:    mov    %rsp,%r13
   0x0000000000401103 <+15>:    mov    %rsp,%rsi
   0x0000000000401106 <+18>:    callq  0x40145c <read_six_numbers>
```

위는 phase_6를 시작해서 스택 프레임을 만들고 read_six_nubmers를 호출하는 부분이다.
스택에 저장된 입력값을 편의상 a[0] ~ a[5]라고 하겠다.

```
   0x000000000040110b <+23>:    mov    %rsp,%r14                    %r14 = %rsp
   0x000000000040110e <+26>:    mov    $0x0,%r12d                   %r12d = 0
   0x0000000000401114 <+32>:    mov    %r13,%rbp                    %rbp = %r13
   0x0000000000401117 <+35>:    mov    0x0(%r13),%eax               %eax = (%r13 + 0x0)
   0x000000000040111b <+39>:    sub    $0x1,%eax                    %eax -= 1
   0x000000000040111e <+42>:    cmp    $0x5,%eax                    if(%eax <= 5)
   0x0000000000401121 <+45>:    jbe    0x401128 <phase_6+52>            goto <+52>
   0x0000000000401123 <+47>:    callq  0x40143a <explode_bomb>      else explode_bomb
   0x0000000000401128 <+52>:    add    $0x1,%r12d                   %r12d += 1
   0x000000000040112c <+56>:    cmp    $0x6,%r12d                   if(%r12d == 6)
   0x0000000000401130 <+60>:    je     0x401153 <phase_6+95>            goto <+95>
   0x0000000000401132 <+62>:    mov    %r12d,%ebx                   %ebx = %r12d
   0x0000000000401135 <+65>:    movslq %ebx,%rax                    %rax = %ebx
   0x0000000000401138 <+68>:    mov    (%rsp,%rax,4),%eax           %eax = (%rsp + %rax * 4)
   0x000000000040113b <+71>:    cmp    %eax,0x0(%rbp)               if((%rbp) != %eax)
   0x000000000040113e <+74>:    jne    0x401145 <phase_6+81>            goto <+81>
   0x0000000000401140 <+76>:    callq  0x40143a <explode_bomb>      else explode_bomb
   0x0000000000401145 <+81>:    add    $0x1,%ebx                    %ebx += 1
   0x0000000000401148 <+84>:    cmp    $0x5,%ebx                    if(%ebx <= 5)
   0x000000000040114b <+87>:    jle    0x401135 <phase_6+65>            goto <+65>
   0x000000000040114d <+89>:    add    $0x4,%r13                    %r13 += 4
   0x0000000000401151 <+93>:    jmp    0x401114 <phase_6+32>        goto <+32>
```

위는 하나의 반복문을 만든다.
<+26>과 <+52>를 보면 %r12d가 반복자로 사용됨을 알 수 있다.
<+32>, <+35>는 %r13으로 값이 정해진다.
처음에는 a[0]가 들어있지만, 나중에 <+89> 때문에 a[1], a[2]... 가 순서대로 들어간다.
그리고 <+35>를 보면 %r13 안의 이진수가 그대로 %eax로 들어간다.
이는 곧 unsigned로 해석한다는 의미다.
그리고 <+56>을 보면 반복자가 6이 되는 순간에 끝이나도록 설정되었다.
<+62>를 보면 %ebx = %r12d를 넣어줬다.
편의상 %r12d는 i, %ebx = j라고 하겠다.
<+68>의 식을 보면 %eax = (%rsp + %rax _ 4) = (%rsp + %ebx _ 4)다.
앞서 %r12d가 반복자라고 했으므로 위는 배열 a[j]를 나타낸 부분인 것을 알 수 있다.
<+71>은 if((%rbp) != a[j]) 인데, 처음의 %rbp = %r13 = %rsp 이므로 (%rbp) = a[0]다.
그래서 <+71>은 if(a[0] != a[j])가 된다.
<+81>을 보면 %ebx += 1이므로 j += 1이다.
그리고 <+84>에서 j가 5 이하면 <+65>로 돌아가고 있다.
이를 보아 <+65> ~ <+87>도 반복문인 것을 알 수 있다.
<+89>는 %r13 += 4를 해주고 있는데, 이는 앞서 %rbp, %eax를 초기화하는데 사용됐었다.
그리고 (%rbp)가 a[0]였으므로 +4를 해준다는 것은 다음 배열 a[1]을 본다는 의미다.
마지막으로 <+32> ~ <+93>이 하나의 반복문이다.

상당히 복잡하지만 C코드로 바꿔주면 좀 더 이해하기 쉽다.

```
for(int i = 0; 1;) {                    // <+26> ~ <+56>
    unsigned int t = a[i] - 1;
    if(t > 5) explode_bomb();           // <+42>
    i += 1;
    if(i == 6) break;
    for(int j = i; j <= 5; ++j) {       // <+62> ~ <+87>
        if(a[i] == a[j]) {
            explode_bomb();
        }
    }
}
```

위 코드로 알 수 있는 것은 각 a[i]가 $a[i] \le 6$를 만족해야 한다는 점과, 서로 달라야 한다는 것이다.
여기서 a[i]를 unsigned로 받아들이므로 $a[i] \in \{1, 2, 3, 4, 5, 6\}$이다.

반복문을 탈출하면 <+95>로 넘어간다.

```
   0x0000000000401153 <+95>:    lea    0x18(%rsp),%rsi              %rsi = (%rsp + 0x18)
   0x0000000000401158 <+100>:   mov    %r14,%rax                    %rax = %r14
   0x000000000040115b <+103>:   mov    $0x7,%ecx                    %ecx = 7
   0x0000000000401160 <+108>:   mov    %ecx,%edx                    %edx = %ecx
   0x0000000000401162 <+110>:   sub    (%rax),%edx                  %edx -= (%rax)
   0x0000000000401164 <+112>:   mov    %edx,(%rax)                  (%rax) = %edx
   0x0000000000401166 <+114>:   add    $0x4,%rax                    %rax += 4
   0x000000000040116a <+118>:   cmp    %rsi,%rax                    if(%rax != %rsi)
   0x000000000040116d <+121>:   jne    0x401160 <phase_6+108>           goto <+108>
```

%rsi에 전달되는 내용은 &a[6]이다.
이전 %r14에 들어간 내용은 <+23>을 보면 &a[0]다.
이후 코드를 보면 계산을 진행 한 후에 if문으로 점프하고 있다.
이런 형태는 do-while문이다.
<+108> ~ <+121> 코드의 원본은 아래처럼 된다.

```
int* a_6 = a + 6;       // <+95>
int* a_i = a;           // <+100>
do {
    *a_i = 7 - *a_i
    a_i += 1;
} while(a_i != a_6);
```

이 코드는 각 a[i] = 7 - a[i]로 바꾸는 코드다.

```
   0x000000000040116f <+123>:   mov    $0x0,%esi                    %esi = 0
   0x0000000000401174 <+128>:   jmp    0x401197 <phase_6+163>       goto <+163>
   0x0000000000401176 <+130>:   mov    0x8(%rdx),%rdx               %rdx = (%rdx + 0x8)
   0x000000000040117a <+134>:   add    $0x1,%eax                    %eax += 1
   0x000000000040117d <+137>:   cmp    %ecx,%eax                    if(%eax != %ecx)
   0x000000000040117f <+139>:   jne    0x401176 <phase_6+130>           goto <+130>
   0x0000000000401181 <+141>:   jmp    0x401188 <phase_6+148>       goto <+148>
   0x0000000000401183 <+143>:   mov    $0x6032d0,%edx               %edx = 0x6032d0
   0x0000000000401188 <+148>:   mov    %rdx,0x20(%rsp,%rsi,2)       (%rsp + %rsi * 2 + 0x20) = %rdx
   0x000000000040118d <+153>:   add    $0x4,%rsi                    %rsi += 4
   0x0000000000401191 <+157>:   cmp    $0x18,%rsi                   if(%rsi == 24)
   0x0000000000401195 <+161>:   je     0x4011ab <phase_6+183>           goto <+183>
   0x0000000000401197 <+163>:   mov    (%rsp,%rsi,1),%ecx           %ecx = (%rsp + %rsi)
   0x000000000040119a <+166>:   cmp    $0x1,%ecx                    if(%ecx <= 1)
   0x000000000040119d <+169>:   jle    0x401183 <phase_6+143>           goto <+143>
   0x000000000040119f <+171>:   mov    $0x1,%eax                    %eax = 1
   0x00000000004011a4 <+176>:   mov    $0x6032d0,%edx               %edx = 0x6032d0
   0x00000000004011a9 <+181>:   jmp    0x401176 <phase_6+130>       goto <+130>
```

위 코드를 흐름에 따라서 그대로 적으면 아래처럼 된다.
다만 아래는 가독성을 위해 적은 것으로 실제 작동하는 코드가 아니다.

```
void* esi = 0;              // <+123>
while (esi != 24){
    int value = *(int*)(&a[0] + esi);       // <+163>
    if(value <= 1) {             // <+166>
        address = 0x6032d0;      // <+143>

    } else {
        int cnt = 1;            // <+171>
        address = 0x6032d0;     // <+176>
        do {
            address += 0x8;   // <+130>
            cnt += 1;           // <+134>
        } while(cnt != value)
    }
    *(&a[0] + 2 * esi + 0x20) = address;    // <+148>
    esi += 4;                               // <+153>
}
```

다른 부분은 그리 어렵진 않지만 <+163>이 상당히 까다롭다.
이 부분은 a의 주소에 esi를 더한 주소의 값을 꺼낸다.
이를 코드로 변환하려면 (void\*)를 타입 변환으로 사용해줘야 한다.
<+148>을 보면 a의 주소에 32를 더한 위치를 시작으로 새로운 값을 저장한다.
위에서 새로 만드는 배열을 b라고 하자.
여기서 b는 안에 값으로 주소를 가지고 있다.
어떤 내용이 들어있는지 보기 위해 `x/12gx 0x6032d0`를 입력하면 아래처럼 나온다.

```
(gdb) x/12gx 0x6032d0
0x6032d0 <node1>:       0x000000010000014c      0x00000000006032e0
0x6032e0 <node2>:       0x00000002000000a8      0x00000000006032f0
0x6032f0 <node3>:       0x000000030000039c      0x0000000000603300
0x603300 <node4>:       0x00000004000002b3      0x0000000000603310
0x603310 <node5>:       0x00000005000001dd      0x0000000000603320
0x603320 <node6>:       0x00000006000001bb      0x0000000000000000
```

보면 2개의 값을 가지고 있는데, 2번째 값이 다음 주소를 가리킨다는 것을 볼 수 있다.
그러므로 b와 address는 linked list 형태를 띄고 있다.
새로운 자료형 T를 만들고 정리하면 아래처럼 된다.

```
struct T {
    long data;
    T* next;
};

T* b[6];
for (int i = 0; i != 6; ++i) {
  T* address = 0x6032d0;
  int value = a[i];
  int count = 1;
  while (count != value) {
    address = address->next;
    ++count;
  }
  b[i] = address;
}
```

결국 위 코드는 a[i]로 새로운 b[i]를 만들어내는데 사용한다.
a[i]에 들어 있는 값에 따라서 b[i]의 순서가 정해진다.
예를 들어서 a[i] = 3이라면, 0x6032d0에서 2번 건너간다.
그래서 b[i] = 0x6032f0이 된다.

```
   0x00000000004011ab <+183>:   mov    0x20(%rsp),%rbx              %rbx = (%rsp + 0x20)
   0x00000000004011b0 <+188>:   lea    0x28(%rsp),%rax              %rax = (%rsp + 0x28)
   0x00000000004011b5 <+193>:   lea    0x50(%rsp),%rsi              %rsi = (%rsp + 0x50)
   0x00000000004011ba <+198>:   mov    %rbx,%rcx                    %rcx = %rbx
   0x00000000004011bd <+201>:   mov    (%rax),%rdx                  %rdx = (%rax)
   0x00000000004011c0 <+204>:   mov    %rdx,0x8(%rcx)               (%rcx + 0x8) = %rdx
   0x00000000004011c4 <+208>:   add    $0x8,%rax                    %rax += 8
   0x00000000004011c8 <+212>:   cmp    %rsi,%rax                    if(%rax == %rsi)
   0x00000000004011cb <+215>:   je     0x4011d2 <phase_6+222>           goto <+222>
   0x00000000004011cd <+217>:   mov    %rdx,%rcx                    %rcx = %rdx
   0x00000000004011d0 <+220>:   jmp    0x4011bd <phase_6+201>       goto <+201>
```

위는 b[i]를 사용하고 있는데, 간단히 말해 b[i]를 바뀐 순서에 따라 연결해주고 있다.
아래 코드를 보면 좀 더 명시적으로 알 수 있다.

```
T** curr = &b[1];
T** tail = &b[6];
T*  prev =  b[0];
while (curr != tail) {
    prev->next = *curr;
    curr += 1;
    prev = *curr;
}
```

```
   0x00000000004011d2 <+222>:   movq   $0x0,0x8(%rdx)               (%rdx + 0x8) = 0
   0x00000000004011da <+230>:   mov    $0x5,%ebp                    %ebp = 5
   0x00000000004011df <+235>:   mov    0x8(%rbx),%rax               %rax = (%rbx + 0x8)
   0x00000000004011e3 <+239>:   mov    (%rax),%eax                  %eax = (%rax)
   0x00000000004011e5 <+241>:   cmp    %eax,(%rbx)                  if((%rbx) >= %eax)
   0x00000000004011e7 <+243>:   jge    0x4011ee <phase_6+250>           goto <+250>
   0x00000000004011e9 <+245>:   callq  0x40143a <explode_bomb>      else explode_bomb
   0x00000000004011ee <+250>:   mov    0x8(%rbx),%rbx               %rbx = (%rbx + 0x8)
   0x00000000004011f2 <+254>:   sub    $0x1,%ebp                    %ebp -= 1
   0x00000000004011f5 <+257>:   jne    0x4011df <phase_6+235>       goto <+235>
```

```
b[5]->next = 0;
T* curr = b;
int i = 5;
while (i != 0) {
    T* next = curr->next;
    if (curr->data < next->data)
        explode_bomb();
    curr = curr->next;
    --i;
}
```

위 코드는 새로 정렬한 b[i]를 앞뒤로 검사한다.
만약 b[i]가 오름차순으로 정렬되었다면 폭탄이 터진다.
그러므로 정렬된 b는 안의 값이 감소하는 순서로 정렬되어야 한다.
다시 b에 저장된 내용을 보자.

```
(gdb) x/12gx 0x6032d0
0x6032d0 <node1>:       0x000000010000014c      0x00000000006032e0
0x6032e0 <node2>:       0x00000002000000a8      0x00000000006032f0
0x6032f0 <node3>:       0x000000030000039c      0x0000000000603300
0x603300 <node4>:       0x00000004000002b3      0x0000000000603310
0x603310 <node5>:       0x00000005000001dd      0x0000000000603320
0x603320 <node6>:       0x00000006000001bb      0x0000000000000000
```

여기서 값이 감소하는 순서로 정렬해야 하므로 3 4 5 6 1 2 순서로 정렬되어야 한다.
앞서 a[i] = 7 - a[i]를 했던 것을 기억해야 한다.
결국 입력값은 4 3 2 1 6 5가 된다.
