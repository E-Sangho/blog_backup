---
layout: post
title: "CS:APP Lab 2 Bomb Lab"
date: Thu Jan 20 11:03:10 JST 2022
categories: CSAPP
tag:
toc: true
---

## 1. Introduction

CS:APP의 유명한 과제인 Bomb lab이다.
bomb 파일을 실행하면 6개의 phase가 나온다.
각 페이즈마다 문자열을 입력할 수 있는데, 정답이면 다음 페이즈로 넘어가고, 오답이면 폭탄이 터진다.
파일을 실행해도 정답에 관한 정보를 전혀 얻을 수 없으므로, 어셈블리 코드를 분석해야 한다.
추천하는 어셈블리 코드를 분석하는 방법은 크게 3가지가 있다.

1. gdb
2. lldb
3. objdump

gdb는 책이나 강의에서 이미 소개한 것으로 강의에서도 가장 추천하는 방법이다.
그렇지만 gdb를 따로 설치해야 하고, 버전에 따라 오류가 나는 경우도 있다.
특히 맥이나 가상 머신을 사용하는 경우 종종 오류가 생기곤 한다.
그래서 맥유저는 lldb를 추천하는데, gdb와 명령어가 다를 뿐 사용법은 유사하다.

만약 처음에 Docker를 사용하는 방법을 따랐다면 Docker에서 gdb, lldb를 둘 다 사용할 수 있으므로 문제 없다.
본인은 Docker에서 gdb를 사용해서 풀었다.

## 2. Apple silicon

arm을 사용하는 맥 유저라면 과제를 푸는데 심각한 지장이 있다.
gdb를 사용해서 파일을 실행할 수 없고, Docker에서도 작동하지 않기 때문이다.
대신에 UTM이나 Parallels 같은 가상 머신을 사용해야 한다.
아니면 책의 문제를 푸는 것도 추천하는데, 각 phase가 책의 문제와 같은 내용을 공유하기 때문이다.
아래는 각 페이즈 별 주제다.

-   phase1: comparison
-   phase2: loops
-   phase3: switch
-   phase4: recursion
-   phase5: pointers and array
-   phase6: sorting linked lists

## 3. gdb

아래는 간단한 gdb 명령어다.

-   run:
-   break:
-   disas
-   x/s {메모리주소}
-   x/d {}

## 4. Solve

`gdb bomb`로 bomb 파일을 gdb로 열어준다.
그리고 `disas main`으로 main 코드의 어셈블리 코드를 출력한다.
아래는 출력 결과다.

```
   0x0000000000400da0 <+0>:     push   %rbx
   0x0000000000400da1 <+1>:     cmp    $0x1,%edi
   0x0000000000400da4 <+4>:     jne    0x400db6 <main+22>
   0x0000000000400da6 <+6>:     mov    0x20299b(%rip),%rax        # 0x603748 <stdin@@GLIBC_2.2.5>
   0x0000000000400dad <+13>:    mov    %rax,0x2029b4(%rip)        # 0x603768 <infile>
   0x0000000000400db4 <+20>:    jmp    0x400e19 <main+121>
   0x0000000000400db6 <+22>:    mov    %rsi,%rbx
   0x0000000000400db9 <+25>:    cmp    $0x2,%edi
   0x0000000000400dbc <+28>:    jne    0x400df8 <main+88>
   0x0000000000400dbe <+30>:    mov    0x8(%rsi),%rdi
   0x0000000000400dc2 <+34>:    mov    $0x4022b4,%esi
   0x0000000000400dc7 <+39>:    callq  0x400c10 <fopen@plt>
   0x0000000000400dcc <+44>:    mov    %rax,0x202995(%rip)        # 0x603768 <infile>
   0x0000000000400dd3 <+51>:    test   %rax,%rax
   0x0000000000400dd6 <+54>:    jne    0x400e19 <main+121>
   0x0000000000400dd8 <+56>:    mov    0x8(%rbx),%rcx
   0x0000000000400ddc <+60>:    mov    (%rbx),%rdx
   0x0000000000400ddf <+63>:    mov    $0x4022b6,%esi
   0x0000000000400de4 <+68>:    mov    $0x1,%edi
   0x0000000000400de9 <+73>:    callq  0x400c00 <__printf_chk@plt>
   0x0000000000400dee <+78>:    mov    $0x8,%edi
   0x0000000000400df3 <+83>:    callq  0x400c20 <exit@plt>
   0x0000000000400df8 <+88>:    mov    (%rsi),%rdx
   0x0000000000400dfb <+91>:    mov    $0x4022d3,%esi
   0x0000000000400e00 <+96>:    mov    $0x1,%edi
   0x0000000000400e05 <+101>:   mov    $0x0,%eax
   0x0000000000400e0a <+106>:   callq  0x400c00 <__printf_chk@plt>
   0x0000000000400e0f <+111>:   mov    $0x8,%edi
   0x0000000000400e14 <+116>:   callq  0x400c20 <exit@plt>
   0x0000000000400e19 <+121>:   callq  0x4013a2 <initialize_bomb>
   0x0000000000400e1e <+126>:   mov    $0x402338,%edi
   0x0000000000400e23 <+131>:   callq  0x400b10 <puts@plt>
   0x0000000000400e28 <+136>:   mov    $0x402378,%edi
   0x0000000000400e2d <+141>:   callq  0x400b10 <puts@plt>
   0x0000000000400e32 <+146>:   callq  0x40149e <read_line>
   0x0000000000400e37 <+151>:   mov    %rax,%rdi
   0x0000000000400e3a <+154>:   callq  0x400ee0 <phase_1>
   0x0000000000400e3f <+159>:   callq  0x4015c4 <phase_defused>
   0x0000000000400e44 <+164>:   mov    $0x4023a8,%edi
   0x0000000000400e49 <+169>:   callq  0x400b10 <puts@plt>
   0x0000000000400e4e <+174>:   callq  0x40149e <read_line>
   0x0000000000400e53 <+179>:   mov    %rax,%rdi
   0x0000000000400e56 <+182>:   callq  0x400efc <phase_2>
   0x0000000000400e5b <+187>:   callq  0x4015c4 <phase_defused>
   0x0000000000400e60 <+192>:   mov    $0x4022ed,%edi
   0x0000000000400e65 <+197>:   callq  0x400b10 <puts@plt>
   0x0000000000400e6a <+202>:   callq  0x40149e <read_line>
   0x0000000000400e6f <+207>:   mov    %rax,%rdi
   0x0000000000400e72 <+210>:   callq  0x400f43 <phase_3>
   0x0000000000400e77 <+215>:   callq  0x4015c4 <phase_defused>
   0x0000000000400e7c <+220>:   mov    $0x40230b,%edi
   0x0000000000400e81 <+225>:   callq  0x400b10 <puts@plt>
   0x0000000000400e86 <+230>:   callq  0x40149e <read_line>
   0x0000000000400e8b <+235>:   mov    %rax,%rdi
   0x0000000000400e8e <+238>:   callq  0x40100c <phase_4>
   0x0000000000400e93 <+243>:   callq  0x4015c4 <phase_defused>
   0x0000000000400e98 <+248>:   mov    $0x4023d8,%edi
   0x0000000000400e9d <+253>:   callq  0x400b10 <puts@plt>
   0x0000000000400ea2 <+258>:   callq  0x40149e <read_line>
   0x0000000000400ea7 <+263>:   mov    %rax,%rdi
   0x0000000000400eaa <+266>:   callq  0x401062 <phase_5>
   0x0000000000400eaf <+271>:   callq  0x4015c4 <phase_defused>
   0x0000000000400eb4 <+276>:   mov    $0x40231a,%edi
   0x0000000000400eb9 <+281>:   callq  0x400b10 <puts@plt>
   0x0000000000400ebe <+286>:   callq  0x40149e <read_line>
   0x0000000000400ec3 <+291>:   mov    %rax,%rdi
   0x0000000000400ec6 <+294>:   callq  0x4010f4 <phase_6>
   0x0000000000400ecb <+299>:   callq  0x4015c4 <phase_defused>
   0x0000000000400ed0 <+304>:   mov    $0x0,%eax
   0x0000000000400ed5 <+309>:   pop    %rbx
   0x0000000000400ed6 <+310>:   retq
```

결과를 보면 phase_1~6까지 존재하는 것을 볼 수 있다.

### phase 1

`disas phase_1`으로 phase_1을 보자.

```
(gdb) disas phase_1
Dump of assembler code for function phase_1:
   0x0000000000400ee0 <+0>:     sub    $0x8,%rsp
   0x0000000000400ee4 <+4>:     mov    $0x402400,%esi
   0x0000000000400ee9 <+9>:     callq  0x401338 <strings_not_equal>
   0x0000000000400eee <+14>:    test   %eax,%eax
   0x0000000000400ef0 <+16>:    je     0x400ef7 <phase_1+23>
   0x0000000000400ef2 <+18>:    callq  0x40143a <explode_bomb>
   0x0000000000400ef7 <+23>:    add    $0x8,%rsp
   0x0000000000400efb <+27>:    retq
```

코드를 보면 스택 포인터를 8 증가시켜서 스택에 자리를 만든다.
그리고 mov로 %esi에 0x402400을 넣어준다.
callq로 strings_not_equal을 호출한다.
`disas strings_not_equal`로 함수를 열어보면 아래처럼 나온다.

```
(gdb) disas strings_not_equal
Dump of assembler code for function strings_not_equal:
   0x0000000000401338 <+0>:     push   %r12
   0x000000000040133a <+2>:     push   %rbp
   0x000000000040133b <+3>:     push   %rbx
   0x000000000040133c <+4>:     mov    %rdi,%rbx
   0x000000000040133f <+7>:     mov    %rsi,%rbp
   0x0000000000401342 <+10>:    callq  0x40131b <string_length>
   0x0000000000401347 <+15>:    mov    %eax,%r12d
   0x000000000040134a <+18>:    mov    %rbp,%rdi
   0x000000000040134d <+21>:    callq  0x40131b <string_length>
   0x0000000000401352 <+26>:    mov    $0x1,%edx
   0x0000000000401357 <+31>:    cmp    %eax,%r12d
   0x000000000040135a <+34>:    jne    0x40139b <strings_not_equal+99>
   0x000000000040135c <+36>:    movzbl (%rbx),%eax
   0x000000000040135f <+39>:    test   %al,%al
   0x0000000000401361 <+41>:    je     0x401388 <strings_not_equal+80>
   0x0000000000401363 <+43>:    cmp    0x0(%rbp),%al
   0x0000000000401366 <+46>:    je     0x401372 <strings_not_equal+58>
   0x0000000000401368 <+48>:    jmp    0x40138f <strings_not_equal+87>
   0x000000000040136a <+50>:    cmp    0x0(%rbp),%al
   0x000000000040136d <+53>:    nopl   (%rax)
   0x0000000000401370 <+56>:    jne    0x401396 <strings_not_equal+94>
   0x0000000000401372 <+58>:    add    $0x1,%rbx
   0x0000000000401376 <+62>:    add    $0x1,%rbp
   0x000000000040137a <+66>:    movzbl (%rbx),%eax
   0x000000000040137d <+69>:    test   %al,%al
   0x000000000040137f <+71>:    jne    0x40136a <strings_not_equal+50>
   0x0000000000401381 <+73>:    mov    $0x0,%edx
   0x0000000000401386 <+78>:    jmp    0x40139b <strings_not_equal+99>
   0x0000000000401388 <+80>:    mov    $0x0,%edx
   0x000000000040138d <+85>:    jmp    0x40139b <strings_not_equal+99>
   0x000000000040138f <+87>:    mov    $0x1,%edx
   0x0000000000401394 <+92>:    jmp    0x40139b <strings_not_equal+99>
   0x0000000000401396 <+94>:    mov    $0x1,%edx
   0x000000000040139b <+99>:    mov    %edx,%eax
   0x000000000040139d <+101>:   pop    %rbx
   0x000000000040139e <+102>:   pop    %rbp
   0x000000000040139f <+103>:   pop    %r12
   0x00000000004013a1 <+105>:   retq
```

여기서 string_length의 코드는 아래와 같다.

```
(gdb) disas string_length
Dump of assembler code for function string_length:
   0x000000000040131b <+0>:     cmpb   $0x0,(%rdi)
   0x000000000040131e <+3>:     je     0x401332 <string_length+23>
   0x0000000000401320 <+5>:     mov    %rdi,%rdx
   0x0000000000401323 <+8>:     add    $0x1,%rdx
   0x0000000000401327 <+12>:    mov    %edx,%eax
   0x0000000000401329 <+14>:    sub    %edi,%eax
   0x000000000040132b <+16>:    cmpb   $0x0,(%rdx)
   0x000000000040132e <+19>:    jne    0x401323 <string_length+8>
   0x0000000000401330 <+21>:    repz retq
   0x0000000000401332 <+23>:    mov    $0x0,%eax
   0x0000000000401337 <+28>:    retq
```

이제 코드를 분석해볼텐데 중요한 것은 어디에 값을 받아서, 어떤 값을 반환하는지다.

우선 string_length는 이름 그대로 문자열의 길이를 알아낸다.
(%rdi)에 문자열이 들어 있고, %rdi의 주소를 1칸씩 옮기면서 0이 나오는 곳을 찾는다.
문자열의 제일 끝에는 0이 있으므로 0이 나온다는 것은 곧 문자열이 끝난다는 뜻이다.
그리고 그동안 구한 길이를 %eax에 반환해준다.

다음으로 strings_not_equal을 보자.
%rdi에 첫 번째 변수를 받고, %rbx에 2번째 변수를 받아서 계산을 진행한다.
어떻게 진행되는지 오른쪽에 설명을 적어놨다.

```
   0x0000000000401338 <+0>:     push   %r12                                 스택에 레지스터 값을 저장한다.
   0x000000000040133a <+2>:     push   %rbp                                 스택에 레지스터 값을 저장한다.
   0x000000000040133b <+3>:     push   %rbx                                 스택에 레지스터 값을 저장한다.
   0x000000000040133c <+4>:     mov    %rdi,%rbx                            첫 번째 변수(%rdi)를 %rbx로 옮긴다.
   0x000000000040133f <+7>:     mov    %rsi,%rbp                            두 번째 변수(%rsi)를 %rbp로 옮긴다.
   0x0000000000401342 <+10>:    callq  0x40131b <string_length>             string_length 함수를 호출한다. 첫 번째 변수((%rdi))의 길이를 구한다.
   0x0000000000401347 <+15>:    mov    %eax,%r12d                           반환된 (%rdi)의 길이를 %r12d로 옮긴다.
   0x000000000040134a <+18>:    mov    %rbp,%rdi                            두 번째 변수를 %rdi로 옮긴다.
   0x000000000040134d <+21>:    callq  0x40131b <string_length>             string_length 호출해서 두 번째 변수의 길이를 구한다.
   0x0000000000401352 <+26>:    mov    $0x1,%edx                            %edx를 1로 바꾼다.
   0x0000000000401357 <+31>:    cmp    %eax,%r12d                           첫 번째 변수와 두 번째 변수의 길이를 비교한다.
   0x000000000040135a <+34>:    jne    0x40139b <strings_not_equal+99>      다르다면 <+99>로 점프
   0x000000000040135c <+36>:    movzbl (%rbx),%eax                          길이가 같다면 첫 번째 변수의 값을 %eax로 옮긴다.
   0x000000000040135f <+39>:    test   %al,%al
   0x0000000000401361 <+41>:    je     0x401388 <strings_not_equal+80>      %al(첫 번째 첫 글자)이 0이라면 <+80>으로 점프
   0x0000000000401363 <+43>:    cmp    0x0(%rbp),%al
   0x0000000000401366 <+46>:    je     0x401372 <strings_not_equal+58>      첫 번째 변수의 첫 글자가 두 번째 변수가 같다면 <+58>로 점프
   0x0000000000401368 <+48>:    jmp    0x40138f <strings_not_equal+87>      아니라면 <+87>로 점프
   0x000000000040136a <+50>:    cmp    0x0(%rbp),%al
   0x000000000040136d <+53>:    nopl   (%rax)
   0x0000000000401370 <+56>:    jne    0x401396 <strings_not_equal+94>
   0x0000000000401372 <+58>:    add    $0x1,%rbx                            첫 번째 변수의 다음 글자를 검색하기 위해 1추가
   0x0000000000401376 <+62>:    add    $0x1,%rbp                            두 번째 변수의 다음 글자를 검색하기 위해 1추가
   0x000000000040137a <+66>:    movzbl (%rbx),%eax                          <+71>까지 앞서 했듯이 글자를 비교하기 위해 준비
   0x000000000040137d <+69>:    test   %al,%al
   0x000000000040137f <+71>:    jne    0x40136a <strings_not_equal+50>      첫 번째 변수의 이번 글자가 0이 아니면 <+50>으로 점프해서 반복
   0x0000000000401381 <+73>:    mov    $0x0,%ed복
   0x0000000000401386 <+78>:    jmp    0x40139b <strings_not_equal+99>
   0x0000000000401388 <+80>:    mov    $0x0,%edx
   0x000000000040138d <+85>:    jmp    0x40139b <strings_not_equal+99>
   0x000000000040138f <+87>:    mov    $0x1,%edx
   0x0000000000401394 <+92>:    jmp    0x40139b <strings_not_equal+99>
   0x0000000000401396 <+94>:    mov    $0x1,%edx
   0x000000000040139b <+99>:    mov    %edx,%eax
   0x000000000040139d <+101>:   pop    %rbx
   0x000000000040139e <+102>:   pop    %rbp
   0x000000000040139f <+103>:   pop    %r12
   0x00000000004013a1 <+105>:   retq                                        두 글자가 다르면 1, 같으면 0을 반환한다.
```

책의 문제를 풀어봤다면 별다른 문제 없이 해석할 수 있을 것이다.
간단히 요약해서 strings_not_equal은 첫 번째 문자(%rdi)와 두 번째 문자(%rsi)를 비교한다.
처음에는 길이를 비교하고, 다음엔 앞에서부터 글자를 하나씩 비교한다.
그리고 두 문자열이 같으면 0을, 다르면 1을 반환한다.

다시 처음으로 돌아가서 phase_1을 보자.

```
   0x0000000000400ee0 <+0>:     sub    $0x8,%rsp
   0x0000000000400ee4 <+4>:     mov    $0x402400,%esi
   0x0000000000400ee9 <+9>:     callq  0x401338 <strings_not_equal>
   0x0000000000400eee <+14>:    test   %eax,%eax
   0x0000000000400ef0 <+16>:    je     0x400ef7 <phase_1+23>
   0x0000000000400ef2 <+18>:    callq  0x40143a <explode_bomb>
   0x0000000000400ef7 <+23>:    add    $0x8,%rsp
   0x0000000000400efb <+27>:    retq
```

우선 0x402400의 내용을 %esi로 옮긴다.
그리고 strings_not_equl 함수를 실행해서, 우리가 입력한 값(%rdi)과 %rsi의 값을 비교한다.
만약 다르다면 %eax에 1이 들어 있을테고 <+16>의 점프 코드가 실행되지 않는다.
그래서 <+18>의 explode_bombdㅣ 실행되서 폭탄이 터진다.
그러므로 %eax에 0이 들어가야 한다.
%eax에 0이 들어가려면 %esi와 동일한 값을 입력해줘야 한다.
`x/s 0x402400`으로 0x402400의 값을 출력해보면 "Border relations with Canada have never been better."이 나온다.
그러므로 phase_1에선 위와 같은 문장을 입력해주면 된다.

### phase 2

disas로 phase_2의 어셈블리 코드를 보면 아래처럼 나온다.

```
(gdb) disas phase_2
Dump of assembler code for function phase_2:
   0x0000000000400efc <+0>:     push   %rbp
   0x0000000000400efd <+1>:     push   %rbx
   0x0000000000400efe <+2>:     sub    $0x28,%rsp
   0x0000000000400f02 <+6>:     mov    %rsp,%rsi
   0x0000000000400f05 <+9>:     callq  0x40145c <read_six_numbers>
   0x0000000000400f0a <+14>:    cmpl   $0x1,(%rsp)
   0x0000000000400f0e <+18>:    je     0x400f30 <phase_2+52>
   0x0000000000400f10 <+20>:    callq  0x40143a <explode_bomb>
   0x0000000000400f15 <+25>:    jmp    0x400f30 <phase_2+52>
   0x0000000000400f17 <+27>:    mov    -0x4(%rbx),%eax
   0x0000000000400f1a <+30>:    add    %eax,%eax
   0x0000000000400f1c <+32>:    cmp    %eax,(%rbx)
   0x0000000000400f1e <+34>:    je     0x400f25 <phase_2+41>
   0x0000000000400f20 <+36>:    callq  0x40143a <explode_bomb>
   0x0000000000400f25 <+41>:    add    $0x4,%rbx
   0x0000000000400f29 <+45>:    cmp    %rbp,%rbx
   0x0000000000400f2c <+48>:    jne    0x400f17 <phase_2+27>
   0x0000000000400f2e <+50>:    jmp    0x400f3c <phase_2+64>
   0x0000000000400f30 <+52>:    lea    0x4(%rsp),%rbx
   0x0000000000400f35 <+57>:    lea    0x18(%rsp),%rbp
   0x0000000000400f3a <+62>:    jmp    0x400f17 <phase_2+27>
   0x0000000000400f3c <+64>:    add    $0x28,%rsp
   0x0000000000400f40 <+68>:    pop    %rbx
   0x0000000000400f41 <+69>:    pop    %rbp
   0x0000000000400f42 <+70>:    retq
```

read_six_numbers 함수는 아래처럼 나온다.

```
(gdb) disas read_six_numbers
Dump of assembler code for function read_six_numbers:
   0x000000000040145c <+0>:     sub    $0x18,%rsp
   0x0000000000401460 <+4>:     mov    %rsi,%rdx
   0x0000000000401463 <+7>:     lea    0x4(%rsi),%rcx
   0x0000000000401467 <+11>:    lea    0x14(%rsi),%rax
   0x000000000040146b <+15>:    mov    %rax,0x8(%rsp)
   0x0000000000401470 <+20>:    lea    0x10(%rsi),%rax
   0x0000000000401474 <+24>:    mov    %rax,(%rsp)
   0x0000000000401478 <+28>:    lea    0xc(%rsi),%r9
   0x000000000040147c <+32>:    lea    0x8(%rsi),%r8
   0x0000000000401480 <+36>:    mov    $0x4025c3,%esi
   0x0000000000401485 <+41>:    mov    $0x0,%eax
   0x000000000040148a <+46>:    callq  0x400bf0 <__isoc99_sscanf@plt>
   0x000000000040148f <+51>:    cmp    $0x5,%eax
   0x0000000000401492 <+54>:    jg     0x401499 <read_six_numbers+61>
   0x0000000000401494 <+56>:    callq  0x40143a <explode_bomb>
   0x0000000000401499 <+61>:    add    $0x18,%rsp
   0x000000000040149d <+65>:    retq
```

read_six_numbers 함수를 보면 <+32>까지는 스택 프레임을 만드는 과정이다.
다시 말해서 변수 값을 받아와서 레지스터에 저장하는 과정이다.
<+36>부터 코드가 시작되는데, 0x4025c3의 값을 %esi로 옮긴다.
`x/s 0x4025c3`으로 해당 주소 안의 내용을 보면 "%d %d %d %d %d %d"가 나온다.
모양을 보면 알겠지만 이는 <+46>의 scanf에 사용하는 문자열이다.
scanf는 성공적으로 저장한 변수의 갯수를 반환한다.
그러므로 %eax에는 scanf로 받아들인 변수의 갯수가 들어간다.
<+51>, <+54>는 5 < %eax 인 경우 <+61>로 점프한다.
만약 점프가 일어나지 않으면 <+56>에서 폭탄이 터진다.

정리하자면 read_six_numbers는 scanf로 수를 읽어들인다.
이때 읽어들인 수가 6개보다 작은 경우 폭탄이 터지므로, 우리는 6개 이상의 변수를 입력해야 한다.

다음으로 phase_2를 보자.

```
(gdb) disas phase_2
Dump of assembler code for function phase_2:
   0x0000000000400efc <+0>:     push   %rbp
   0x0000000000400efd <+1>:     push   %rbx
   0x0000000000400efe <+2>:     sub    $0x28,%rsp
   0x0000000000400f02 <+6>:     mov    %rsp,%rsi
   0x0000000000400f05 <+9>:     callq  0x40145c <read_six_numbers>
   0x0000000000400f0a <+14>:    cmpl   $0x1,(%rsp)
   0x0000000000400f0e <+18>:    je     0x400f30 <phase_2+52>
   0x0000000000400f10 <+20>:    callq  0x40143a <explode_bomb>
   0x0000000000400f15 <+25>:    jmp    0x400f30 <phase_2+52>
   0x0000000000400f17 <+27>:    mov    -0x4(%rbx),%eax
   0x0000000000400f1a <+30>:    add    %eax,%eax
   0x0000000000400f1c <+32>:    cmp    %eax,(%rbx)
   0x0000000000400f1e <+34>:    je     0x400f25 <phase_2+41>
   0x0000000000400f20 <+36>:    callq  0x40143a <explode_bomb>
   0x0000000000400f25 <+41>:    add    $0x4,%rbx
   0x0000000000400f29 <+45>:    cmp    %rbp,%rbx
   0x0000000000400f2c <+48>:    jne    0x400f17 <phase_2+27>
   0x0000000000400f2e <+50>:    jmp    0x400f3c <phase_2+64>
   0x0000000000400f30 <+52>:    lea    0x4(%rsp),%rbx
   0x0000000000400f35 <+57>:    lea    0x18(%rsp),%rbp
   0x0000000000400f3a <+62>:    jmp    0x400f17 <phase_2+27>
   0x0000000000400f3c <+64>:    add    $0x28,%rsp
   0x0000000000400f40 <+68>:    pop    %rbx
   0x0000000000400f41 <+69>:    pop    %rbp
   0x0000000000400f42 <+70>:    retq
```

<+14>, <+18>을 보면 스택의 탑이 1일 <+52>로 가도록 만들어졌다.
그 외의 경우는 폭탄이 터진다.
프로그램의 흐름을 보면 (%rsp)에 scanf로 받은 첫 번째 글자가 들어갈 것이다.
이를 확인하기 위해 ni 명령어로 한 줄씩 실행시킨 다음 %rsp의 값을 보면, 첫 번째로 입력한 값이 들어가는 것을 볼 수 있다.

다음을
